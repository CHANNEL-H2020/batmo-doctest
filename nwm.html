<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>nwm: Near Wellbore Modelling &mdash; The Matlab Reservoir Simulation Toolbox 2019b documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="opm_gridprocessing" href="opm_gridprocessing.html" />
    <link rel="prev" title="msrsb: Multiscale Restriction-Smoothed Basis method for pressure" href="msrsb.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> The Matlab Reservoir Simulation Toolbox
            <img src="_static/mrstlogo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2019b
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="core.html">Core functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-core.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code>: Automatic Differentiation Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-props.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-props</span></code>: PVT, fluid models and other properties for the AD-solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-blackoil.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-blackoil</span></code>: Black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-eor.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-eor</span></code>: Enhanced oil recovery solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-mechanics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-mechanics</span></code>: Coupled flow and mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="adjoint.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">adjoint</span></code>: Two-phase, incompressible adjoint solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="agglom.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">agglom</span></code>: Flow and property-based coarse-grid generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="blackoil-sequential.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">blackoil-sequential</span></code>: Sequential implicit black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="book.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">book</span></code>: Book examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="coarsegrid.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">coarsegrid</span></code>: Generation of coarse grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="compositional.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">compositional</span></code>: Equation-of-state compositional solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="co2lab.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">co2lab</span></code>: Numerical CO<sub>2</sub> laboratory</a></li>
<li class="toctree-l1"><a class="reference internal" href="deckformat.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">deckformat</span></code>: Reading and conversion of input decks</a></li>
<li class="toctree-l1"><a class="reference internal" href="dfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dfm</span></code>: Discrete fracture matrix implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="dg.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dg</span></code>: Discontinous Galerkin discretizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">diagnostics</span></code>: Flow diagnostics functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="dual_porosity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dual-porosity</span></code>: Dual porosity/permeability model for fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="fvbiot.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fvbiot</span></code>: Consistent finite-volume discretizations for poroelasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="geochemistry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">geochemistry</span></code>: Surface geochemistry</a></li>
<li class="toctree-l1"><a class="reference internal" href="heterogeneity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">heterogeneity</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="hfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hfm</span></code>: Hierarchical and embedded fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="incomp.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">incomp</span></code>: Solvers for incompressible flow and transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="libgeometry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">libgeometry</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="linearsolvers.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">linearsolvers</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="matlab_bgl.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">matlab_bgl</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="mimetic.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mimetic</span></code>: Mimetic solvers for pressure problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mpfa</span></code>: Multi-point flux approximation solvers for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst_api.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst_api</span></code>: API for writing C/C++ for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst-gui.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst-gui</span></code>: Graphical user-interfaces for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="msfvm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msfvm</span></code>: Multiscale Finite-Volume method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msmfem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msmfem</span></code>: Multiscale Mixed Finite-Element method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msrsb.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msrsb</span></code>: Multiscale Restriction-Smoothed Basis method for pressure</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nwm</span></code>: Near Wellbore Modelling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="opm_gridprocessing.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">opm_gridprocessing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">optimization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="re-mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">re-mpfa</span></code>: Richards’ equation with multi-point flux</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvent.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solvent</span></code>: Solvent solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="spe10.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">spe10</span></code>: Access to the SPE10 benchmark case</a></li>
<li class="toctree-l1"><a class="reference internal" href="steady-state.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">steady-state</span></code> Steady-state upscaling of functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamlines.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">streamlines</span></code>: Compute streamlines</a></li>
<li class="toctree-l1"><a class="reference internal" href="triangle.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">triangle</span></code>: Triangular grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="upscaling.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaling</span></code>: Upscaling of reservoir problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="vem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vem</span></code>: Virtual element method on general grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="vemmech.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vemmech</span></code>: Mechanics for general grids using the virtual element method</a></li>
<li class="toctree-l1"><a class="reference internal" href="wellpaths.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">wellpaths</span></code>: Generation of wells using general curves</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Matlab Reservoir Simulation Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nwm</span></code>: Near Wellbore Modelling</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/nwm.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="module-nwm.models">
<span id="nwm-near-wellbore-modelling"></span><h1><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nwm</span></code>: Near Wellbore Modelling<a class="headerlink" href="#module-nwm.models" title="Permalink to this headline"></a></h1>
<dl class="mat class">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">HorWellRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">regionIndices</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion" title="Permalink to this definition"></a></dt>
<dd><p>Class for horizontal well (HW) region in volume of interest (VOI) grid
which generates the geometrical information of VOI grid and constructs
the radial HW grid</p>
<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.HorWellRegion">
<span class="sig-name descname"><span class="pre">HorWellRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">regionIndices</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.HorWellRegion" title="Permalink to this definition"></a></dt>
<dd><p>The HW grid is built inside the Cartesian region of VOI grid.
And the logical indices of HW region are specified.</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1   ymin                     ymax   ny</p>
</div></blockquote>
<p>—– —– —– —– —– —– —–</p>
</div></blockquote>
<div class="line-block">
<div class="line">|     |     |     |     |     |     |    1
—– —– —– —– —– —– —–</div>
<div class="line">|  *  |  *  |  *  |  *  |  *  |     |   zmin
—– —– —– —– —– —– —–</div>
<div class="line">|  *  |  *  |  *  |  *  |  *  |     |
—– —– —– —– —– —– —–</div>
<div class="line">|  *  |  *  |  *  |  *  |  *  |     |   zmax
—– —– —– —– —– —– —–</div>
<div class="line">|     |     |     |     |     |     |    nz
—– —– —– —– —– —– —–</div>
</div>
<ul class="simple">
<li><p>= HW region</p></li>
</ul>
<dl class="simple">
<dt>Remarks:    1 &lt; ymin &lt; ymax &lt; ny (GV.children.cartDims(2))</dt><dd><p>1 &lt; zmin &lt; zmax &lt; nz (GV.layers.num)</p>
</dd>
</dl>
<p>regionIndices: [ymin, ymax, zmin, zmax]</p>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.IDOfFourVertices">
<span class="sig-name descname"><span class="pre">IDOfFourVertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.IDOfFourVertices" title="Permalink to this definition"></a></dt>
<dd><p>Get the indices of four vertices in boundary nodes</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.ReConstructToRadialGrid">
<span class="sig-name descname"><span class="pre">ReConstructToRadialGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">radPara</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.ReConstructToRadialGrid" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct VOI grid in HW region to layered radial grid.
Two types of grid lines are provided:
‘pureCircular’ : The radial grid lines are pure circular
‘gradual’      : The radial grid lines vary from the circular</p>
<blockquote>
<div><p>line to the rectangular line of a specified
box gradually</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>GV</strong> – The layered VOI grid, built by
‘VolumeOfInterest.ReConstructGrid’</p></li>
<li><p><strong>radPara</strong> – <p>Parameters for generating the radial grid
The type ‘pureCircular’ requires following fields:</p>
<blockquote>
<div><p>’maxRadius’: Max radius of the radial grid
‘nRadCells’: Number of radial cells</p>
</div></blockquote>
<dl>
<dt>The type ‘gradual’ requires following fields:</dt><dd><blockquote>
<div><dl class="simple">
<dt>’boxRatio’<span class="classifier">Size ratio of the rectangular box</span></dt><dd><p>to the outer boundary, 2x1 double,
[yRatio, zRatio]</p>
</dd>
<dt>’nRadCells’: Number of radial cells, 2x1 double,</dt><dd><p>[inbox, outbox]</p>
</dd>
<dt>’pDMult’<span class="classifier">Multiplier of pD of the outer-most</span></dt><dd><p>angular line to PD of wellbore
line, the larger the pDMult is,
the outer-most line is closer to
the box</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>’offCenter’:  Whether the well is off-center in</dt><dd><p>the radial grid</p>
</dd>
</dl>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>GW</strong> – Layered radial HW grid</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.allInfoOfRegion">
<span class="sig-name descname"><span class="pre">allInfoOfRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.allInfoOfRegion" title="Permalink to this definition"></a></dt>
<dd><p>Get all information of the region, consisting of cells,
layer-faces, nodes of layer-faces, boundary nodes, indices of
vertices.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.assignCartDimsOfVOIGrid">
<span class="sig-name descname"><span class="pre">assignCartDimsOfVOIGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.assignCartDimsOfVOIGrid" title="Permalink to this definition"></a></dt>
<dd><p>Assign Cartesian dimensions of VOI grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.assignRegionIndices">
<span class="sig-name descname"><span class="pre">assignRegionIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.assignRegionIndices" title="Permalink to this definition"></a></dt>
<dd><p>Assign the region indices</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.bdyNodesOfRegion">
<span class="sig-name descname"><span class="pre">bdyNodesOfRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.bdyNodesOfRegion" title="Permalink to this definition"></a></dt>
<dd><p>Get boundary nodes of HW region in VOI grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.cartCellsOfVOIGrid">
<span class="sig-name descname"><span class="pre">cartCellsOfVOIGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.cartCellsOfVOIGrid" title="Permalink to this definition"></a></dt>
<dd><p>Get cells of VOI grid in Cartesian region</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.cellsOfRegion">
<span class="sig-name descname"><span class="pre">cellsOfRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.cellsOfRegion" title="Permalink to this definition"></a></dt>
<dd><p>Get cells of HW region in VOI grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.checkRegionIndices">
<span class="sig-name descname"><span class="pre">checkRegionIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.checkRegionIndices" title="Permalink to this definition"></a></dt>
<dd><p>Check whether the region indices exceed the Cartesian reigon
dimension of the VOI grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.facesOfRegion">
<span class="sig-name descname"><span class="pre">facesOfRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">c</span></em>, <em class="sig-param"><span class="pre">n</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.facesOfRegion" title="Permalink to this definition"></a></dt>
<dd><p>Get layer-faces of HW region in VOI grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.getNodesSingleSurface">
<span class="sig-name descname"><span class="pre">getNodesSingleSurface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.getNodesSingleSurface" title="Permalink to this definition"></a></dt>
<dd><p>Get nodes of HW region in VOI grid on single surface</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.nodesOfRegion">
<span class="sig-name descname"><span class="pre">nodesOfRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.nodesOfRegion" title="Permalink to this definition"></a></dt>
<dd><p>Get nodes of layer-faces of HW region in VOI grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.plotRegionCells">
<span class="sig-name descname"><span class="pre">plotRegionCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">packed</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.plotRegionCells" title="Permalink to this definition"></a></dt>
<dd><p>Plot cells inside the HW region</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.plotRegionLayerFaces">
<span class="sig-name descname"><span class="pre">plotRegionLayerFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">packed</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.plotRegionLayerFaces" title="Permalink to this definition"></a></dt>
<dd><p>Plot layer-faces of the HW region</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.showWellRegionInVOIGrid">
<span class="sig-name descname"><span class="pre">showWellRegionInVOIGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">hw</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.HorWellRegion.showWellRegionInVOIGrid" title="Permalink to this definition"></a></dt>
<dd><p>Show the well region in the VOI grid</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.GVOI">
<span class="sig-name descname"><span class="pre">GVOI</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.HorWellRegion.GVOI" title="Permalink to this definition"></a></dt>
<dd><p>Layered unstructured VOI grid</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.regionIndices">
<span class="sig-name descname"><span class="pre">regionIndices</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.HorWellRegion.regionIndices" title="Permalink to this definition"></a></dt>
<dd><p>Logical indices of HW region in VOI grid</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.HorWellRegion.well">
<span class="sig-name descname"><span class="pre">well</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.HorWellRegion.well" title="Permalink to this definition"></a></dt>
<dd><p>Structure of well information</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="nwm.models.MultiSegWellNWM">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">MultiSegWellNWM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">subGrids</span></em>, <em class="sig-param"><span class="pre">deck</span></em>, <em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.MultiSegWellNWM" title="Permalink to this definition"></a></dt>
<dd><p>Derived class for generating necessary data structures passed to the mrst
AD simulators for the hybrid grid of near-wellbore model coupling with
the multi-segment well model</p>
<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.MultiSegWellNWM.buildWellboreGrid">
<span class="sig-name descname"><span class="pre">buildWellboreGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">msw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.MultiSegWellNWM.buildWellboreGrid" title="Permalink to this definition"></a></dt>
<dd><p>Build grid for the void space inside wellbore</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.MultiSegWellNWM.generateNodes">
<span class="sig-name descname"><span class="pre">generateNodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">msw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.MultiSegWellNWM.generateNodes" title="Permalink to this definition"></a></dt>
<dd><p>Generate node definitions from the wellbore grid for
multi-segment well</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.MultiSegWellNWM.generateSegments">
<span class="sig-name descname"><span class="pre">generateSegments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">msw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.MultiSegWellNWM.generateSegments" title="Permalink to this definition"></a></dt>
<dd><p>Generate segment definitions from the wellbore grid for
multi-segment well</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.MultiSegWellNWM.getSimSchedule">
<span class="sig-name descname"><span class="pre">getSimSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">msw</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.MultiSegWellNWM.getSimSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Get the multi-segment well simulation schedule from deck and
node/segment definitions</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.MultiSegWellNWM.plotSegments">
<span class="sig-name descname"><span class="pre">plotSegments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">msw</span></em>, <em class="sig-param"><span class="pre">nodes</span></em>, <em class="sig-param"><span class="pre">segs</span></em>, <em class="sig-param"><span class="pre">S</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.MultiSegWellNWM.plotSegments" title="Permalink to this definition"></a></dt>
<dd><p>Plot the nodes and reservoir cells assoicated with segment S</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.MultiSegWellNWM.setupSimModel">
<span class="sig-name descname"><span class="pre">setupSimModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">T_all</span></em>, <em class="sig-param"><span class="pre">N_all</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.MultiSegWellNWM.setupSimModel" title="Permalink to this definition"></a></dt>
<dd><p>Setup simulation model passed to ad-blackoil simulator for
the global grid (the multi-segment well model now only
supports the ‘ThreePhaseBlackOilModel’)
rock:  Rock of the global grid
T_all: Full transmissibility
N_all: Neighborship of all connections</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.MultiSegWellNWM.wellboreGrid">
<span class="sig-name descname"><span class="pre">wellboreGrid</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.MultiSegWellNWM.wellboreGrid" title="Permalink to this definition"></a></dt>
<dd><p>1D ‘wellbore grid’ in the void wellbore space which</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">NearWellboreModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">subGrids</span></em>, <em class="sig-param"><span class="pre">deck</span></em>, <em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel" title="Permalink to this definition"></a></dt>
<dd><p>Class for generating necessary data structures passed to the mrst AD
simulators for the hybrid grid of near-wellbore model</p>
<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.assembleTransNeighbors">
<span class="sig-name descname"><span class="pre">assembleTransNeighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">T</span></em>, <em class="sig-param"><span class="pre">nnc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.assembleTransNeighbors" title="Permalink to this definition"></a></dt>
<dd><p>Assemble transmissibility and neighborship for the simulation
model</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.assignInputSubGrdTypes">
<span class="sig-name descname"><span class="pre">assignInputSubGrdTypes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.assignInputSubGrdTypes" title="Permalink to this definition"></a></dt>
<dd><p>Assign types of input subgrids</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.assignInputSubGrds">
<span class="sig-name descname"><span class="pre">assignInputSubGrds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.assignInputSubGrds" title="Permalink to this definition"></a></dt>
<dd><p>Assign subgrids from input</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.assignSubGrdTypes">
<span class="sig-name descname"><span class="pre">assignSubGrdTypes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.assignSubGrdTypes" title="Permalink to this definition"></a></dt>
<dd><p>Assign types of updated subgrids</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.assignSubGrds">
<span class="sig-name descname"><span class="pre">assignSubGrds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.assignSubGrds" title="Permalink to this definition"></a></dt>
<dd><p>Assign updated subgrids from the global grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.assignSubRocks">
<span class="sig-name descname"><span class="pre">assignSubRocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">rock</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.assignSubRocks" title="Permalink to this definition"></a></dt>
<dd><p>Assign rocks from the global rock for updated subgrids</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.cellMapFromInputSubGrdsToGloGrd">
<span class="sig-name descname"><span class="pre">cellMapFromInputSubGrdsToGloGrd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.cellMapFromInputSubGrdsToGloGrd" title="Permalink to this definition"></a></dt>
<dd><p>Cell map from input subgrids to global grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.cellMapFromSubGrdsToGloGrd">
<span class="sig-name descname"><span class="pre">cellMapFromSubGrdsToGloGrd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.cellMapFromSubGrdsToGloGrd" title="Permalink to this definition"></a></dt>
<dd><p>Cell map from updated subgrids (after-remove cells) to global
grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.checkCellMaps">
<span class="sig-name descname"><span class="pre">checkCellMaps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.checkCellMaps" title="Permalink to this definition"></a></dt>
<dd><p>Check the cell maps</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.checkFaceMaps">
<span class="sig-name descname"><span class="pre">checkFaceMaps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.checkFaceMaps" title="Permalink to this definition"></a></dt>
<dd><p>Check the face maps</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.checkIntxnRelation">
<span class="sig-name descname"><span class="pre">checkIntxnRelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">intXn</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.checkIntxnRelation" title="Permalink to this definition"></a></dt>
<dd><p>Check the intersection relation by comparing the face areas</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.computeCPGHalfTrans">
<span class="sig-name descname"><span class="pre">computeCPGHalfTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">rock</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.computeCPGHalfTrans" title="Permalink to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">Flow          | Permeability   | Anisotropy |</div>
<div class="line">approximation | coordinate     |            |</div>
</div>
<p><a href="#id79"><span class="problematic" id="id80">|---------------------------------------------|</span></a>
| Linear        | Local          | Yes        |
———————————————–</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.computeHWGrdHalfTrans">
<span class="sig-name descname"><span class="pre">computeHWGrdHalfTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">rock</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.computeHWGrdHalfTrans" title="Permalink to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">Flow          | Permeability   | Anisotropy |</div>
<div class="line">approximation | coordinate     |            |</div>
</div>
<p><a href="#id81"><span class="problematic" id="id82">|---------------------------------------------|</span></a>
| Radial        | Global         | Yes        |
———————————————–</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.computeIntxnRelation">
<span class="sig-name descname"><span class="pre">computeIntxnRelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.computeIntxnRelation" title="Permalink to this definition"></a></dt>
<dd><p>Compute intersection relations between subgrids</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.computeVOIGrdHalfTrans">
<span class="sig-name descname"><span class="pre">computeVOIGrdHalfTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">rock</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.computeVOIGrdHalfTrans" title="Permalink to this definition"></a></dt>
<dd><div class="line-block">
<div class="line">Flow          | Permeability   | Anisotropy |</div>
<div class="line">approximation | coordinate     |            |</div>
</div>
<p><a href="#id83"><span class="problematic" id="id84">|---------------------------------------------|</span></a>
| Linear        | Global         | No         |
———————————————–</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.faceMapFromInputSubGrdsToGloGrd">
<span class="sig-name descname"><span class="pre">faceMapFromInputSubGrdsToGloGrd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.faceMapFromInputSubGrdsToGloGrd" title="Permalink to this definition"></a></dt>
<dd><p>Face map from input subgrids to global grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.faceMapFromSubGrdsToGloGrd">
<span class="sig-name descname"><span class="pre">faceMapFromSubGrdsToGloGrd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.faceMapFromSubGrdsToGloGrd" title="Permalink to this definition"></a></dt>
<dd><p>Face map from updated subgrids (after-remove cells) to global
grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.generateNonNeighborConn">
<span class="sig-name descname"><span class="pre">generateNonNeighborConn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">intXn</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">T</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.generateNonNeighborConn" title="Permalink to this definition"></a></dt>
<dd><p>Generate the non-neighbor connections (NNCs)
intXn: Boundary intersection relations
rock:  Rock of global grid
T:     Fully transmissibility of global grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getCPGRockFromDeck">
<span class="sig-name descname"><span class="pre">getCPGRockFromDeck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getCPGRockFromDeck" title="Permalink to this definition"></a></dt>
<dd><p>Get the rock of input CPG from input deck</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getCPGSimSchedule">
<span class="sig-name descname"><span class="pre">getCPGSimSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getCPGSimSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Get the simulation schedule for input CPG from deck</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getGlobalRock">
<span class="sig-name descname"><span class="pre">getGlobalRock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">rocks</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getGlobalRock" title="Permalink to this definition"></a></dt>
<dd><p>Get the rock for the global grid
rocks = {rockC, rockV, rockW}
————————————————————-
| Rock  | Grid  | Source        | Permeability | Anisotropy |
|       |       |               | coordinate   |            |
<a href="#id85"><span class="problematic" id="id86">|-----------------------------------------------------------|</span></a>
| rockC | Input | Input deck    | Local        | Yes        |
|       | GC    |               |              |            |
<a href="#id87"><span class="problematic" id="id88">|-----------------------------------------------------------|</span></a>
| rockV | Input | Interpolation | Global       | Yes        |
|       | GV    | of rockC      |              |            |
<a href="#id89"><span class="problematic" id="id90">|-----------------------------------------------------------|</span></a>
| rockW | Input | User-defined  | Global       | No         |
|       | GW    |               |              |            |
————————————————————-</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getGrdEclFromDeck">
<span class="sig-name descname"><span class="pre">getGrdEclFromDeck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getGrdEclFromDeck" title="Permalink to this definition"></a></dt>
<dd><p>Get ECLIPSE grid structure from deck</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getInitState">
<span class="sig-name descname"><span class="pre">getInitState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getInitState" title="Permalink to this definition"></a></dt>
<dd><p>Get initial state by equilibrium initialization</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getPhaseFromDeck">
<span class="sig-name descname"><span class="pre">getPhaseFromDeck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getPhaseFromDeck" title="Permalink to this definition"></a></dt>
<dd><p>Get phase components from input deck</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getRadTransFactors">
<span class="sig-name descname"><span class="pre">getRadTransFactors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getRadTransFactors" title="Permalink to this definition"></a></dt>
<dd><p>Get the radial half transmissibility factors for the HW grid
Get the factors of the 2D surface grids first</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getSimSchedule">
<span class="sig-name descname"><span class="pre">getSimSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getSimSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Get the simulation schedule for the global grid from the
production/injection control data in deck</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getTransGloGrid">
<span class="sig-name descname"><span class="pre">getTransGloGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">rock</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getTransGloGrid" title="Permalink to this definition"></a></dt>
<dd><p>Compute the transmissibility for the global grid
rock: rock of the global grid
The transmissibility consists of:
Transmissibility of updated [CPG, VOI grid, and HW grid]</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getVOIRocksByInterp">
<span class="sig-name descname"><span class="pre">getVOIRocksByInterp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getVOIRocksByInterp" title="Permalink to this definition"></a></dt>
<dd><p>Get the rock of input VOI grid by interpolation of CPG rock
Optional:</p>
<blockquote>
<div><p>‘InterpMethod’, same with opitions in ‘griddata’:
‘linear’ (default) | ‘nearest’ | ‘natural’ | ‘cubic’ | ‘v4’</p>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getWellCellPara">
<span class="sig-name descname"><span class="pre">getWellCellPara</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getWellCellPara" title="Permalink to this definition"></a></dt>
<dd><p>Get parameters for well cells of the HW
wc: well cell indices
wf: well face indices
WI: well indices of well cells</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.getWellCells">
<span class="sig-name descname"><span class="pre">getWellCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.getWellCells" title="Permalink to this definition"></a></dt>
<dd><p>Get well cell indices</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.matchingIntxnRelation">
<span class="sig-name descname"><span class="pre">matchingIntxnRelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">grdInd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.matchingIntxnRelation" title="Permalink to this definition"></a></dt>
<dd><p>Compute intersection relations of matching faces on the
layered boundaries of input subgrids
gridInd: Indices of the subgrids involving in the computation</p>
<blockquote>
<div><p>[i-1, i], i &lt;= number of subgrids</p>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.nncOfMatchingBoundaries">
<span class="sig-name descname"><span class="pre">nncOfMatchingBoundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">intXn</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">T</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.nncOfMatchingBoundaries" title="Permalink to this definition"></a></dt>
<dd><p>Generate non-neighbor connections (NNCs) arised from the
matching boundaries
intXn: Boundary intersection relations
rock:  Rock of global grid
T:     Fully transmissibility of global grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.nncOfNonMatchingBoundaries">
<span class="sig-name descname"><span class="pre">nncOfNonMatchingBoundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">intXn</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">T</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.nncOfNonMatchingBoundaries" title="Permalink to this definition"></a></dt>
<dd><p>Generate non-neighbor connections (NNCs) arised from the
non-matching boundaries
intXn: Boundary intersection relations
rock:  Rock of global grid
T:     Fully transmissibility of global grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.nonMatchingIntxnRelation">
<span class="sig-name descname"><span class="pre">nonMatchingIntxnRelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">grdInd</span></em>, <em class="sig-param"><span class="pre">bdyLoc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.nonMatchingIntxnRelation" title="Permalink to this definition"></a></dt>
<dd><p>Compute intersection relations of non-matching faces on
the boundaries of input subgrids
gridInd: Indices of the subgrids involving in the computation</p>
<blockquote>
<div><p>[i-1, i], i &lt;= number of subgrids</p>
</div></blockquote>
<dl class="simple">
<dt>bdyLoc:  The location of boundaries</dt><dd><p>‘top’  | ‘bot’ for CPG and VOI grid
‘heel’ | ‘toe’ for VOI grid and HW grid</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.packedCPGSimData">
<span class="sig-name descname"><span class="pre">packedCPGSimData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.packedCPGSimData" title="Permalink to this definition"></a></dt>
<dd><p>Obtain all necessary simulation data structures of the CPG
CPG</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.packedSimData">
<span class="sig-name descname"><span class="pre">packedSimData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">rockW</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.packedSimData" title="Permalink to this definition"></a></dt>
<dd><p>Obtain all necessary simulation data structures of the hybrid
grid in near-wellbore model
Global grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.plotMatchingIntxnRelation">
<span class="sig-name descname"><span class="pre">plotMatchingIntxnRelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">intXn</span></em>, <em class="sig-param"><span class="pre">f1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.plotMatchingIntxnRelation" title="Permalink to this definition"></a></dt>
<dd><p>Plot the intersection relations of matching face f1</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.plotNonMatchingIntxnRelation">
<span class="sig-name descname"><span class="pre">plotNonMatchingIntxnRelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">intXn</span></em>, <em class="sig-param"><span class="pre">f1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.plotNonMatchingIntxnRelation" title="Permalink to this definition"></a></dt>
<dd><p>Plot the intersection relations of non-matching face f1</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.setupCPGSimModel">
<span class="sig-name descname"><span class="pre">setupCPGSimModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.setupCPGSimModel" title="Permalink to this definition"></a></dt>
<dd><p>Setup simulation model passed to ad-blackoil simulator for
the input CPG grid</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.setupFluid">
<span class="sig-name descname"><span class="pre">setupFluid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.setupFluid" title="Permalink to this definition"></a></dt>
<dd><p>Initialize AD fluid from input deck</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.setupSimModel">
<span class="sig-name descname"><span class="pre">setupSimModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">T_all</span></em>, <em class="sig-param"><span class="pre">N_all</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.setupSimModel" title="Permalink to this definition"></a></dt>
<dd><p>Setup simulation model passed to ad-blackoil simulator for
the global grid
rock:  Rock of global grid
T_all: Full transmissibility
N_all: Neighborship of all connections</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.validateGlobalGrid">
<span class="sig-name descname"><span class="pre">validateGlobalGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nwm</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.NearWellboreModel.validateGlobalGrid" title="Permalink to this definition"></a></dt>
<dd><p>Validate the global hybrid grid by subgrids
Get updated subgrids (cells in VOI and HW region are removed)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.fluid">
<span class="sig-name descname"><span class="pre">fluid</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.NearWellboreModel.fluid" title="Permalink to this definition"></a></dt>
<dd><p>AD-solver fluid from ECLIPSE-style input deck</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.gloGrid">
<span class="sig-name descname"><span class="pre">gloGrid</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.NearWellboreModel.gloGrid" title="Permalink to this definition"></a></dt>
<dd><p>The global hybrid grid</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.inputDeck">
<span class="sig-name descname"><span class="pre">inputDeck</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.NearWellboreModel.inputDeck" title="Permalink to this definition"></a></dt>
<dd><p>ECLIPSE-style input deck of CPG</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.subGrids">
<span class="sig-name descname"><span class="pre">subGrids</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.NearWellboreModel.subGrids" title="Permalink to this definition"></a></dt>
<dd><p>Subgrids {Corner-point grid (CPG), VOI grid, HW grid}</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.NearWellboreModel.well">
<span class="sig-name descname"><span class="pre">well</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.NearWellboreModel.well" title="Permalink to this definition"></a></dt>
<dd><p>Structure of well information</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">VolumeOfInterest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">pbdy</span></em>, <em class="sig-param"><span class="pre">nextra</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest" title="Permalink to this definition"></a></dt>
<dd><p>Class for volume of interest (VOI) in the Corner-point grid (CPG) or
Cartesian grid which generates the geometrical information of CPG or
Cartesian grid in VOI and constructs the unstructured VOI grid.</p>
<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.PeacemanWellCells">
<span class="sig-name descname"><span class="pre">PeacemanWellCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.PeacemanWellCells" title="Permalink to this definition"></a></dt>
<dd><p>Find well cells of Peaceman’s well model, require ‘wellpaths’
module</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.ReConstructToUnstructuredGrid">
<span class="sig-name descname"><span class="pre">ReConstructToUnstructuredGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">WR</span></em>, <em class="sig-param"><span class="pre">layerRf</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.ReConstructToUnstructuredGrid" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct CPG in VOI to layered unstructured grid.
The open-source triangle generator ‘DistMesh’
(Per-Olof Persson) is used to obtain high-quality triangles.
The scaled edge length function is defined as:
h(p) = max(multiplier*d(p) +lIB, lOB)
to let the point density increases from inner boundary to
outer boundary
lIB: average length of inner boundary (outer-boundary of WR subgrid)
lOB: average length of outer boundary (VOI clipped boundary)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>WR</strong> – The 2D well region struct, including the node and
topology information. Generated by
‘prepareWellRegionNodes2D’</p></li>
<li><p><strong>layerRf</strong> – Number of refinement layers in each VOI layer</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘multiplier’</strong> – Multiplier of the scaled edge length function</p></li>
<li><p><strong>‘maxIter’</strong> – The maximum number of DistMesh iterations</p></li>
<li><p><strong>‘gridType’</strong> – Grid type, ‘Voronoi’ (default) | ‘triangular’</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>GV</strong> – Layered unstructured VOI grid</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.allInfoOfVolume">
<span class="sig-name descname"><span class="pre">allInfoOfVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.allInfoOfVolume" title="Permalink to this definition"></a></dt>
<dd><p>Get all information of the volume</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.boundaryInfoOfVolume">
<span class="sig-name descname"><span class="pre">boundaryInfoOfVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.boundaryInfoOfVolume" title="Permalink to this definition"></a></dt>
<dd><p>Get all boundary nodes and layer-faces of the volume</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.boxCellsOfVolume">
<span class="sig-name descname"><span class="pre">boxCellsOfVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.boxCellsOfVolume" title="Permalink to this definition"></a></dt>
<dd><p>Get all box cells of the volume</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.cellsOfVolume">
<span class="sig-name descname"><span class="pre">cellsOfVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.cellsOfVolume" title="Permalink to this definition"></a></dt>
<dd><p>Get all cells of the volume</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.facesOfVolume">
<span class="sig-name descname"><span class="pre">facesOfVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">c</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.facesOfVolume" title="Permalink to this definition"></a></dt>
<dd><p>Get all layer-faces of the volume</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.getBoundaryInfoSingleSurface">
<span class="sig-name descname"><span class="pre">getBoundaryInfoSingleSurface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.getBoundaryInfoSingleSurface" title="Permalink to this definition"></a></dt>
<dd><p>Get boundary information of faces on single surface
bn:  sorted boundary nodes
bf:  sorted boundary faces</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.getBoxCellsSingleLayer">
<span class="sig-name descname"><span class="pre">getBoxCellsSingleLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">k</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.getBoxCellsSingleLayer" title="Permalink to this definition"></a></dt>
<dd><p>Get layer-k box cells. The defined 2D boundary located inside
the box. This will be useful in the interpolations of rock
properties.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.getCellsSingleLayer">
<span class="sig-name descname"><span class="pre">getCellsSingleLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">k</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.getCellsSingleLayer" title="Permalink to this definition"></a></dt>
<dd><p>Get layer-k cells inside the defined 2D polygon</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.getLayerFacesFromCells">
<span class="sig-name descname"><span class="pre">getLayerFacesFromCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">c</span></em>, <em class="sig-param"><span class="pre">indicator</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.getLayerFacesFromCells" title="Permalink to this definition"></a></dt>
<dd><p>Get layer-faces of cell c in single layer
For CPG or Cartesian grid, the layer-faces are Z- and Z+
faces</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.getNodesFromFaces">
<span class="sig-name descname"><span class="pre">getNodesFromFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.getNodesFromFaces" title="Permalink to this definition"></a></dt>
<dd><p>Get nodes of layer-faces on single surface</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.ijIndicesFromBoundary">
<span class="sig-name descname"><span class="pre">ijIndicesFromBoundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.ijIndicesFromBoundary" title="Permalink to this definition"></a></dt>
<dd><p>Get i and j indices f the volume from the defined 2D boundary</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.kIndicesFromExtraLayers">
<span class="sig-name descname"><span class="pre">kIndicesFromExtraLayers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.kIndicesFromExtraLayers" title="Permalink to this definition"></a></dt>
<dd><p>Get the grid layer indices from the extra layers and layers
occupied by the well
nex = number of layers [above, below] the well layers</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.layerFaceIndicator">
<span class="sig-name descname"><span class="pre">layerFaceIndicator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.layerFaceIndicator" title="Permalink to this definition"></a></dt>
<dd><p>Find face indicator of layered dimension (typically is ‘Z’)</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.logicalIndices">
<span class="sig-name descname"><span class="pre">logicalIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.logicalIndices" title="Permalink to this definition"></a></dt>
<dd><p>Get logical indices of CPG</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.logicalToArray">
<span class="sig-name descname"><span class="pre">logicalToArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">ijk</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.logicalToArray" title="Permalink to this definition"></a></dt>
<dd><p>Convert logical indices to array indices</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.maxWellSegLength2D">
<span class="sig-name descname"><span class="pre">maxWellSegLength2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.maxWellSegLength2D" title="Permalink to this definition"></a></dt>
<dd><p>Display the maximum 2D length of well segments</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.nodesOfVolume">
<span class="sig-name descname"><span class="pre">nodesOfVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.nodesOfVolume" title="Permalink to this definition"></a></dt>
<dd><p>Get all nodes of layer-faces of the volume</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.plot2DWRSubGrid">
<span class="sig-name descname"><span class="pre">plot2DWRSubGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">WR</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.plot2DWRSubGrid" title="Permalink to this definition"></a></dt>
<dd><p>Plot the subgrid of the 2D well region</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.plotVolumeBoundaries">
<span class="sig-name descname"><span class="pre">plotVolumeBoundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">packed</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.plotVolumeBoundaries" title="Permalink to this definition"></a></dt>
<dd><p>Plot the user defined boundary and clipped boundary</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.plotVolumeCells">
<span class="sig-name descname"><span class="pre">plotVolumeCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">packed</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.plotVolumeCells" title="Permalink to this definition"></a></dt>
<dd><p>Plot cells inside the volume</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.plotVolumeLayerFaces">
<span class="sig-name descname"><span class="pre">plotVolumeLayerFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">packed</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.plotVolumeLayerFaces" title="Permalink to this definition"></a></dt>
<dd><p>Plot layer-faces of the volume</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.prepareWellRegionNodes2D">
<span class="sig-name descname"><span class="pre">prepareWellRegionNodes2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em>, <em class="sig-param"><span class="pre">WR</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.prepareWellRegionNodes2D" title="Permalink to this definition"></a></dt>
<dd><p>Prepare the 2D well region nodes.
The unstructured VOI grid includes a 2D well region (WR). The
WR is composed of a Cartesian region and two half-radial
regions in xy plane, which are used to connect the HW grid.
This function generates the grid nodes for the three
structured regions.
For the Cartesian region, the X axis extends along the well
trajectory:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>———&gt; X</p>
</div></blockquote>
<div class="line-block">
<div class="line">———————————–</div>
</div>
</div></blockquote>
<dl class="simple">
<dt>Y |    ——— Well trajectory ———</dt><dd><p>V    ———————————–</p>
</dd>
</dl>
</div></blockquote>
<p>PARAMETERS:
WR - The 2D WR structure that consists of following fields:</p>
<blockquote>
<div><p>‘ny’ - The number of Cartesian cells in Y direction
‘ny’ - The size of Cartesian region in Y direction
‘na’ - The number of angular cells in radial region</p>
</div></blockquote>
<p>RETURNS:
The expanded WR structure with node and topology information:</p>
<blockquote>
<div><p>‘points’    - 2D coordinates WR nodes
‘connlist’  - Connectivity list of the whole well region
‘connlistC’ - Connectivity list of the Cartesian region
‘bdnodes’   - Indices of outer boundary nodes of the whole</p>
<blockquote>
<div><p>well region</p>
</div></blockquote>
<dl class="simple">
<dt>‘bdnodesC’  - Indices of outer boundary nodes of the</dt><dd><p>Cartesian region</p>
</dd>
</dl>
<p>‘cartDims’  - Dimensions of the Cartesian region, [nx, ny]</p>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.volumeLayerNumber">
<span class="sig-name descname"><span class="pre">volumeLayerNumber</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">volume</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.models.VolumeOfInterest.volumeLayerNumber" title="Permalink to this definition"></a></dt>
<dd><p>Display the number of volume layers</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.CPG">
<span class="sig-name descname"><span class="pre">CPG</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.VolumeOfInterest.CPG" title="Permalink to this definition"></a></dt>
<dd><p>CPG or Cartesian grid structure</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.boundary">
<span class="sig-name descname"><span class="pre">boundary</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.VolumeOfInterest.boundary" title="Permalink to this definition"></a></dt>
<dd><p>2D VOI boundary specified by the polygon</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.extraLayers">
<span class="sig-name descname"><span class="pre">extraLayers</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.VolumeOfInterest.extraLayers" title="Permalink to this definition"></a></dt>
<dd><p>Extra layers above and below the layers where the</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="nwm.models.VolumeOfInterest.well">
<span class="sig-name descname"><span class="pre">well</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#nwm.models.VolumeOfInterest.well" title="Permalink to this definition"></a></dt>
<dd><p>Structure of well information</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-nwm.gridding"></span><dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.assembleGrids">
<span class="sig-name descname"><span class="pre">assembleGrids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Gs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.assembleGrids" title="Permalink to this definition"></a></dt>
<dd><p>Assemble multiple grids, but does not merge common faces and does not
handle boundary intersections</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Gf</span> <span class="p">=</span> <span class="n">assembleGrids</span><span class="p">(</span><span class="n">Gs</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Gs</strong> – Grids, nGrid x 1, cell</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – The combined grid</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G1</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">]);</span>
<span class="n">G1</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G1</span><span class="p">);</span>
<span class="n">cC1</span> <span class="p">=</span> <span class="nb">find</span><span class="p">(</span><span class="n">G1</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">&amp;</span> <span class="n">G1</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">&amp;</span> <span class="p">...</span>
    <span class="n">G1</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">&amp;</span> <span class="n">G1</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">cC2</span> <span class="p">=</span> <span class="nb">find</span><span class="p">(</span><span class="n">G1</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">18</span> <span class="o">&amp;</span> <span class="n">G1</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">14</span> <span class="o">&amp;</span> <span class="p">...</span>
    <span class="n">G1</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;</span> <span class="n">G1</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">G1</span> <span class="p">=</span> <span class="n">removeCells</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="p">[</span><span class="n">cC1</span><span class="p">;</span> <span class="n">cC2</span><span class="p">]);</span>

<span class="n">G2</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="n">G2</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">G2</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">G2</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="p">=</span> <span class="n">G2</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>

<span class="n">G3</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">G3</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">G3</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">14</span><span class="p">;</span>
<span class="n">G3</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="p">=</span> <span class="n">G3</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

<span class="nb">figure</span><span class="p">,</span> <span class="nb">hold</span> <span class="n">on</span><span class="p">;</span> <span class="nb">axis</span> <span class="n">equal</span> <span class="n">off</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="s">&#39;facecolor&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">113</span><span class="p">,</span> <span class="mi">188</span><span class="p">]</span><span class="o">/</span><span class="mi">255</span><span class="p">)</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="s">&#39;facecolor&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">216</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">24</span><span class="p">]</span><span class="o">/</span><span class="mi">255</span><span class="p">)</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G3</span><span class="p">,</span> <span class="s">&#39;facecolor&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">118</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">47</span><span class="p">]</span><span class="o">/</span><span class="mi">255</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.gridprocessing.glue2DGrid" title="core.gridprocessing.glue2DGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">glue2DGrid</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.buildRadialGrid">
<span class="sig-name descname"><span class="pre">buildRadialGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">nA</span></em>, <em class="sig-param"><span class="pre">nR</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.buildRadialGrid" title="Permalink to this definition"></a></dt>
<dd><p>Build the 2D radial grid from point and dimension definitions</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">G</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">=</span> <span class="n">buildRadialGrid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nA</span><span class="p">,</span> <span class="n">nR</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – 2D node coordinates, obey the logical numbering (angularly
cycle fastest, then radially)</p></li>
<li><p><strong>nA</strong> – Angular cell dimension</p></li>
<li><p><strong>nR</strong> – Radial cell dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul>
<li><p><strong>G</strong> – The 2D radial grid. The cells and nodes obey logical numbering
(angularly cycle fastest, then radially). Each cell has four faces.
The face types are:</p>
<blockquote>
<div><p>Face 1:  Radial  -
Face 2:  Angular +
Face 3:  Radial  +
Face 4:  Angular -</p>
</div></blockquote>
<p>If the points are generated from R+ to R-, the directions of face 1
and 3 will be R+ and R-
If the points are generated in clockwise direction, the directions o
of face 2 and 4 will be A- and A+</p>
</li>
<li><p><strong>t</strong> – Connectivity list</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">nA</span><span class="p">,</span> <span class="n">nR</span><span class="p">,</span> <span class="n">rW</span><span class="p">,</span> <span class="n">rM</span><span class="p">]</span> <span class="p">=</span> <span class="nb">deal</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">th</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">,</span> <span class="n">nA</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="n">th</span> <span class="p">=</span> <span class="n">th</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">r</span> <span class="p">=</span> <span class="nb">logspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">rW</span><span class="p">),</span> <span class="n">log10</span><span class="p">(</span><span class="n">rM</span><span class="p">),</span> <span class="n">nR</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">[</span><span class="n">R</span><span class="p">,</span> <span class="n">TH</span><span class="p">]</span> <span class="p">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">th</span><span class="p">);</span>
<span class="p">[</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">]</span> <span class="p">=</span> <span class="n">pol2cart</span><span class="p">(</span><span class="n">TH</span><span class="p">(:),</span> <span class="n">R</span><span class="p">(:));</span>
<span class="n">p</span> <span class="p">=</span> <span class="p">[</span><span class="n">px</span><span class="p">(:),</span> <span class="n">py</span><span class="p">(:)];</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">buildRadialGrid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nA</span><span class="p">,</span> <span class="n">nR</span><span class="p">)</span>
<span class="nb">figure</span><span class="p">,</span> <span class="nb">axis</span> <span class="n">equal</span><span class="p">,</span> <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">)</span><span class="o">&#39;</span><span class="p">)</span>
<span class="nb">title</span><span class="p">(</span><span class="s">&#39;Cell array indices of the radial grid&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.gridprocessing.tessellationGrid" title="core.gridprocessing.tessellationGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tessellationGrid</span></code></a> <a class="reference internal" href="core.html#core.gridprocessing.pebi" title="core.gridprocessing.pebi"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pebi</span></code></a> <a class="reference internal" href="#nwm.gridding.makeConnListFromMat" title="nwm.gridding.makeConnListFromMat"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeConnListFromMat</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.distmesh_2d_nwm">
<span class="sig-name descname"><span class="pre">distmesh_2d_nwm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fd</span></em>, <em class="sig-param"><span class="pre">fh</span></em>, <em class="sig-param"><span class="pre">h0</span></em>, <em class="sig-param"><span class="pre">box</span></em>, <em class="sig-param"><span class="pre">iteration_max</span></em>, <em class="sig-param"><span class="pre">pfix</span></em>, <em class="sig-param"><span class="pre">plotMesh</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.distmesh_2d_nwm" title="Permalink to this definition"></a></dt>
<dd><p><a href="#id1"><span class="problematic" id="id2">**</span></a><a href="#id3"><span class="problematic" id="id4">**</span></a><a href="#id5"><span class="problematic" id="id6">**</span></a><a href="#id7"><span class="problematic" id="id8">**</span></a><a href="#id9"><span class="problematic" id="id10">**</span></a><a href="#id11"><span class="problematic" id="id12">**</span></a><a href="#id13"><span class="problematic" id="id14">**</span></a><a href="#id15"><span class="problematic" id="id16">**</span></a><a href="#id17"><span class="problematic" id="id18">**</span></a><a href="#id19"><span class="problematic" id="id20">**</span></a><a href="#id21"><span class="problematic" id="id22">**</span></a><a href="#id23"><span class="problematic" id="id24">**</span></a><a href="#id25"><span class="problematic" id="id26">**</span></a><a href="#id27"><span class="problematic" id="id28">**</span></a><a href="#id29"><span class="problematic" id="id30">**</span></a><a href="#id31"><span class="problematic" id="id32">**</span></a><a href="#id33"><span class="problematic" id="id34">**</span></a><a href="#id35"><span class="problematic" id="id36">**</span></a><a href="#id37"><span class="problematic" id="id38">**</span></a><a href="#id39"><span class="problematic" id="id40">**</span></a><a href="#id41"><span class="problematic" id="id42">**</span></a><a href="#id43"><span class="problematic" id="id44">**</span></a><a href="#id45"><span class="problematic" id="id46">**</span></a><a href="#id47"><span class="problematic" id="id48">**</span></a><a href="#id49"><span class="problematic" id="id50">**</span></a><a href="#id51"><span class="problematic" id="id52">**</span></a><a href="#id53"><span class="problematic" id="id54">**</span></a><a href="#id55"><span class="problematic" id="id56">**</span></a><a href="#id57"><span class="problematic" id="id58">**</span></a><a href="#id59"><span class="problematic" id="id60">**</span></a><a href="#id61"><span class="problematic" id="id62">**</span></a><a href="#id63"><span class="problematic" id="id64">**</span></a><a href="#id65"><span class="problematic" id="id66">**</span></a><a href="#id67"><span class="problematic" id="id68">**</span></a><a href="#id69"><span class="problematic" id="id70">**</span></a><a href="#id71"><span class="problematic" id="id72">**</span></a><a href="#id73"><span class="problematic" id="id74">**</span></a><a href="#id75"><span class="problematic" id="id76">**</span></a><a href="#id77"><span class="problematic" id="id78">*</span></a>80</p>
<p>DISTMESH_2D is a 2D mesh generator using distance functions.</p>
<blockquote>
<div><p>Example:</p>
<blockquote>
<div><p>Uniform Mesh on Unit Circle:</p>
<blockquote>
<div><p>fd = inline(‘sqrt(sum(p.^2,2))-1’,’p’);
[p,t] = distmesh_2d(fd,&#64;huniform,0.2,[-1,-1;1,1],100,[]);</p>
</div></blockquote>
<p>Rectangle with circular hole, refined at circle boundary:</p>
<blockquote>
<div><p>fd = inline(‘ddiff(drectangle(p,-1,1,-1,1),dcircle(p,0,0,0.5))’,’p’);
fh = inline(‘min(4*sqrt(sum(p.^2,2))-1,2)’,’p’);
[p,t] = distmesh_2d(fd,fh,0.05,[-1,-1;1,1],500,[-1,-1;-1,1;1,-1;1,1]);</p>
</div></blockquote>
</div></blockquote>
<p>Licensing:</p>
<blockquote>
<div><p>(C) 2004 Per-Olof Persson.
See COPYRIGHT.TXT for details.</p>
</div></blockquote>
<p>Modified:</p>
<blockquote>
<div><p>09 June 2012</p>
</div></blockquote>
<p>Author:</p>
<blockquote>
<div><p>Per-Olof Persson
Modifications by John Burkardt</p>
</div></blockquote>
<p>Reference:</p>
<blockquote>
<div><p>Per-Olof Persson, Gilbert Strang,
A Simple Mesh Generator in MATLAB,
SIAM Review,
Volume 46, Number 2, June 2004, pages 329-345.</p>
</div></blockquote>
<p>Parameters:</p>
<blockquote>
<div><p>Input, function FD, signed distance function d(x,y).</p>
<p>Input, function FH, scaled edge length function h(x,y).</p>
<p>Input, real H0, the initial edge length.</p>
<p>Input, real BOX(2,2), the bounding box [xmin,ymin; xmax,ymax].</p>
<p>Input, integer ITERATION_MAX, the maximum number of iterations.
The iteration might terminate sooner than this limit, if the program decides
that the mesh has converged.</p>
<p>Input, real PFIX(NFIX,2), the fixed node positions.</p>
<p>Input, VARARGIN, aditional parameters passed to FD and FH.</p>
<p>Output, real P(N,2), the node positions.</p>
<p>Output, integer T(NT,3), the triangle indices.</p>
</div></blockquote>
<p>Local parameters:</p>
<blockquote>
<div><p>Local, real GEPS, a tolerance for determining whether a point is “almost” inside
the region.  Setting GEPS = 0 makes this an exact test.  The program currently
sets it to 0.001 * H0, that is, a very small multiple of the desired side length
of a triangle.  GEPS is also used to determine whether a triangle falls inside
or outside the region.  In this case, the test is a little tighter.  The centroid
PMID is required to satisfy FD ( PMID ) &lt;= -GEPS.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.extractBdyNodesCells">
<span class="sig-name descname"><span class="pre">extractBdyNodesCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">cI</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.extractBdyNodesCells" title="Permalink to this definition"></a></dt>
<dd><p>An 2D version of ‘VolumeOfInterest.getBoundaryInfoSingleSurface’, which
extracts the sorted boundary nodes and cells (in counterclockwise) of a
inner continuous region what we name ‘region of interest (ROI)’ specified
by cells ‘cI’.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">bdNodes</span><span class="p">,</span> <span class="n">bdCells</span><span class="p">]</span> <span class="p">=</span> <span class="n">extractBdyNodesCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cI</span><span class="p">)</span>
<span class="p">[</span><span class="n">bdNodes</span><span class="p">,</span> <span class="n">bdCells</span><span class="p">]</span> <span class="p">=</span> <span class="n">extractBdyNodesCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cI</span><span class="p">,</span> <span class="s">&#39;plotResults&#39;</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – The 2D Cartesian grid</p></li>
<li><p><strong>cI</strong> – Cells that specifies the ROI</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>bdNodes</strong> – The sorted boundary nodes, in counterclockwise</p></li>
<li><p><strong>bdCells</strong> – The sorted boundary cells, in counterclockwise</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">]);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
<span class="n">pbdy</span> <span class="p">=</span> <span class="p">[</span><span class="mi">136</span><span class="p">,</span>  <span class="mi">150</span><span class="p">;</span>
        <span class="mi">145</span><span class="p">,</span>   <span class="mi">95</span><span class="p">;</span>
         <span class="mi">90</span><span class="p">,</span>   <span class="mi">30</span><span class="p">;</span>
         <span class="mi">50</span><span class="p">,</span>   <span class="mi">50</span><span class="p">;</span>
         <span class="mi">45</span><span class="p">,</span>  <span class="mi">105</span><span class="p">;</span>
         <span class="mi">90</span><span class="p">,</span>  <span class="mi">160</span><span class="p">];</span>
<span class="n">cCtro</span> <span class="p">=</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">centroids</span><span class="p">;</span>
<span class="n">in</span> <span class="p">=</span> <span class="nb">inpolygon</span><span class="p">(</span><span class="n">cCtro</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span> <span class="n">cCtro</span><span class="p">(:,</span><span class="mi">2</span><span class="p">),</span> <span class="n">pbdy</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span> <span class="n">pbdy</span><span class="p">(:,</span><span class="mi">2</span><span class="p">));</span>
<span class="n">cI</span> <span class="p">=</span> <span class="nb">find</span><span class="p">(</span> <span class="n">in</span> <span class="p">);</span>
<span class="p">[</span><span class="n">bnv</span><span class="p">,</span> <span class="n">bcv</span><span class="p">]</span> <span class="p">=</span> <span class="n">extractBdyNodesCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cI</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">VolumeOfInterest</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.generateHWGridNodes">
<span class="sig-name descname"><span class="pre">generateHWGridNodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">GV</span></em>, <em class="sig-param"><span class="pre">packed</span></em>, <em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">radPara</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.generateHWGridNodes" title="Permalink to this definition"></a></dt>
<dd><p>Generate 3D points of all radial HW grid surfaces and 2D planar points</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">pSurfs</span><span class="p">,</span> <span class="n">pSurfXY</span><span class="p">,</span> <span class="n">wellbores</span><span class="p">]</span> <span class="p">=</span> <span class="n">generateHWGridNodes</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">packed</span><span class="p">,</span> <span class="n">well</span><span class="p">,</span> <span class="n">radPara</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>GV</strong> – Unstructured VOI grid structure</p></li>
<li><p><strong>packed</strong> – Structure of HW information, see ‘allInfoOfRegion’</p></li>
<li><p><strong>well</strong> – Structure of well information, see
‘nearWellBoreModelingGrids’</p></li>
<li><p><strong>radPara</strong> – Parameters for generating the radial grid, see
‘ReConstructToRadialGrid’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>pSurfs</strong> – 3D points of all HW grid surfaces</p></li>
<li><p><strong>pSurfXY</strong> – pSurfs in xy plane, used to compute the radial
transmissibility factors</p></li>
<li><p><strong>wellbores</strong> – Structure of the casing and screen, used to generate nodes
segments for the multi-segment well</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">HorWellRegion</span></code> <a class="reference internal" href="#nwm.gridding.generateVOIGridNodes" title="nwm.gridding.generateVOIGridNodes"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">generateVOIGridNodes</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.generateVOIGridNodes">
<span class="sig-name descname"><span class="pre">generateVOIGridNodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">GC</span></em>, <em class="sig-param"><span class="pre">packed</span></em>, <em class="sig-param"><span class="pre">WR</span></em>, <em class="sig-param"><span class="pre">layerRf</span></em>, <em class="sig-param"><span class="pre">opt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.generateVOIGridNodes" title="Permalink to this definition"></a></dt>
<dd><p>Generate 3D points of all surfaces of volume of interest (VOI) and
connectivity list corresponding to the 2D planar points</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">pSurfs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">bdyID</span><span class="p">]</span> <span class="p">=</span> <span class="n">generateVOIGridNodes</span><span class="p">(</span><span class="n">GC</span><span class="p">,</span> <span class="n">packed</span><span class="p">,</span> <span class="n">WR</span><span class="p">,</span> <span class="n">layerRf</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>GC</strong> – CPG grid structure</p></li>
<li><p><strong>packed</strong> – Structure of VOI information, see ‘allInfoOfVolume’</p></li>
<li><p><strong>WR</strong> – Structure of 2D WR points, see ‘prepareWellRegionNodes2D’</p></li>
<li><p><strong>layerRf</strong> – Number of refinement layers in each VOI layer</p></li>
<li><p><strong>opt</strong> – Parameters for generating the unstructured grid, see
‘ReConstructToUnstructuredGrid’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>pSurfs</strong> – Points of all VOI grid surfaces</p></li>
<li><p><strong>t</strong> – Connectivity list</p></li>
<li><p><strong>bdyID</strong> – Indices of outer boundary nodes in points pSurfs</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">VolumeOfInterest</span></code> <a class="reference internal" href="#nwm.gridding.generateHWGridNodes" title="nwm.gridding.generateHWGridNodes"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">generateHWGridNodes</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.getConnListAndBdyNodeWR2D">
<span class="sig-name descname"><span class="pre">getConnListAndBdyNodeWR2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">ny</span></em>, <em class="sig-param"><span class="pre">na</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.getConnListAndBdyNodeWR2D" title="Permalink to this definition"></a></dt>
<dd><p>Get connectivity list and boundary nodes of 2D well region (WR). The WR
is composed of a Cartesian region and two half-radial regions in xy
plane, which is used to connect the HW grid. For the Cartesian region,
the X axis extends along the well trajectory:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>———&gt; X</p>
</div></blockquote>
<div class="line-block">
<div class="line">———————————–</div>
</div>
</div></blockquote>
<dl class="simple">
<dt>Y |    ——— Well trajectory ———</dt><dd><p>V    ———————————–</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">tC</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">bnC</span><span class="p">]</span> <span class="p">=</span> <span class="n">getConnListAndBdyNodeWR2D</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – Points of the WR region, generated by ‘pointsSingleWellNode’</p></li>
<li><p><strong>ny</strong> – The number of Cartesian cells in Y direction</p></li>
<li><p><strong>na</strong> – The number of angular cells in radial region</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>t</strong> – Connectivity list of the whole well region</p></li>
<li><p><strong>tC</strong> – Connectivity list of the Cartesian region</p></li>
<li><p><strong>bn</strong> – Indices of outer boundary nodes of the whole well region</p></li>
<li><p><strong>bnC</strong> – Indices of outer boundary nodes of the Cartesian region</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">VolumeOfInterest</span></code> <a class="reference internal" href="#nwm.gridding.pointsSingleWellNode" title="nwm.gridding.pointsSingleWellNode"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pointsSingleWellNode</span></code></a> <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nearWellBoreModelingGrids</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.makeConnListFromMat">
<span class="sig-name descname"><span class="pre">makeConnListFromMat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nd</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.makeConnListFromMat" title="Permalink to this definition"></a></dt>
<dd><p>Make the connectivity list from the node distribution matrix for a
structured grid.
The node distribution matrix:</p>
<blockquote>
<div><blockquote>
<div><p>1  2  3                      nnx</p>
</div></blockquote>
<p>1    *  *  *  *  *  *  ….  *  *  *
2    *  *  *  *  *  *  ….  *  *  *
3    *  *  *  *  *  *  ….  *  *  *</p>
<blockquote>
<div><p>……                   ……
*  *  *  *  *  *  ….  *  *  *</p>
</div></blockquote>
<p>nny  *  *  *  *  *  *  ….  *  *  *</p>
</div></blockquote>
<dl class="simple">
<dt>The nodes corresponding to cell (i,j) is:</dt><dd><p>{L(i,j), L(i+1,j), L(i+1,j+1), L(i,j+1)}</p>
</dd>
</dl>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="p">=</span> <span class="n">makeConnListFromMat</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
<span class="n">t</span> <span class="p">=</span> <span class="n">makeConnListFromMat</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="s">&#39;order&#39;</span><span class="p">,</span> <span class="s">&#39;column&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nd</strong> – Node distribution matrix</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘order’</strong> – ‘rows’ (Default) | ‘column’: the picking order. The numbering
of the connectivity list cycles along ‘order’ fastest.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>t</strong> – Connectivity list, n x 1 cell</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">nnx</span><span class="p">,</span> <span class="n">nny</span><span class="p">]</span> <span class="p">=</span> <span class="nb">deal</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">x0</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nnx</span><span class="p">);</span>
<span class="n">x</span>  <span class="p">=</span> <span class="nb">arrayfun</span><span class="p">(@(</span><span class="n">j</span><span class="p">)</span><span class="n">j</span><span class="o">*</span><span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">nny</span><span class="p">)</span><span class="o">&#39;</span><span class="p">,</span> <span class="s">&#39;UniformOutput&#39;</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="n">x</span>  <span class="p">=</span> <span class="n">cell2mat</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">y0</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">nny</span><span class="p">)</span><span class="o">&#39;</span><span class="p">;</span>
<span class="n">y</span>  <span class="p">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nnx</span><span class="p">);</span>
<span class="n">p</span>  <span class="p">=</span> <span class="p">[</span><span class="n">x</span><span class="p">(:),</span> <span class="n">y</span><span class="p">(:)];</span>
<span class="n">nd</span> <span class="p">=</span> <span class="nb">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">nny</span><span class="p">,</span> <span class="n">nnx</span><span class="p">);</span>
<span class="n">t</span>  <span class="p">=</span> <span class="n">makeConnListFromMat</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
<span class="n">G</span>  <span class="p">=</span> <span class="n">tessellationGrid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">)</span><span class="o">&#39;</span><span class="p">)</span>
<span class="n">t</span>  <span class="p">=</span> <span class="n">makeConnListFromMat</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="s">&#39;order&#39;</span><span class="p">,</span> <span class="s">&#39;column&#39;</span><span class="p">);</span>
<span class="n">G</span>  <span class="p">=</span> <span class="n">tessellationGrid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">)</span><span class="o">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#nwm.gridding.buildRadialGrid" title="nwm.gridding.buildRadialGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildRadialGrid</span></code></a>, <a class="reference internal" href="core.html#core.gridprocessing.tessellationGrid" title="core.gridprocessing.tessellationGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tessellationGrid</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.makeLayeredGridNWM">
<span class="sig-name descname"><span class="pre">makeLayeredGridNWM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.makeLayeredGridNWM" title="Permalink to this definition"></a></dt>
<dd><p>Extrude 2D grid to layered 3D grid according the topology of 2D grid and
provided surface point set. The surface points are given on all surfaces,
and topologically aligned in layered direction.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">makeLayeredGridNWM</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">makeLayeredGridNWM</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&#39;connectivity&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> – The 2D grid to be extruded</p></li>
<li><p><strong>p</strong> – Points of all surfaces, topologically aligned in layered direction</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘connectivity’</strong> – Connectivity list (nodes of cells) for g,
ncell_g x 1 cell. Note if the 2D grid are not on the
XY plane, the connectivity list of the 2D grid should
be provided</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>G</strong> – Valid 2.5D layerd grid structure</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">N</span>     <span class="p">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">N1</span>    <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">;</span>
<span class="n">N2</span>    <span class="p">=</span> <span class="mi">3</span><span class="o">*</span><span class="nb">ceil</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span> <span class="p">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="n">N1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="n">N2</span><span class="p">);</span>
<span class="n">X</span>     <span class="p">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">X</span><span class="p">;</span>
<span class="n">Y</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">)=</span><span class="n">Y</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="p">;</span>
<span class="n">p</span>     <span class="p">=</span> <span class="p">[</span><span class="n">X</span><span class="p">(:),</span> <span class="n">Y</span><span class="p">(:)];</span>
<span class="n">t</span>     <span class="p">=</span> <span class="nb">delaunayn</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="n">g</span>     <span class="p">=</span> <span class="n">triangleGrid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="n">g</span>     <span class="p">=</span> <span class="n">pebi</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
<span class="n">p</span>     <span class="p">=</span> <span class="n">g</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">;</span>
<span class="n">z</span>     <span class="p">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">50</span><span class="p">)</span><span class="o">&#39;</span><span class="p">;</span>
<span class="n">pSurfs</span> <span class="p">=</span> <span class="nb">arrayfun</span><span class="p">(@(</span><span class="n">z</span><span class="p">)[</span><span class="n">p</span><span class="o">-</span><span class="n">z</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="n">z</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">)],</span> <span class="n">z</span><span class="p">,</span> <span class="s">&#39;UniformOutput&#39;</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">makeLayeredGridNWM</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pSurfs</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.gridprocessing.makeLayeredGrid" title="core.gridprocessing.makeLayeredGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeLayeredGrid</span></code></a> <a class="reference internal" href="core.html#core.gridprocessing.tessellationGrid" title="core.gridprocessing.tessellationGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tessellationGrid</span></code></a> <code class="xref mat mat-func docutils literal notranslate"><span class="pre">layeredGrids</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.passToDistmesh">
<span class="sig-name descname"><span class="pre">passToDistmesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pIB</span></em>, <em class="sig-param"><span class="pre">pOB</span></em>, <em class="sig-param"><span class="pre">multiplier</span></em>, <em class="sig-param"><span class="pre">maxIter</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.passToDistmesh" title="Permalink to this definition"></a></dt>
<dd><p>Generate parameters passed to ‘distmesh_2d_nwm’</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.pointsSingleWellNode">
<span class="sig-name descname"><span class="pre">pointsSingleWellNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pW</span></em>, <em class="sig-param"><span class="pre">ly</span></em>, <em class="sig-param"><span class="pre">ny</span></em>, <em class="sig-param"><span class="pre">na</span></em>, <em class="sig-param"><span class="pre">ii</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.pointsSingleWellNode" title="Permalink to this definition"></a></dt>
<dd><p>Generate the 2D well region (WR) points corresponding to single well node
ii. The WR is composed of a Cartesian region and two half-radial regions
in xy plane, which is used to connect the HW grid. For the Cartesian
region, the X axis extends along the well trajectory:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>———&gt; X</p>
</div></blockquote>
<div class="line-block">
<div class="line">———————————–</div>
</div>
</div></blockquote>
<dl class="simple">
<dt>Y |    ——— Well trajectory ———</dt><dd><p>V    ———————————–</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">p0</span> <span class="p">=</span> <span class="n">pointsSingleWellNode</span><span class="p">(</span><span class="n">pW</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pW</strong> – The well trajectory, specified by a set of discrete 3D well
points (in xyz format)</p></li>
<li><p><strong>ly</strong> – The size of Cartesian region in Y direction</p></li>
<li><p><strong>ny</strong> – The number of Cartesian cells in Y direction</p></li>
<li><p><strong>na</strong> – The number of angular cells in radial region</p></li>
<li><p><strong>ii</strong> – Well node index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p0</strong> – 2D well region (WR) points corresponding to single well node ii</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">VolumeOfInterest</span></code> <a class="reference internal" href="#nwm.gridding.getConnListAndBdyNodeWR2D" title="nwm.gridding.getConnListAndBdyNodeWR2D"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getConnListAndBdyNodeWR2D</span></code></a> <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nearWellBoreModelingGrids</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.gridding.radCartHybridGrid">
<span class="sig-name descname"><span class="pre">radCartHybridGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">GC</span></em>, <em class="sig-param"><span class="pre">CI</span></em>, <em class="sig-param"><span class="pre">rW</span></em>, <em class="sig-param"><span class="pre">rM</span></em>, <em class="sig-param"><span class="pre">nR</span></em>, <em class="sig-param"><span class="pre">pW</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.gridding.radCartHybridGrid" title="Permalink to this definition"></a></dt>
<dd><p>Build the hybrid grid by gluing the radial grid in the near-well region
to the Cartesian grid elsewhere in the reservoir</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">radCartHybridGrid</span><span class="p">(</span><span class="n">GC</span><span class="p">,</span> <span class="n">CI</span><span class="p">,</span> <span class="n">rW</span><span class="p">,</span> <span class="n">rM</span><span class="p">,</span> <span class="n">nR</span><span class="p">,</span> <span class="n">pW</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>GC</strong> – The Cartesian grid structure</p></li>
<li><p><strong>CI</strong> – Cells inside the well region</p></li>
<li><p><strong>nR</strong> – Number of cells in radial direction</p></li>
<li><p><strong>rW</strong> – The minimum radius (wellbore radius)</p></li>
<li><p><strong>rM</strong> – The maximum radius</p></li>
<li><p><strong>pW</strong> – The well point coordinates</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>G</strong> – Valid hybrid grid definition</p></li>
<li><p><strong>t</strong> – Connectivity list of the hybrid grid</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">GC</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">]);</span>
<span class="n">GC</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">GC</span><span class="p">);</span>
<span class="n">ij</span> <span class="p">=</span> <span class="n">gridLogicalIndices</span><span class="p">(</span><span class="n">GC</span><span class="p">);</span>
<span class="n">idxI</span> <span class="p">=</span> <span class="n">ij</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="o">&gt;</span><span class="p">=</span> <span class="mi">10</span> <span class="o">&amp;</span> <span class="n">ij</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="o">&lt;</span><span class="p">=</span> <span class="mi">14</span> <span class="o">&amp;</span> <span class="n">ij</span><span class="p">{</span><span class="mi">2</span><span class="p">}</span> <span class="o">&gt;</span><span class="p">=</span> <span class="mi">10</span> <span class="o">&amp;</span> <span class="n">ij</span><span class="p">{</span><span class="mi">2</span><span class="p">}</span> <span class="o">&lt;</span><span class="p">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="n">CI</span> <span class="p">=</span> <span class="nb">find</span><span class="p">(</span><span class="n">idxI</span><span class="p">);</span>
<span class="c">% Place the well at the region center</span>
<span class="n">pCI</span> <span class="p">=</span> <span class="n">GC</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">centroids</span><span class="p">(</span><span class="n">CI</span><span class="p">,</span> <span class="p">:);</span>
<span class="n">pW</span>  <span class="p">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">pCI</span><span class="p">(:,</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">pCI</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">pCI</span><span class="p">(:,</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">pCI</span><span class="p">(:,</span><span class="mi">2</span><span class="p">))];</span>
<span class="p">[</span><span class="n">nR</span><span class="p">,</span> <span class="n">rW</span><span class="p">,</span> <span class="n">rM</span><span class="p">]</span> <span class="p">=</span> <span class="nb">deal</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">[</span><span class="n">G</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">=</span> <span class="n">radCartHybridGrid</span><span class="p">(</span><span class="n">GC</span><span class="p">,</span> <span class="n">CI</span><span class="p">,</span> <span class="n">rW</span><span class="p">,</span> <span class="n">rM</span><span class="p">,</span> <span class="n">nR</span><span class="p">,</span> <span class="n">pW</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">,</span> <span class="nb">hold</span> <span class="n">on</span><span class="p">;</span> <span class="nb">axis</span> <span class="n">equal</span> <span class="n">off</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.gridprocessing.tessellationGrid" title="core.gridprocessing.tessellationGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tessellationGrid</span></code></a> <a class="reference internal" href="core.html#core.gridprocessing.pebi" title="core.gridprocessing.pebi"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pebi</span></code></a> <a class="reference internal" href="#nwm.gridding.buildRadialGrid" title="nwm.gridding.buildRadialGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildRadialGrid</span></code></a> <code class="xref mat mat-func docutils literal notranslate"><span class="pre">glueRadCartGrids</span></code></p>
</div>
</dd></dl>

<span class="target" id="module-nwm.trans"></span><dl class="mat function">
<dt class="sig sig-object mat" id="nwm.trans.computeRadTransFactor">
<span class="sig-name descname"><span class="pre">computeRadTransFactor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">pW</span></em>, <em class="sig-param"><span class="pre">skin</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.trans.computeRadTransFactor" title="Permalink to this definition"></a></dt>
<dd><p>Compute the radial half transmissibility factor (ft) for the 2D radial
grid (halfTrans = perm .* ft). The computation assumes the steady-state
flow, and the ‘transmissibility center’ is obtained by integral of the
pressure within the area of cell</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">ft</span> <span class="p">=</span> <span class="n">computeRadTransFactor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pW</span><span class="p">,</span> <span class="n">skin</span><span class="p">)</span>
<span class="n">ft</span> <span class="p">=</span> <span class="n">computeRadTransFactor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pW</span><span class="p">,</span> <span class="n">skin</span><span class="p">,</span> <span class="s">&#39;nodeCoords&#39;</span><span class="p">,</span> <span class="n">nodeCoords</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Radial grid structure, typically built by <a class="reference internal" href="#nwm.gridding.buildRadialGrid" title="nwm.gridding.buildRadialGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildRadialGrid</span></code></a>.
The numbering of cells and nodes obey the the logical
numbering (angular cycle fastest, then radial).
G should contain the field: ‘radDims’: [nA, nR] or
[nA, nR(1), nR(2)]. For the second case, the total raidal
dimension is nR(1)+nR(2), but only cells with r-indices within
1 - nR(1) are involved in the calculations.</p></li>
<li><p><strong>pW</strong> – 2D coordinate of the well point</p></li>
<li><p><strong>skin</strong> – Skin factor of the well</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘nodeCoords’</strong> – Provided 2D coordinates of grid nodes. The G will be
updated after assigning ‘G.nodes.coords’ = nodeCoords.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>ft</strong> – Radial half transmissibility factor, corresponding to
‘G.cells.faces’. ft of cells with r-indices within</p>
<blockquote>
<div><p>nR(1)+1 - nR(1)+nR(2) are ‘nan’.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">nA</span><span class="p">,</span> <span class="n">nR</span><span class="p">,</span> <span class="n">rW</span><span class="p">,</span> <span class="n">rM</span><span class="p">]</span> <span class="p">=</span> <span class="nb">deal</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">th</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">,</span> <span class="n">nA</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="n">th</span> <span class="p">=</span> <span class="n">th</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">r</span> <span class="p">=</span> <span class="nb">logspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">rW</span><span class="p">),</span> <span class="n">log10</span><span class="p">(</span><span class="n">rM</span><span class="p">),</span> <span class="n">nR</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">[</span><span class="n">R</span><span class="p">,</span> <span class="n">TH</span><span class="p">]</span> <span class="p">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">th</span><span class="p">);</span>
<span class="p">[</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">]</span> <span class="p">=</span> <span class="n">pol2cart</span><span class="p">(</span><span class="n">TH</span><span class="p">(:),</span> <span class="n">R</span><span class="p">(:));</span>
<span class="n">p</span> <span class="p">=</span> <span class="p">[</span><span class="n">px</span><span class="p">(:),</span> <span class="n">py</span><span class="p">(:)];</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">buildRadialGrid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nA</span><span class="p">,</span> <span class="n">nR</span><span class="p">);</span>
<span class="n">ft</span> <span class="p">=</span> <span class="n">computeRadTransFactor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.solvers.computeTrans" title="core.solvers.computeTrans"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeTrans</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.trans.handleMatchingFaces">
<span class="sig-name descname"><span class="pre">handleMatchingFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G1</span></em>, <em class="sig-param"><span class="pre">cells1</span></em>, <em class="sig-param"><span class="pre">bdnodes1</span></em>, <em class="sig-param"><span class="pre">G2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.trans.handleMatchingFaces" title="Permalink to this definition"></a></dt>
<dd><p>Compute intersection relation between layered boundaries of subgrids.
Basically, the faces on the layered boundaries are matching, and only the
common areas are obtained from the cells and boundary nodes of G1. This
function is tailored to grids of the near-wellbore model.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">relation</span> <span class="p">=</span> <span class="n">handleMatchingFaces</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">cells1</span><span class="p">,</span> <span class="n">bdnodes1</span><span class="p">,</span> <span class="n">G2</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G1</strong> – Layered grid structures, G2 is loacted inside G1</p></li>
<li><p><strong>G2</strong> – Layered grid structures, G2 is loacted inside G1</p></li>
<li><p><strong>cells1</strong> – Cells in G1 which will be replaced by G2</p></li>
<li><p><strong>bdnodes1</strong> – Boundary nodes of cells1</p></li>
</ul>
</dd>
</dl>
<p>RETURNS:
relation - Face intersection relation, n x 3 matrix</p>
<blockquote>
<div><p>column 1     - Face of G1
column 2     - Face of G2
column 3     - Areas of intersection subfaces</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#nwm.gridding.assembleGrids" title="nwm.gridding.assembleGrids"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">assembleGrids</span></code></a>, <a class="reference internal" href="#nwm.trans.handleNonMatchingFaces" title="nwm.trans.handleNonMatchingFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">handleNonMatchingFaces</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.trans.handleNonMatchingFaces">
<span class="sig-name descname"><span class="pre">handleNonMatchingFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G1</span></em>, <em class="sig-param"><span class="pre">faces1</span></em>, <em class="sig-param"><span class="pre">G2</span></em>, <em class="sig-param"><span class="pre">faces2</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.trans.handleNonMatchingFaces" title="Permalink to this definition"></a></dt>
<dd><p>Compute the intersection relation of a surface shared by G1 and G2.
The surface will be divided into a set of subfaces due to different face
gemotries of G1 and G2.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">relation</span> <span class="p">=</span> <span class="n">handleNonMatchingFaces</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">faces1</span><span class="p">,</span> <span class="n">G2</span><span class="p">,</span> <span class="n">faces2</span><span class="p">)</span>
<span class="n">relation</span> <span class="p">=</span> <span class="n">handleNonMatchingFaces</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">faces1</span><span class="p">,</span> <span class="n">G2</span><span class="p">,</span> <span class="n">faces2</span><span class="p">,</span> <span class="s">&#39;isfaceNodesSorted&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G1</strong> – Grids sharing a surface</p></li>
<li><p><strong>G2</strong> – Grids sharing a surface</p></li>
<li><p><strong>faces1</strong> – Surface faces set, faces1 from G1 and faces2
from G2. Basically, faces1 and faces2 constitute the
same 3D surface. The surface is continuous and
completed.</p></li>
<li><p><strong>faces2</strong> – Surface faces set, faces1 from G1 and faces2
from G2. Basically, faces1 and faces2 constitute the
same 3D surface. The surface is continuous and
completed.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>% KEYWORD ARGUMENTS:</dt><dd><dl class="simple">
<dt>‘isfaceNodesSorted’  -  Wether the nodes of faces stored at</dt><dd><p>‘G.faces.nodes’ are sorted (for both G1 and G2)</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>relation</strong> – Face intersection relation, n x 9 matrix
column 1     - Face of G1
column 2     - Face of G2
column 3     - Areas of intersection subfaces
column 4-6   - Centroids of the subfaces
column 7-9   - Normals of the subfaces</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G1</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
<span class="n">G2</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
<span class="n">G2</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span> <span class="p">=</span> <span class="n">twister</span><span class="p">(</span><span class="n">G2</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">);</span>
<span class="n">G2</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span><span class="mi">3</span><span class="p">)</span> <span class="p">=</span> <span class="n">G2</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">G1</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G1</span><span class="p">);</span>
<span class="n">G2</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G2</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">,</span> <span class="nb">hold</span> <span class="n">on</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="s">&#39;facecolor&#39;</span><span class="p">,</span> <span class="s">&#39;none&#39;</span><span class="p">,</span> <span class="s">&#39;edgecolor&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="s">&#39;facecolor&#39;</span><span class="p">,</span> <span class="s">&#39;none&#39;</span><span class="p">,</span> <span class="s">&#39;edgecolor&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">faces1</span> <span class="p">=</span> <span class="nb">find</span><span class="p">(</span><span class="n">G1</span><span class="p">.</span><span class="n">faces</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">faces2</span> <span class="p">=</span> <span class="nb">find</span><span class="p">(</span><span class="n">G2</span><span class="p">.</span><span class="n">faces</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span><span class="p">=</span> <span class="mi">5</span><span class="o">+</span><span class="mf">0.01</span> <span class="o">&amp;</span> <span class="n">G2</span><span class="p">.</span><span class="n">faces</span><span class="p">.</span><span class="n">centroids</span><span class="p">(:,</span><span class="mi">3</span><span class="p">)</span> <span class="o">&gt;</span><span class="p">=</span> <span class="mi">5</span><span class="o">-</span><span class="mf">0.01</span><span class="p">);</span>
<span class="n">relation</span> <span class="p">=</span> <span class="n">handleNonMatchingFaces</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">faces1</span><span class="p">,</span> <span class="n">G2</span><span class="p">,</span> <span class="n">faces2</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#nwm.gridding.assembleGrids" title="nwm.gridding.assembleGrids"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">assembleGrids</span></code></a>, <a class="reference internal" href="#nwm.trans.handleMatchingFaces" title="nwm.trans.handleMatchingFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">handleMatchingFaces</span></code></a></p>
</div>
</dd></dl>

<span class="target" id="module-nwm.utils"></span><dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.bisection">
<span class="sig-name descname"><span class="pre">bisection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">bot</span></em>, <em class="sig-param"><span class="pre">top</span></em>, <em class="sig-param"><span class="pre">tol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.bisection" title="Permalink to this definition"></a></dt>
<dd><p>Find root by bisection method
f: function handle
bot, top: inintial X guess</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.circleCross">
<span class="sig-name descname"><span class="pre">circleCross</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x1</span></em>, <em class="sig-param"><span class="pre">y1</span></em>, <em class="sig-param"><span class="pre">r1</span></em>, <em class="sig-param"><span class="pre">x2</span></em>, <em class="sig-param"><span class="pre">y2</span></em>, <em class="sig-param"><span class="pre">r2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.circleCross" title="Permalink to this definition"></a></dt>
<dd><p>Compute intersction points of two circiles</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.computeCentroids">
<span class="sig-name descname"><span class="pre">computeCentroids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">p</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.computeCentroids" title="Permalink to this definition"></a></dt>
<dd><p>Compute centroids of the 2D polygon specified by points p</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.computePD">
<span class="sig-name descname"><span class="pre">computePD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">y</span></em>, <em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">xw</span></em>, <em class="sig-param"><span class="pre">yw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.computePD" title="Permalink to this definition"></a></dt>
<dd><p>Compute dimensionless pressure for the flow problem that a well is
arbitrarily located inside a rectangular box with width a and height b.
The distance from well to right boundary is xw and to the lower boundary
is yw</p>
<blockquote>
<div><blockquote>
<div></div></blockquote>
<div class="line-block">
<div class="line-block">
<div class="line">xw         |</div>
</div>
<div class="line">(Well) o …………… |</div>
<div class="line-block">
<div class="line-block">
<div class="line">.                 |</div>
</div>
<div class="line">yw  .                 |</div>
<div class="line-block">
<div class="line">.                 |</div>
<div class="line">.                 |
——————————————-</div>
</div>
</div>
</div>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.convertTo3DPlane">
<span class="sig-name descname"><span class="pre">convertTo3DPlane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">T</span></em>, <em class="sig-param"><span class="pre">R</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.convertTo3DPlane" title="Permalink to this definition"></a></dt>
<dd><p>Convert the points p from horizontal plane to the fully 3D plane. T and R
are transformation matrix, can be obtained by <a class="reference internal" href="#nwm.utils.convertToXYPlane" title="nwm.utils.convertToXYPlane"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertToXYPlane</span></code></a></p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.convertToXYPlane">
<span class="sig-name descname"><span class="pre">convertToXYPlane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pts1</span></em>, <em class="sig-param"><span class="pre">n1</span></em>, <em class="sig-param"><span class="pre">pts2</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.convertToXYPlane" title="Permalink to this definition"></a></dt>
<dd><p>Convert the points p from fully 3D plane to horizontal xy plane. The
fully 3D plane is specified by pts1(n1(1), :), pts1(n1(2), :), and
pts1(n1(3), :).
New z-axis: Along normals of the 3D plane
New x-axis: pts1(n1(2), :) - pts1(n1(1), :)
All points of pts1 and pts2 will be transformed.
Optional: ‘normalZ’, provide z-normal of the plane</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.euclideanDistance">
<span class="sig-name descname"><span class="pre">euclideanDistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">X</span></em>, <em class="sig-param"><span class="pre">Y</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.euclideanDistance" title="Permalink to this definition"></a></dt>
<dd><p>Calculate euclidean distance from one set to another
Equivalent to the matlab function pdist2(X, Y, ‘euclidean’)
See <a class="reference external" href="https://stackoverflow.com/questions/7696734/pdist2-equivalent-in-matlab-version-7">https://stackoverflow.com/questions/7696734/pdist2-equivalent-in-matlab-version-7</a></p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.getDZ">
<span class="sig-name descname"><span class="pre">getDZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">c</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.getDZ" title="Permalink to this definition"></a></dt>
<dd><p>Compute DZ of cell c in grid G. The face direction indicator in
cell.faces(:,2) is required</p>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">]);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
<span class="n">dz</span> <span class="p">=</span> <span class="n">getDZ</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.getUnitDisVectors">
<span class="sig-name descname"><span class="pre">getUnitDisVectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">cfCentersAll</span></em>, <em class="sig-param"><span class="pre">cells</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.getUnitDisVectors" title="Permalink to this definition"></a></dt>
<dd><p>Get unit distance vectors of cells in Corner-point or Cartesian grid</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">ux</span><span class="p">,</span> <span class="n">uy</span><span class="p">,</span> <span class="n">uz</span><span class="p">]</span> <span class="p">=</span> <span class="n">getUnitDisVectors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cfCentersAll</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Corner-point or Cartesian grid structure</p></li>
<li><p><strong>cfCentersAll</strong> – Cell face center of the G, corresponding to G.cells.faces
can be obtained by: ‘computeCpGeometry’ or
G.faces.centroids(G.cells.faces(:,1), :)</p></li>
<li><p><strong>cells</strong> – Cells of G</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ux: Unit distance vector directing from X</strong> – face center to X+ face center</p></li>
<li><p><strong>uy:          ……                     Y</strong> – Y+</p></li>
<li><p><strong>uz:          ……                     Z</strong> – Z+</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">]);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
<span class="n">cfCentersAll</span> <span class="p">=</span> <span class="n">G</span><span class="p">.</span><span class="n">faces</span><span class="p">.</span><span class="n">centroids</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">faces</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span> <span class="p">:);</span>
<span class="p">[</span><span class="n">ux</span><span class="p">,</span> <span class="n">uy</span><span class="p">,</span> <span class="n">uz</span><span class="p">]</span> <span class="p">=</span> <span class="n">getUnitDisVectors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cfCentersAll</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">)</span><span class="o">&#39;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>, <a class="reference internal" href="ad-core.html#ad_core.utils.computeCpGeometry" title="ad_core.utils.computeCpGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeCpGeometry</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.polyintersect">
<span class="sig-name descname"><span class="pre">polyintersect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.polyintersect" title="Permalink to this definition"></a></dt>
<dd><p>POLYINTERSECT  Finds all intersections of 2 polygons.</p>
<blockquote>
<div><p>[xr,yr] = polyintersect(x1,y1,x2,y2)</p>
</div></blockquote>
<p>returns all intersections between the line pieces of polygons
(x1,y1) and (x2,y2).</p>
<p>POLYINTERSECT calculates analytically any possible intersection
if the line segments would have infinate length, and subsequently
discards those intersections that are outside the
support points (begin and end points) of each segment. This
method is in principle fool-proof, (and also works for vertical line segments).</p>
<p>Note that whether line 1 or line 2 is longest does
not matter (nor for speed, not for solution).
Note that line 1 and line2 can be NaN-separated polygons.
Note that for two parallel lines no crossing is returned
(even if they partly overlap).</p>
<blockquote>
<div><p>[xr,yr] = polyintersect(x1,y1,x2,y2,&lt;keyword,value&gt;)</p>
</div></blockquote>
<dl class="simple">
<dt>implemented &lt;keyword,value&gt; pairs are:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>debug<span class="classifier">0, 1 (default) for plot of intersects</span></dt><dd><p>2 for plotting all segments of line 2 one by one.</p>
</dd>
</dl>
</li>
<li><p>disp     :   0, 1 (default) for printing progress to command line</p></li>
</ul>
</dd>
<dt>See also: POLYJOIN, POLYSPLIT, (mapping toolbox)</dt><dd><p>POLY2STRUC,
FINDCROSSINGSOFPOLYGONANDPOLYGON, LANDBOUNDARY</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.sortPtsClockWise">
<span class="sig-name descname"><span class="pre">sortPtsClockWise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.sortPtsClockWise" title="Permalink to this definition"></a></dt>
<dd><p>Sort the points in counterclockwise order for each element specified by
the connectivity list t</p>
<blockquote>
<div><p>p - 2D point set
t - Connectivity list, n x 1, cell array</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.sortPtsCounterClockWise">
<span class="sig-name descname"><span class="pre">sortPtsCounterClockWise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.sortPtsCounterClockWise" title="Permalink to this definition"></a></dt>
<dd><p>Sort the points in counterclockwise order for each element specified by
the connectivity list t</p>
<blockquote>
<div><p>p - 2D point set
t - Connectivity list, n x 1, cell array</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.tabulate_NWM">
<span class="sig-name descname"><span class="pre">tabulate_NWM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.tabulate_NWM" title="Permalink to this definition"></a></dt>
<dd><p>Use ‘accumarray’ with val = 1 to count the number of identical subscripts
in u. Equivalent to the matlab function tabulate(u).
Written by Knut-Andreas Lie</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="nwm.utils.tri_area">
<span class="sig-name descname"><span class="pre">tri_area</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">P1</span></em>, <em class="sig-param"><span class="pre">P2</span></em>, <em class="sig-param"><span class="pre">P3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#nwm.utils.tri_area" title="Permalink to this definition"></a></dt>
<dd><p>A Copy from ‘hfm’ module
tri_area(P1, P2, P3) calculates the triangle area given the coordinates
of its vertices in P1, P2 and P3 using Heron’s formula.
Heron’s Formula:
s = semiperimeter
A = sqrt(s * (s-a) * (s-b) * (s-c))
Where a,b,c are lengths of the triangle edges</p>
</dd></dl>

<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h2>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="msrsb.html" class="btn btn-neutral float-left" title="msrsb: Multiscale Restriction-Smoothed Basis method for pressure" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="opm_gridprocessing.html" class="btn btn-neutral float-right" title="opm_gridprocessing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, SINTEF Digital.
      <span class="lastupdated">Last updated on Sep 23, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>