<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>adjoint: Two-phase, incompressible adjoint solvers &mdash; The Matlab Reservoir Simulation Toolbox 2019b documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="agglom: Flow and property-based coarse-grid generation" href="agglom.html" />
    <link rel="prev" title="ad-mechanics: Coupled flow and mechanics" href="ad-mechanics.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> The Matlab Reservoir Simulation Toolbox
            <img src="_static/mrstlogo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2019b
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="core.html">Core functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-core.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code>: Automatic Differentiation Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-props.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-props</span></code>: PVT, fluid models and other properties for the AD-solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-blackoil.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-blackoil</span></code>: Black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-eor.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-eor</span></code>: Enhanced oil recovery solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-mechanics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-mechanics</span></code>: Coupled flow and mechanics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">adjoint</span></code>: Two-phase, incompressible adjoint solvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-adjoint">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="agglom.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">agglom</span></code>: Flow and property-based coarse-grid generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="blackoil-sequential.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">blackoil-sequential</span></code>: Sequential implicit black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="book.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">book</span></code>: Book examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="coarsegrid.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">coarsegrid</span></code>: Generation of coarse grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="compositional.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">compositional</span></code>: Equation-of-state compositional solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="co2lab.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">co2lab</span></code>: Numerical CO<sub>2</sub> laboratory</a></li>
<li class="toctree-l1"><a class="reference internal" href="deckformat.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">deckformat</span></code>: Reading and conversion of input decks</a></li>
<li class="toctree-l1"><a class="reference internal" href="dfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dfm</span></code>: Discrete fracture matrix implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="dg.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dg</span></code>: Discontinous Galerkin discretizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">diagnostics</span></code>: Flow diagnostics functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="dual_porosity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dual-porosity</span></code>: Dual porosity/permeability model for fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="fvbiot.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fvbiot</span></code>: Consistent finite-volume discretizations for poroelasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="geochemistry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">geochemistry</span></code>: Surface geochemistry</a></li>
<li class="toctree-l1"><a class="reference internal" href="heterogeneity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">heterogeneity</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="hfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hfm</span></code>: Hierarchical and embedded fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="incomp.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">incomp</span></code>: Solvers for incompressible flow and transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="libgeometry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">libgeometry</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="linearsolvers.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">linearsolvers</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="matlab_bgl.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">matlab_bgl</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="mimetic.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mimetic</span></code>: Mimetic solvers for pressure problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mpfa</span></code>: Multi-point flux approximation solvers for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst_api.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst_api</span></code>: API for writing C/C++ for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst-gui.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst-gui</span></code>: Graphical user-interfaces for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="msfvm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msfvm</span></code>: Multiscale Finite-Volume method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msmfem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msmfem</span></code>: Multiscale Mixed Finite-Element method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msrsb.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msrsb</span></code>: Multiscale Restriction-Smoothed Basis method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="nwm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nwm</span></code>: Near Wellbore Modelling</a></li>
<li class="toctree-l1"><a class="reference internal" href="opm_gridprocessing.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">opm_gridprocessing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">optimization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="re-mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">re-mpfa</span></code>: Richards’ equation with multi-point flux</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvent.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solvent</span></code>: Solvent solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="spe10.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">spe10</span></code>: Access to the SPE10 benchmark case</a></li>
<li class="toctree-l1"><a class="reference internal" href="steady-state.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">steady-state</span></code> Steady-state upscaling of functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamlines.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">streamlines</span></code>: Compute streamlines</a></li>
<li class="toctree-l1"><a class="reference internal" href="triangle.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">triangle</span></code>: Triangular grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="upscaling.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaling</span></code>: Upscaling of reservoir problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="vem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vem</span></code>: Virtual element method on general grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="vemmech.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vemmech</span></code>: Mechanics for general grids using the virtual element method</a></li>
<li class="toctree-l1"><a class="reference internal" href="wellpaths.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">wellpaths</span></code>: Generation of wells using general curves</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Matlab Reservoir Simulation Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><code class="xref mat mat-func docutils literal notranslate"><span class="pre">adjoint</span></code>: Two-phase, incompressible adjoint solvers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/adjoint.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="adjoint-two-phase-incompressible-adjoint-solvers">
<h1><code class="xref mat mat-func docutils literal notranslate"><span class="pre">adjoint</span></code>: Two-phase, incompressible adjoint solvers<a class="headerlink" href="#adjoint-two-phase-incompressible-adjoint-solvers" title="Permalink to this headline"></a></h1>
<p>Implements strategies for production optimisation based on adjoint formulations. This enables for, instance, optimization of net present value constrained by the bottom-hole pressure in wells. This module is limited to two-phase, incompressible flow as implemented in the incomp module. For optimization problems with more complex fluid physics, the newer “optimization” module is recommended.</p>
<div class="section" id="module-adjoint">
<span id="utilities"></span><h2>Utilities<a class="headerlink" href="#module-adjoint" title="Permalink to this headline"></a></h2>
<dl class="mat script">
<dt class="sig sig-object mat" id="adjoint.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#adjoint.Contents" title="Permalink to this definition"></a></dt>
<dd><p>ADJOINT Add-on module for adjoint-based production optimisation</p>
<dl class="simple">
<dt>Files</dt><dd><p>addAdjointWellFields            - SYNOPSIS:
adjointFluidFields              - Extend fluid functionality with fields needed in (2nd order) adjoint imp.
assembleWellSystem              - Generate pressure linear system components for wells.
computeAdjointRHS               - Compute adjoint ‘pressure’ rhs
computeGradient                 - compute gradient for control variables and project according to
computeNumericalGradient        - compute numerical gradient
controls2RHS                    - Create mappings A_N, b_N, A_D, b_D such that
controls2Wells                  - Create mappings A_N, b_N, A_D, b_D such that
generateUpstreamTransportMatrix - generateUpstreamTransportMatrix for use in saturation solver
initControls                    - initControls – Initialize control structure based on well schedule
initSchedule                    - initSchedule – Initialize schedule structure based on well W.
optimizeObjective               - optimizeObjective – Run whole optimization proccess using ad-hoc line
projectGradient                 - Project gradient according to linear input constraints. Handles box-constraints and
runAdjoint                      - runAdjoint – Run adjoint simulation based on simRes and schedule.
runSchedule                     - runSchedule – Run simulation based on schedule.
solveAdjointPressureSystem      - Find current time step (search for empty slots in adjRes)
solveAdjointTransportSystem     - Find current time step (search for empty slots in adjRes)
updateSchedule                  - Update schedule based on controls
updateWells                     - Update wells based on schedule time step
dispControls                    - Display control values.
dispSchedule                    - Display schedule values
lineSearchAgr                   - Run agressive line search based on given gradient.
solveIncompFlowLocal            - Local version of solveIncompFlow for use with adjoint module. Local</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.addAdjointWellFields">
<span class="sig-name descname"><span class="pre">addAdjointWellFields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">CG</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.addAdjointWellFields" title="Permalink to this definition"></a></dt>
<dd><p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="p">=</span> <span class="n">addAdjointWellFields</span><span class="p">(</span><span class="n">CG</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
<span class="n">W</span> <span class="p">=</span> <span class="n">addAdjointWellFields</span><span class="p">(</span><span class="n">CG</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="s">&#39;OverlapWell&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;OverlapBlock&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Hack for the adjoint code:
Add additional fields to the Well-structure.
The added fields are coarseCells and optionally CS.overlap and
CS.wellOverlap.</p>
<p>Needed in updateWells and createSingleCellPseudoWells.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.adjointFluidFields">
<span class="sig-name descname"><span class="pre">adjointFluidFields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fluid</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.adjointFluidFields" title="Permalink to this definition"></a></dt>
<dd><p>Extend fluid functionality with fields needed in (2nd order) adjoint imp.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">fluid</span> <span class="p">=</span> <span class="n">adjointFluidFields</span><span class="p">(</span><span class="n">fluid</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fluid</strong> – A ‘fluid_structure’.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>fluid</strong> – Updated fluid structure now containing additional fields
- dLtInv (state) – d/ds     (1 / lambda_t(state))
- d2LtInv(state) – d^2/ds^2 (1 / lambda_t(state))
- d2fw   (state) – d^2/ds^2 f_w(state)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fluid_structure</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.assembleWellSystem">
<span class="sig-name descname"><span class="pre">assembleWellSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.assembleWellSystem" title="Permalink to this definition"></a></dt>
<dd><p>Generate pressure linear system components for wells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="p">=</span> <span class="n">assembleWellSystem</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
<span class="n">W</span> <span class="p">=</span> <span class="n">assembleWellSystem</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure as described by grid_structure.</p></li>
<li><p><strong>W</strong> – Well structure as defined by addWell &amp;c.</p></li>
<li><p><strong>'pn'/pv</strong> – <p>List of ‘key’/value pairs defining optional parameters.  The
supported options are:</p>
<blockquote>
<div><ul>
<li><dl class="simple">
<dt>Type – The kind of system to assemble.  The choice made</dt><dd><p>for this option influences which pressure solvers
can be employed later.
String.  Default value = ‘hybrid’.</p>
</dd>
<dt>Supported values are:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>’hybrid’<span class="classifier">Hybrid system with inverse mass matrix</span></dt><dd><p>(BI) for Schur complement reduction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>’mixed’<span class="classifier">Hybrid system with regular mass matrix (B)</span></dt><dd><p>for reduction to mixed form.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Note: The value of this option should match the option
pair passed to function computeMimeticIP.</p>
</li>
</ul>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>W</strong> – Updated well structure.  Function assembleWellSystem adds field ‘S’
to each well in ‘W’.  The well system W(k).S has the following
fields:</p>
<blockquote>
<div><p>S.BI/S.B – Well hybrid system (inverse) ‘mass’ matrix.
S.C      – Well hybrid system discrete divergence operator.
S.D      – Well hybrid system flux continuity matrix.
S.RHS    – Well hybrid linear system right hand side.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="mimetic.html#mimetic.computeMimeticIP" title="mimetic.computeMimeticIP"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeMimeticIP</span></code></a>, <a class="reference internal" href="core.html#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.computeAdjointRHS">
<span class="sig-name descname"><span class="pre">computeAdjointRHS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">f_res</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.computeAdjointRHS" title="Permalink to this definition"></a></dt>
<dd><p>Compute adjoint ‘pressure’ rhs
for use in e.g. function solveAdjointPressureSystem</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="p">=</span> <span class="n">computeAdjoint</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">f_res</span><span class="p">,</span> <span class="n">f_w</span><span class="p">)</span>
</pre></div>
</div>
<p>DESCRIPTION:
Computes adjoint ‘pressure’ rhs as input to solveIncompFlow
in function solveAdjointPressureSystem</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>W</strong> – Well structure as defined by addWell &amp;c.</p></li>
<li><p><strong>f_res</strong> – Adjoint reservoir ‘pressure’ condtions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>b</strong> – Ajoint pressure rhs to be passed directly as option
‘rhs’ to solveIncompFlow.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.computeGradient">
<span class="sig-name descname"><span class="pre">computeGradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">adjRes</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">controls</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.computeGradient" title="Permalink to this definition"></a></dt>
<dd><p>compute gradient for control variables and project according to
linEqConst A*u = b  =&gt; A*grad = 0
Thus the projected gradient is</p>
<blockquote>
<div><p>grad_p  = (I - A’<a href="#id1"><span class="problematic" id="id2">*</span></a>inv(A*A’)*A)*grad</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.computeNumericalGradient">
<span class="sig-name descname"><span class="pre">computeNumericalGradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">simRes</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">S</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">controls</span></em>, <em class="sig-param"><span class="pre">objectiveFunction</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.computeNumericalGradient" title="Permalink to this definition"></a></dt>
<dd><p>compute numerical gradient</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.controls2RHS">
<span class="sig-name descname"><span class="pre">controls2RHS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">controls</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.controls2RHS" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Create mappings A_N, b_N, A_D, b_D such that</dt><dd><p>q_{tot,N}^n = A_N{n}*u^n + b_N{n}
p_{w,D}^n   = A_D{n}*u^n + b_D{n}</p>
</dd>
</dl>
<p>where u^n is the set of controll variables at step n</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.controls2Wells">
<span class="sig-name descname"><span class="pre">controls2Wells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">controls</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.controls2Wells" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Create mappings A_N, b_N, A_D, b_D such that</dt><dd><p>q_{tot,N}^n = A_N{n}*u^n + b_N{n}
p_{w,D}^n   = A_D{n}*u^n + b_D{n}</p>
</dd>
</dl>
<p>where u^n is the set of controll variables at step n</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.dispControls">
<span class="sig-name descname"><span class="pre">dispControls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">controls</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.dispControls" title="Permalink to this definition"></a></dt>
<dd><p>Display control values.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.dispSchedule">
<span class="sig-name descname"><span class="pre">dispSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.dispSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Display schedule values</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.generateUpstreamTransportMatrix">
<span class="sig-name descname"><span class="pre">generateUpstreamTransportMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">S</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">resSol</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.generateUpstreamTransportMatrix" title="Permalink to this definition"></a></dt>
<dd><p>generateUpstreamTransportMatrix for use in saturation solver</p>
<p>SYNOPSIS:
[A, qPluss, signQ] = generateUpstreamTransportMatrix(G, S, W, resSol, …</p>
<blockquote>
<div><p>wellSol, pn1, pv1, …)</p>
</div></blockquote>
<p class="rubric">Description:</p>
<p>Generates sparse matrix A(cellFlux) which is used in transport solver
s1 = s0 + dt*Dv*(Af(s) + q+).
Assumes no-flow boundary conditions on all cell-faces</p>
<p>signQ is useful for differentation of max(q, 0)/min(q, 0) wrt to q,
when q is zero</p>
<p>REQUIRED PARAMETERS:</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Transpose</strong> – if true, the transpose of a is given (default false)</p></li>
<li><p><strong>VectorOutput</strong> – if true, output A is a struct with fields ‘i’, ‘j’ and
‘qMinus’, such that
A = sparse(i, j, -cellFlux) + diag(qMinus)
(NOTE MINUSES). Default value is false</p></li>
<li><p><strong>RelativeThreshold</strong> – Considers values below
max(abs(cellflux))*RealtiveThreshold
as zero (default 0)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.initControls">
<span class="sig-name descname"><span class="pre">initControls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.initControls" title="Permalink to this definition"></a></dt>
<dd><p>initControls – Initialize control structure based on well schedule</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">controls</span> <span class="p">=</span> <span class="n">initControls</span><span class="p">(</span><span class="n">schedule</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Initialize controls</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>schedule</strong> – schedule structure</p></li>
<li><p><strong>'pn'/pv</strong> – <p>List of ‘key’/value pairs defining optional parameters.  The
supported options are:</p>
<blockquote>
<div><ul>
<li><dl class="simple">
<dt>ControllableWells<span class="classifier">indices to wells which will be</span></dt><dd><p>controlled (default all)</p>
</dd>
</dl>
</li>
<li><p>BHPMaxMin          :  max/min value for bhp-wells,(default [-Inf Inf])</p></li>
<li><p>RateMaxMin         :  max/min value for rate-wells,(default [-Inf Inf])</p></li>
<li><dl class="simple">
<dt>MaxMin<span class="classifier">matrix of size numControls x 2,</span></dt><dd><p>where each row contains the max and min
value for the corresponding control. Aternative
to the two above</p>
</dd>
</dl>
</li>
<li><p>NumControlSteps    :  number of control steps (default number of time steps)</p></li>
<li><dl class="simple">
<dt>LinEqConst<span class="classifier">linear equality constraints of the</span></dt><dd><p>form Au = b given in the form {A_1,
b_1, A_2, b_2, …}</p>
</dd>
</dl>
</li>
<li><p>Verbose            :  Display Control vars using dispControls</p></li>
</ul>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>controls</strong> – Initialized control structure having fields
- well  : #controllable wells x 1 structure having</p>
<blockquote>
<div><blockquote>
<div><p>fields:</p>
</div></blockquote>
<ul class="simple">
<li><p>wellNum    : index to current well in schedule (and W)</p></li>
<li><p>values     : values for each timeStep</p></li>
<li><p>bhpMaxMin  :</p></li>
<li><p>rateMAxMin :</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>linEqConst<span class="classifier">linear equality contraints structure having fields:</span></dt><dd><ul>
<li><p>A</p></li>
<li><p>b</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#adjoint.initSchedule" title="adjoint.initSchedule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initSchedule</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.initSchedule">
<span class="sig-name descname"><span class="pre">initSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.initSchedule" title="Permalink to this definition"></a></dt>
<dd><p>initSchedule – Initialize schedule structure based on well W.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">shedule</span> <span class="p">=</span> <span class="n">initSchedule</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Initialize schedule</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> – well structure</p></li>
<li><p><strong>'pn'/pv</strong> – <p>List of ‘key’/value pairs defining optional parameters.  The
supported options are:</p>
<blockquote>
<div><ul>
<li><p>NumSteps  :  number of simulation time steps (default 1)</p></li>
<li><p>TotalTime :  total simualtion time (default 1)</p></li>
<li><p>TimeSteps :  endtime for each time step assuming t_0 = 0 (alterative to two previous pns)</p></li>
<li><p>Verbose   :  display schedule with dispSchedule</p></li>
</ul>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>schedule</strong> – Initialized numSteps x 1 rate schedule structure having fields
- timeInterval     – [startTime endTime]
- names            – {name_1, …, name_n}
- types            – {welltype_1, … , welltype_n}
- values           – {val_1, …, val_2}</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#adjoint.dispSchedule" title="adjoint.dispSchedule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dispSchedule</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.lineSearchAgr">
<span class="sig-name descname"><span class="pre">lineSearchAgr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">simRes</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">S</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">controls</span></em>, <em class="sig-param"><span class="pre">grad</span></em>, <em class="sig-param"><span class="pre">objectiveFunction</span></em>, <em class="sig-param"><span class="pre">stepSize</span></em>, <em class="sig-param"><span class="pre">figProps</span></em>, <em class="sig-param"><span class="pre">opt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.lineSearchAgr" title="Permalink to this definition"></a></dt>
<dd><p>Run agressive line search based on given gradient.
Handles box-constraints and linear equality - and (probably not)
inequality-constaints
based on iteratively applying the constrints to the gradient until
convergence.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">simRes</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">controls</span><span class="p">,</span> <span class="n">data</span><span class="p">]</span> <span class="p">=</span> <span class="n">lineSearch</span><span class="p">(...</span>
  <span class="n">simRes</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">controls</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">objectiveFunction</span><span class="p">,</span> <span class="p">...</span>
  <span class="n">stepSize</span><span class="p">,</span> <span class="n">figProps</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>
</pre></div>
</div>
<dl>
<dt>DISCRIPTION:</dt><dd><ol class="arabic">
<li><p>Project gradient according to constraints iteratively until tollerance ConstTol is met
or max number of iterations MaxConstIts is met (returnes failure).
Constraints are applied in the following order:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><ol class="lowerroman simple">
<li><p>Box const.</p></li>
</ol>
</div></blockquote>
<ol class="lowerroman simple" start="2">
<li><p>Lin. UnEq. const.</p></li>
</ol>
</div></blockquote>
<ol class="lowerroman simple" start="3">
<li><p>Lin. Eq. const.</p></li>
</ol>
</div></blockquote>
<p>The resulting norm of the projected gradient is used as stopping criteria</p>
</li>
<li><dl>
<dt>Line search along projected gradient:</dt><dd><p>Uses three points [x1 x2 x3] = [0 .5 1]*stepSize
(a) If projected gradient pgrad(x2)=pgrad(x3), then on boundary,</p>
<blockquote>
<div><p>done</p>
</div></blockquote>
<ol class="loweralpha simple" start="2">
<li><p>If obj(x1)&lt;obj(x2)&lt;obj(x3), set stepSize=2*stepSize goto (a)</p></li>
<li><p>If obj(x1)&gt;obj(x2), set stepSize = .5*stepSize goto (a)</p></li>
<li><p>Find max on quad-curve through (x1, x2, x3) done</p></li>
</ol>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – usual structures</p></li>
<li><p><strong>S</strong> – usual structures</p></li>
<li><p><strong>W</strong> – usual structures</p></li>
<li><p><strong>rock</strong> – usual structures</p></li>
<li><p><strong>fluid</strong> – usual structures</p></li>
<li><p><strong>simRes</strong> – <p>…</p>
</p></li>
<li><p><strong>schedule</strong> – <p>…</p>
</p></li>
<li><p><strong>controls</strong> – <p>…</p>
</p></li>
<li><p><strong>grad</strong> – gradien as given by computeGradient</p></li>
<li><p><strong>objectiveFunction</strong> – handle to objective function</p></li>
<li><p><strong>'pn'/pv</strong> – <dl class="simple">
<dt>List of ‘key’/value pairs defining optional parameters.  The</dt><dd><p>supported options are:</p>
</dd>
</dl>
<ul>
<li><dl class="simple">
<dt>MaxPoints<span class="classifier">maximum number of points before to</span></dt><dd><p>terminate line search algorithm</p>
</dd>
</dl>
</li>
<li><p>LinSrchTol          : line search relative tolerance</p></li>
<li><p>StepSize            : Step size</p></li>
<li><p>ConstTol            : Relative contraint satisfaction tol</p></li>
<li><p>MaxConstIts         : max number of its for constraint satisfaction</p></li>
<li><p>VerboseLevel        : amount of output to screen</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul>
<li><p><strong>simRes</strong> – Results for ‘best’ forward simulation</p></li>
<li><p><strong>schedule</strong></p></li>
<li><p><strong>controls</strong></p></li>
<li><p><strong>data</strong> – structure with fields
value         : objective function value for best run
relNormGrad   : relative norm of gradient <a href="#id3"><span class="problematic" id="id4">|du|</span></a>/<a href="#id5"><span class="problematic" id="id6">|objective|</span></a>
success       : whether or line search procedure succeeded
fraction      : optimal fraction obtained during the line</p>
<blockquote>
<div><p>search</p>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
<p>SEE ALSO:</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.optimizeObjective">
<span class="sig-name descname"><span class="pre">optimizeObjective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">S</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">resSolInit</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">controls</span></em>, <em class="sig-param"><span class="pre">objectiveFunction</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.optimizeObjective" title="Permalink to this definition"></a></dt>
<dd><p>optimizeObjective – Run whole optimization proccess using ad-hoc line
search. A linkage with an external optimizer or use of matlabs optimizer
toolbox (e.g., fmincon)is recommended.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">simRes</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">controls</span><span class="p">,</span> <span class="n">output</span><span class="p">]</span> <span class="p">=</span> <span class="n">optimizeObjective</span><span class="p">(</span> <span class="p">...</span>
                     <span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="n">resSolInit</span><span class="p">,</span> <span class="p">...</span>
                     <span class="n">schedule</span><span class="p">,</span> <span class="n">controls</span><span class="p">,</span> <span class="n">objectiveFunction</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – usual structures</p></li>
<li><p><strong>S</strong> – usual structures</p></li>
<li><p><strong>W</strong> – usual structures</p></li>
<li><p><strong>rock</strong> – usual structures</p></li>
<li><p><strong>fluid</strong> – usual structures</p></li>
<li><p><strong>resSolInit</strong> – initial ‘solution’ minimum containing field
resSol.sw</p></li>
<li><p><strong>schedule</strong> – <p>…</p>
</p></li>
<li><p><strong>controls</strong> – <p>…</p>
</p></li>
<li><p><strong>objectiveFunction</strong> – handle to objective function</p></li>
<li><p><strong>'pn'/pv</strong> – List of ‘key’/value pairs defining optional parameters.  The
supported options are:</p></li>
</ul>
</dd>
</dl>
<p>:param : gradTol       : stopping criterion for scaled gradien
:param : objChangeTol  : stopping criterion for realitive change in objective</p>
<blockquote>
<div><p>function</p>
</div></blockquote>
<p>:param : stepSize      : initial step size
:param : VerboseLevel  : level of output to screen during progress (default: 0).</p>
<blockquote>
<div><dl class="simple">
<dt>&lt; 0<span class="classifier">no output</span></dt><dd><p>0  : minumal
1  : quite a bit
2  : loads</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>:param<span class="classifier">PlotProgress</span><span class="classifier">whether or not to plot output during progress</span></dt><dd><p>(default: true)</p>
</dd>
<dt>:param<span class="classifier">OutputLevel</span><span class="classifier">level of output given in structure output (default: 0)</span></dt><dd><dl>
<dt>&lt; 0  = nothing (empty)</dt><dd><dl class="simple">
<dt>0  = objective function value for every</dt><dd><p>iteration</p>
</dd>
</dl>
<p>1  = ?</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>simRes</strong> – Results for last (optimal) simulation</p></li>
<li><p><strong>schedule</strong></p></li>
<li><p><strong>controls</strong></p></li>
<li><p><strong>outPut</strong> – as described above</p></li>
</ul>
</dd>
</dl>
<p>SEE ALSO:</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.projectGradient">
<span class="sig-name descname"><span class="pre">projectGradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">controls</span></em>, <em class="sig-param"><span class="pre">du</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.projectGradient" title="Permalink to this definition"></a></dt>
<dd><p>Project gradient according to linear input constraints. Handles box-constraints and
linear equality - and inequality-constraints based on iteratively applying the constraints
to the gradient until convergence.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">pGrad</span><span class="p">]</span> <span class="p">=</span> <span class="n">projectGradient</span><span class="p">(...</span>
  <span class="n">simRes</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">controls</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">objectiveFunction</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<dl>
<dt>DISCRIPTION:</dt><dd><p>Project gradient according to constraints iteratively until tollerance ConstTol is met
or max number of iterations MaxConstIts is met (returnes failure).
Constraints are applied in the following order:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><ol class="lowerroman simple">
<li><p>Box const.</p></li>
</ol>
</div></blockquote>
<ol class="lowerroman simple" start="2">
<li><p>Lin. InEq. const.</p></li>
</ol>
</div></blockquote>
<ol class="lowerroman simple" start="3">
<li><p>Lin. Eq. const.</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>controls</strong> – </p></li>
<li><p><strong>grad</strong> – </p></li>
<li><p><strong>'pn'/pv</strong> – <dl class="simple">
<dt>List of ‘key’/value pairs defining optional parameters.  The</dt><dd><p>supported options are:</p>
</dd>
</dl>
<ul>
<li><p>ConstTol            : Relative contraint satisfaction tol</p></li>
<li><p>MaxConstIts         : max number of its for constraint satisfaction</p></li>
<li><p>VerboseLevel        : amount of output to screen</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pGrad</strong> – projected gradient</p>
</dd>
</dl>
<p>SEE ALSO:</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.runAdjoint">
<span class="sig-name descname"><span class="pre">runAdjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">simRes</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">S</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">controls</span></em>, <em class="sig-param"><span class="pre">objectiveFunction</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.runAdjoint" title="Permalink to this definition"></a></dt>
<dd><p>runAdjoint – Run adjoint simulation based on simRes and schedule.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">adjRes</span> <span class="p">=</span> <span class="n">runAdjoint</span><span class="p">(</span><span class="n">simRes</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">objective</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p>DESCRIPTION:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>simRes</strong> – </p></li>
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>S</strong> – </p></li>
<li><p><strong>W</strong> – </p></li>
<li><p><strong>fluid</strong> – </p></li>
<li><p><strong>schedule</strong> – </p></li>
<li><p><strong>objective</strong> – function handle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>adjRes</strong> – numSteps x 1 structure having fields
- timeInterval
- resSol
- wellSol</p>
</dd>
</dl>
<p>SEE ALSO:</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.runSchedule">
<span class="sig-name descname"><span class="pre">runSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">resSolInit</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">S</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.runSchedule" title="Permalink to this definition"></a></dt>
<dd><p>runSchedule – Run simulation based on schedule.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">simRes</span> <span class="p">=</span> <span class="n">runSchedule</span><span class="p">(</span><span class="n">resSolInit</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p>DESCRIPTION:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>resSolInit</strong> – </p></li>
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>S</strong> – </p></li>
<li><p><strong>W</strong> – </p></li>
<li><p><strong>fluid</strong> – </p></li>
<li><p><strong>schedule</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>simRes</strong> – (numSteps+1) x 1 structure having fields
- timeInterval
- resSol
- wellSol</p>
</dd>
</dl>
<p>SEE ALSO:</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.solveAdjointPressureSystem">
<span class="sig-name descname"><span class="pre">solveAdjointPressureSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">S</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">simRes</span></em>, <em class="sig-param"><span class="pre">adjRes</span></em>, <em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.solveAdjointPressureSystem" title="Permalink to this definition"></a></dt>
<dd><p>Find current time step (search for empty slots in adjRes)
NOTE: actually curent time step +1</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.solveAdjointTransportSystem">
<span class="sig-name descname"><span class="pre">solveAdjointTransportSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">S</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">simRes</span></em>, <em class="sig-param"><span class="pre">adjRes</span></em>, <em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.solveAdjointTransportSystem" title="Permalink to this definition"></a></dt>
<dd><p>Find current time step (search for empty slots in adjRes)
NOTE: actually curent time step +1</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.solveIncompFlowLocal">
<span class="sig-name descname"><span class="pre">solveIncompFlowLocal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.solveIncompFlowLocal" title="Permalink to this definition"></a></dt>
<dd><p>Local version of solveIncompFlow for use with adjoint module. Local
version has the additional option to supply right-hand-side to system
directly. In addition, there is som extra slack in the assertion statement
that checks sum(rates)=0  when only rate-controlled wells are present.
This to prevent crash if input-constraint handling is not set to machine
precision.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">solveIncompFlow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">fluid</span><span class="p">)</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">solveIncompFlow</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function assembles and solves a (block) system of linear equations
defining interface fluxes and cell and interface pressures at the next
time step in a sequential splitting scheme for the reservoir simulation
problem defined by Darcy’s law and a given set of external influences
(wells, sources, and boundary conditions).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – Reservoir and well solution structure either properly
initialized from function ‘initState’, or the results from a
previous call to function ‘solveIncompFlow’ and, possibly, a
transport solver such as function ‘explicitTransport’.</p></li>
<li><p><strong>G</strong> – Grid and (mimetic) linear system data structures as defined by
function ‘computeMimeticIP’.</p></li>
<li><p><strong>S</strong> – Grid and (mimetic) linear system data structures as defined by
function ‘computeMimeticIP’.</p></li>
<li><p><strong>fluid</strong> – Fluid data structure as described by ‘fluid_structure’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>wells</strong> – Well structure as defined by function ‘addWell’.  May be empty
(i.e., W = []) which is interpreted as a model without any
wells.</p></li>
<li><p><strong>bc</strong> – Boundary condition structure as defined by function ‘addBC’.
This structure accounts for all external boundary conditions
to the reservoir flow.  May be empty (i.e., bc = []) which is
interpreted as all external no-flow (homogeneous Neumann)
conditions.</p></li>
<li><p><strong>src</strong> – Explicit source contributions as defined by function
‘addSource’.  May be empty (i.e., src = []) which is
interpreted as a reservoir model without explicit sources.</p></li>
<li><p><strong>rhs</strong> – Supply system right-hand side ‘b’ directly.  Overrides
internally constructed system right-hand side.  Must be a
three-element cell array, the elements of which are correctly
sized for the block system component to be replaced.</p>
<p>NOTE: This is a special purpose option for use by code which
needs to modify the system of linear equations directly, e.g.,
the ‘adjoint’ code.</p>
</li>
<li><p><strong>Solver</strong> – Which solver mode function ‘solveIncompFlow’ should employ in
assembling and solving the block system of linear equations.
String.  Default value: Solver = ‘hybrid’.</p>
<dl>
<dt>Supported values are:</dt><dd><ul>
<li><dl>
<dt>‘hybrid’ –</dt><dd><p>Assemble and solve hybrid system for interface
pressures.  System is eventually solved by Schur
complement reduction and back substitution.</p>
<p>The system ‘S’ must in this case be assembled by
passing option pair (‘Type’,’hybrid’) or option pair
(‘Type’,’comp_hybrid’) to function ‘computeMimeticIP’.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>‘mixed’ –</dt><dd><p>Assemble and solve a hybrid system for interface
pressures, cell pressures and interface fluxes. System
is eventually reduced to a mixed system as per function
‘mixedSymm’.</p>
<p>The system ‘S’ must in this case be assembled by
passing option pair (‘Type’,’mixed’) or option pair
(‘Type’,’comp_hybrid’) to function ‘computeMimeticIP’.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>‘tpfa’ –</dt><dd><p>Assemble and solve a cell-centred system for cell
pressures.  Interface fluxes recovered through back
substitution.</p>
<p>The system ‘S’ must in this case be assembled by
passing option pair (‘Type’,’mixed’) or option pair
(‘Type’,’comp_hybrid’) to function ‘computeMimeticIP’.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p><strong>LinSolve</strong> – Handle to linear system solver software to which the fully
assembled system of linear equations will be passed.  Assumed
to support the syntax</p>
<blockquote>
<div><p>x = LinSolve(A, b)</p>
</div></blockquote>
<p>in order to solve a system Ax=b of linear equations.
Default value: LinSolve = &#64;mldivide (backslash).</p>
</li>
<li><p><strong>MatrixOutput</strong> – Whether or not to return the final system matrix ‘A’ to the
caller of function ‘solveIncompFlow’.
Logical.  Default value: MatrixOutput = FALSE.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>state</strong> – Update reservoir and well solution structure with new values
for the fields:</p>
<blockquote>
<div><ul>
<li><dl class="simple">
<dt>pressure – Pressure values for all cells in the</dt><dd><p>discretised reservoir model, ‘G’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>facePressure –</dt><dd><p>Pressure values for all interfaces in the
discretised reservoir model, ‘G’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>flux     – Flux across global interfaces corresponding to</dt><dd><p>the rows of ‘G.faces.neighbors’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A        – System matrix.  Only returned if specifically</dt><dd><p>requested by setting option ‘MatrixOutput’.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>wellSol  – Well solution structure array, one element for</dt><dd><p>each well in the model, with new values for
the fields:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>flux     – Perforation fluxes through all</dt><dd><p>perforations for corresponding
well.  The fluxes are
interpreted as injection
fluxes, meaning positive
values correspond to injection
into reservoir while negative
values mean
production/extraction out of
reservoir.</p>
</dd>
</dl>
</li>
<li><p>pressure – Well bottom-hole pressure.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are no external influences, i.e., if all of the structures
‘W’, ‘bc’, and ‘src’ are empty and there are no effects of gravity, and
no system right hand side has been supplied externally, then the input
values ‘xr’ and ‘xw’ are returned unchanged and a warning is printed in
the command window.  This warning is printed with message ID</p>
<blockquote>
<div><p>‘solveIncompFlow:DrivingForce:Missing’</p>
</div></blockquote>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="mimetic.html#mimetic.computeMimeticIP" title="mimetic.computeMimeticIP"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeMimeticIP</span></code></a>, <a class="reference internal" href="core.html#core.params.wells_and_bc.addBC" title="core.params.wells_and_bc.addBC"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addBC</span></code></a>, <a class="reference internal" href="core.html#core.params.wells_and_bc.addSource" title="core.params.wells_and_bc.addSource"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addSource</span></code></a>, <a class="reference internal" href="core.html#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a>, <a class="reference internal" href="incomp.html#incomp.fluid.incompressible.initSimpleFluid" title="incomp.fluid.incompressible.initSimpleFluid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initSimpleFluid</span></code></a>
<a class="reference internal" href="core.html#core.solvers.initState" title="core.solvers.initState"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initState</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">solveIncompFlowMS</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.updateSchedule">
<span class="sig-name descname"><span class="pre">updateSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">controls</span></em>, <em class="sig-param"><span class="pre">schedule</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.updateSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Update schedule based on controls</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.updateWells">
<span class="sig-name descname"><span class="pre">updateWells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">scheduleStep</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.updateWells" title="Permalink to this definition"></a></dt>
<dd><p>Update wells based on schedule time step</p>
</dd></dl>

<span class="target" id="module-adjoint.objectives"></span><dl class="mat script">
<dt class="sig sig-object mat" id="adjoint.objectives.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#adjoint.objectives.Contents" title="Permalink to this definition"></a></dt>
<dd><p>Files
recovery  - Objective function calculating water volume at last time step
simpleNPV - Simple net-present-value function - no discount factor</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.objectives.recovery">
<span class="sig-name descname"><span class="pre">recovery</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">S</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">simRes</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">controls</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.objectives.recovery" title="Permalink to this definition"></a></dt>
<dd><p>Objective function calculating water volume at last time step</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">obj</span> <span class="p">=</span> <span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="n">simRes</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">controls</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Computes value of objective function for given simulation, and partial
derivatives of variables if varargin &gt; 6</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>simRes</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>obj</strong> – structure with fields
val    - value of objective function</p>
</dd>
</dl>
<p>SEE ALSO:</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="adjoint.objectives.simpleNPV">
<span class="sig-name descname"><span class="pre">simpleNPV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">S</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">simRes</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">controls</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#adjoint.objectives.simpleNPV" title="Permalink to this definition"></a></dt>
<dd><p>Simple net-present-value function - no discount factor</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">obj</span> <span class="p">=</span> <span class="n">simpleNPV</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="n">simRes</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">controls</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Computes value of objective function for given simulation, and partial
derivatives of variables if varargin &gt; 6</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>simRes</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>obj</strong> – structure with fields</p>
</dd>
</dl>
<p>SEE ALSO:</p>
</dd></dl>

</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h2>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ad-mechanics.html" class="btn btn-neutral float-left" title="ad-mechanics: Coupled flow and mechanics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="agglom.html" class="btn btn-neutral float-right" title="agglom: Flow and property-based coarse-grid generation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, SINTEF Digital.
      <span class="lastupdated">Last updated on Sep 23, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>