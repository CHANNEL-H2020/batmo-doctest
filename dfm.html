<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dfm: Discrete fracture matrix implementation &mdash; The Matlab Reservoir Simulation Toolbox 2019b documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="dg: Discontinous Galerkin discretizations" href="dg.html" />
    <link rel="prev" title="deckformat: Reading and conversion of input decks" href="deckformat.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> The Matlab Reservoir Simulation Toolbox
            <img src="_static/mrstlogo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2019b
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="core.html">Core functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-core.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code>: Automatic Differentiation Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-props.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-props</span></code>: PVT, fluid models and other properties for the AD-solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-blackoil.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-blackoil</span></code>: Black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-eor.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-eor</span></code>: Enhanced oil recovery solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-mechanics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-mechanics</span></code>: Coupled flow and mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="adjoint.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">adjoint</span></code>: Two-phase, incompressible adjoint solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="agglom.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">agglom</span></code>: Flow and property-based coarse-grid generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="blackoil-sequential.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">blackoil-sequential</span></code>: Sequential implicit black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="book.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">book</span></code>: Book examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="coarsegrid.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">coarsegrid</span></code>: Generation of coarse grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="compositional.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">compositional</span></code>: Equation-of-state compositional solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="co2lab.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">co2lab</span></code>: Numerical CO<sub>2</sub> laboratory</a></li>
<li class="toctree-l1"><a class="reference internal" href="deckformat.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">deckformat</span></code>: Reading and conversion of input decks</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dfm</span></code>: Discrete fracture matrix implementation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dg.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dg</span></code>: Discontinous Galerkin discretizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">diagnostics</span></code>: Flow diagnostics functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="dual_porosity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dual-porosity</span></code>: Dual porosity/permeability model for fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="fvbiot.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fvbiot</span></code>: Consistent finite-volume discretizations for poroelasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="geochemistry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">geochemistry</span></code>: Surface geochemistry</a></li>
<li class="toctree-l1"><a class="reference internal" href="heterogeneity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">heterogeneity</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="hfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hfm</span></code>: Hierarchical and embedded fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="incomp.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">incomp</span></code>: Solvers for incompressible flow and transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="libgeometry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">libgeometry</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="linearsolvers.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">linearsolvers</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="matlab_bgl.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">matlab_bgl</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="mimetic.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mimetic</span></code>: Mimetic solvers for pressure problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mpfa</span></code>: Multi-point flux approximation solvers for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst_api.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst_api</span></code>: API for writing C/C++ for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst-gui.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst-gui</span></code>: Graphical user-interfaces for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="msfvm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msfvm</span></code>: Multiscale Finite-Volume method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msmfem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msmfem</span></code>: Multiscale Mixed Finite-Element method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msrsb.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msrsb</span></code>: Multiscale Restriction-Smoothed Basis method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="nwm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nwm</span></code>: Near Wellbore Modelling</a></li>
<li class="toctree-l1"><a class="reference internal" href="opm_gridprocessing.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">opm_gridprocessing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">optimization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="re-mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">re-mpfa</span></code>: Richards’ equation with multi-point flux</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvent.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solvent</span></code>: Solvent solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="spe10.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">spe10</span></code>: Access to the SPE10 benchmark case</a></li>
<li class="toctree-l1"><a class="reference internal" href="steady-state.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">steady-state</span></code> Steady-state upscaling of functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamlines.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">streamlines</span></code>: Compute streamlines</a></li>
<li class="toctree-l1"><a class="reference internal" href="triangle.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">triangle</span></code>: Triangular grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="upscaling.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaling</span></code>: Upscaling of reservoir problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="vem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vem</span></code>: Virtual element method on general grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="vemmech.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vemmech</span></code>: Mechanics for general grids using the virtual element method</a></li>
<li class="toctree-l1"><a class="reference internal" href="wellpaths.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">wellpaths</span></code>: Generation of wells using general curves</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Matlab Reservoir Simulation Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dfm</span></code>: Discrete fracture matrix implementation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/dfm.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="dfm-discrete-fracture-matrix-implementation">
<h1><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dfm</span></code>: Discrete fracture matrix implementation<a class="headerlink" href="#dfm-discrete-fracture-matrix-implementation" title="Permalink to this headline"></a></h1>
<p>This is the Discrete Fracture Matrix module developed as an extension of MRST.</p>
<p>The module is devopled at the University of Bergen, and licenced under
the GNU General Public License v3.0.</p>
<p>The module is mainly developed by Tor Harald Sandve (at IRIS from Jan
2013), minor modifications are introduced by Eirik Keilegavlen (UoB).
Some utility files are partly written at Uni Research.</p>
<p>An overview of the files can be found in Content.m</p>
<p>To get started, see the examples subdirectory.</p>
<p>The performance of the hybrid discretization is described in:
Sandve, T. H., I. Berre, J. M. Nordbotten (2012), An efficient
Multi-Point Flux Approximation based approach for Discrete Fracture
Matrix simulation, Journal of Computational Physics, 231(9), 3784-3800,
doi:10.1016/j.jcp.2012.01.023.</p>
<p>Some thoughts on the implementation, and more general on discretization
on fractured media can be found in Implementation_Notes.pdf</p>
<span class="target" id="module-dfm"></span><dl class="mat script">
<dt class="sig sig-object mat" id="dfm.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#dfm.Contents" title="Permalink to this definition"></a></dt>
<dd><p>Discrete Fracture Matrix (DFM) module</p>
<p>Routines supporting the DFM method. Examples in /examples
Add module by typing MrstModule add dfm
AUTHOR: <a class="reference external" href="mailto:tor&#46;harald&#46;sandve&#37;&#52;&#48;iris&#46;no">tor<span>&#46;</span>harald<span>&#46;</span>sandve<span>&#64;</span>iris<span>&#46;</span>no</a></p>
<dl>
<dt>new files</dt><dd><p>addhybrid                   - Add hybrid cells to the grid structure.
build_fractures_mod         - Build fracture network that serves as constraints in the triangulation.
computeHybridTrans          - Computes the hybrid-hybrid transmissibilities between a hybrid cell 1 and 2
nodeType                    - return node type
plotEdges                   - plot lines
testNormals                 - Tests if the normals points from neighbor 1 to 2 and returns the index of
triangulate                 - Make a Delaunay Triangulation and return a Mrst grid</p>
<p>/plotting/plotFractures - Plots 2d hybridcells.</p>
</dd>
<dt>Files modified from  core MRST functions. Use these to</dt><dd><p>computeTrans_DFM            - Compute transmissibilities using a two-point scheme.
computeMultiPointTrans_DFM  - Compute multi-point transmissibilities.
twophaseJacobian_DFM        - Residual and Jacobian of single point upwind solver for two-phase flow.
explicitTransport_DFM       - Explicit single point upwind transport solver for two-phase flow.
implicitTransport_DFM       - Implicit single point upwind transport solver for two-phase flow.
removeInternalBoundary_DFM  - Remove internal boundary in grid by merging faces in face list N</p>
<p>/plotting/                 - Modification to plotting rutines to handle</p>
</dd>
<dt>/private.</dt><dd><ul class="simple">
<li><p>Files needed since we can not access private folders from this location</p></li>
</ul>
</dd>
<dt>/examples:</dt><dd><p>add_point                   - Add a new point to the cloud.
computeHybridMPTrans        - Computes the hybrid-hybrid transmissibilities. Also update the grid and
computeTimeOfFlight_DFM     - Compute time of flight using finite-volume scheme.
distance_to_closest_line    - Copyright 2011-2012 University of Bergen
incompMPFA_DFM              - Solve incompressible flow problem (fluxes/pressures) using MPFA-O method.
incompTPFA_DFM              - Solve incompressible flow problem (fluxes/pressures) using TPFA method.
lines_intersect             - [pt] = lines_intersect (vertices, edge1, edge2)
partition_edges             - [vertices, new_edges, num_added] = …
read_openoffice             - Read fractures drawn in Libreoffice, and represent them as points and
removeFractureIntersections - Partition intersecting edges by adding a point in the intersection.
remove_closepoints          - Remove all points that are too close to the lines, since these will only
snap_to_grid                - Move vertices to the closest (structured) grid point.
split_edge                  - Split an edge into two parts</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.add_point">
<span class="sig-name descname"><span class="pre">add_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">vertices</span></em>, <em class="sig-param"><span class="pre">pt</span></em>, <em class="sig-param"><span class="pre">box</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.add_point" title="Permalink to this definition"></a></dt>
<dd><p>Add a new point to the cloud.</p>
<p>Ensure the existence of a point in the vertex set if it is not already
there. When the function return, the point will be present at
vertices(i). new_point contains 0 if an old point was found, and 1 if a
new point is created, i.e. it is the number of points added.</p>
<p>Portions Copyright (C) 2006-2007 Uni Research AS
This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.addhybrid">
<span class="sig-name descname"><span class="pre">addhybrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">hybrids</span></em>, <em class="sig-param"><span class="pre">apertures</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.addhybrid" title="Permalink to this definition"></a></dt>
<dd><p>Add hybrid cells to the grid structure.</p>
<p>A hybrid cell can be considered a lower-dimensional object in the
geometrical grid, that still has a volume in the computational grid.
Hybrid cells are created by converting a face into a thin cell.
The hybrid cell consist of the same number of points as the corresponding face,
but a volume = aperture * A associated with each of the hybrid cell,
where A is the hybrid face area.</p>
<p>In addition to the original faces (the ones that the hybrid cell was
created from) the hybrid cells consists of hybrid faces. They are lines
in 3d and points in 2d, but with an area = aperture * L (3d) and area =
aperture (2d), where L is the length of the corresponding face edge.</p>
<p>The hybrid cells will be connected both to ‘normal’ cells (the ones that
used to share a face before the the hybrid cells was squeezed in) and
possibly other hybrid cells (if the face formed a segment of a longer
fracture, say). The former connections are stored in G.faces.neighbors,
for details on the ordering of faces etc see comments within the
subfunction ‘createHybridCells’ below. Connections between hybrid
neighbors are stored in a special field G.hybridNeighbors. For flow
calculations on the resulting grid hybrid transmissibilities between the
hybrid faces can be computed from computeHybridTrans.m or
computeHybridMPTrans.m</p>
<p>If fractures (e.g. lines / planes of multiple hybrid cells) intersects, a
small cell may be created in the intersection. However, this has a really
small volume, and it may be desirable to eliminate it in flow
calculations. This is done by default, unless the optional field
addHybrid2Cells is set to true. The elimination results in non-neighbor
cell-to-cell connections between hybrid cells that are stored in
G.hybridNeighbors.</p>
<p>SYNOPSIS</p>
<blockquote>
<div><p>G = addhybrid(G,faces,apertures)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>faces</strong> – Logical Vector of face indices. A hybrid cell is created
for each true face.</p></li>
<li><p><strong>apertures</strong> – Vector of size G.faces.num giving the aperture of the
hybrid cell.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>OPTIONS:</dt><dd><dl class="simple">
<dt>addHybrid2Cells - adds hybrids cells of second kind (explanation above)</dt><dd><p>and remove the internal boundary between the rest of
the hybrid faces i.e no cell2cell connection are
needed.</p>
</dd>
<dt>addCorners      - hybrid cells of second kind are created</dt><dd><p>in the corners</p>
</dd>
</dl>
</dd>
</dl>
<p>EX:</p>
<dl class="simple">
<dt>Create a standard grid</dt><dd><p>G = tensorGrid(linspace(0,10,11),linspace(0,10,11));
G = computeGeometry(G);</p>
</dd>
<dt>Create a fracture at y=5</dt><dd><p>hit=find(G.faces.centroids(:,2)==5);</p>
</dd>
<dt>Mark the face as a fracture face</dt><dd><p>G.faces.tags=zeros(G.faces.num,1);
G.faces.tags(hit)=1;</p>
</dd>
<dt>Assign aperture</dt><dd><p>apt = zeros(G.faces.num,1);
apt(hit) = 0.001;</p>
</dd>
<dt>Add the hybrid cells</dt><dd><p>G = addhybrid(G,G.faces.tags &gt; 0,apt);</p>
</dd>
<dt>Plot the grid</dt><dd><p>plotGrid(G);
plotFractures(G);</p>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.build_fractures_mod">
<span class="sig-name descname"><span class="pre">build_fractures_mod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.build_fractures_mod" title="Permalink to this definition"></a></dt>
<dd><p>Build fracture network that serves as constraints in the triangulation.</p>
<p>Currently only odp-files are read, but other user-specified formats can
easily be added here.</p>
<p>Copyright (C) 2006-2007 Uni Research AS 2013 IRIS ENERGY
This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.computeHybridMPTrans">
<span class="sig-name descname"><span class="pre">computeHybridMPTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">S</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.computeHybridMPTrans" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Computes the hybrid-hybrid transmissibilities. Also update the grid and</dt><dd><p>transmissibility structure accordingly.</p>
<p>The call to computeMultiPointTrans with hybrid = true gives a
transmissibility matrix where connections between hybrid cells are
represented as boundaries (they are not connectiod). This function
modifies the transmissibility matrix to produce connected faces.
In the case that more than two hybrid cells meets (fracture
intersection), we furthermore remove the small cell in the interaction.</p>
<p>If the pressure values at the intersections between hybrid cells are denoted u_0,
the discretized elliptic pressure equation can be splitt such that:</p>
</dd>
</dl>
<p>( A B^T ; B D ) (u u0)^T = (f 0)^T,</p>
<blockquote>
<div><p>The pressure at the intersection can then be removed such that</p>
<p>u0 = inv(D)*B</p>
<p>Using the above expression the flux can be expressed%
q = (T T0) (u u0)^T = (T - T0*inv(D)*B)u</p>
<p>SYNOPSIS</p>
<blockquote>
<div><blockquote>
<div><p>[g, S] = computeHybridMPTrans(g,S)</p>
</div></blockquote>
<p>PARAMETERS</p>
<blockquote>
<div><p>g       - Grid data structure.
S       - Transmissibility data structure.</p>
</div></blockquote>
</div></blockquote>
<p>Copyright 2011-2012 University of Bergen</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.computeHybridTrans">
<span class="sig-name descname"><span class="pre">computeHybridTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">T</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.computeHybridTrans" title="Permalink to this definition"></a></dt>
<dd><p>Computes the hybrid-hybrid transmissibilities between a hybrid cell 1 and 2
using the star-delta transformation:</p>
<blockquote>
<div><p>t_12 = t_1*t_2/sum(t_k)</p>
<p>for all cells k connected to an intersection.</p>
</div></blockquote>
<p>SYNOPSIS</p>
<blockquote>
<div><p>[G, ft_hybrid] = computeHybridTrans(G,T)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>T</strong> – Half-Transmissibilities one for each cell face.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>G</strong> – Grid structure with cell-to-cell connections added</p></li>
<li><p><strong>ft_hybrid</strong> – Transmissibilities for each hybrid cell2cell connection.</p></li>
</ul>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.computeMultiPointTrans_DFM">
<span class="sig-name descname"><span class="pre">computeMultiPointTrans_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.computeMultiPointTrans_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Compute multi-point transmissibilities.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="p">=</span> <span class="n">computeMultiPointTrans_DFM</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure as described by grid_structure.</p></li>
<li><p><strong>rock</strong> – <p>Rock data structure with valid field ‘perm’.  The
permeability is assumed to be in measured in units of
metres squared (m^2).  Use function ‘darcy’ to convert from
(milli)darcies to m^2, e.g.,</p>
<blockquote>
<div><p>perm = convertFrom(perm, milli*darcy)</p>
</div></blockquote>
<p>if the permeability is provided in units of millidarcies.</p>
<p>The field rock.perm may have ONE column for a scalar
permeability in each cell, TWO/THREE columns for a diagonal
permeability in each cell (in 2/3 D) and THREE/SIX columns
for a symmetric full tensor permeability.  In the latter
case, each cell gets the permeability tensor</p>
<blockquote>
<div><dl class="simple">
<dt>K_i = [ k1  k2 ]      in two space dimensions</dt><dd><p>[ k2  k3 ]</p>
</dd>
<dt>K_i = [ k1  k2  k3 ]  in three space dimensions</dt><dd><p>[ k2  k4  k5 ]
[ k3  k5  k6 ]</p>
</dd>
</dl>
</div></blockquote>
</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>OPTIONAL PARAMETERS</dt><dd><dl class="simple">
<dt>verbose   - Whether or not to emit informational messages throughout the</dt><dd><p>computational process.  Default value depending on the
settings of function ‘mrstVerbose’.</p>
</dd>
</dl>
<p>facetrans -</p>
<dl class="simple">
<dt>hybrid -    If true, the interaction region is splitted for all nodes</dt><dd><p>shared by more then one hybrid cell. And the continuity
point is moved half an aperture in the normal direction.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>T</strong> – half-transmissibilities for each local face of each grid cell
in the grid.  The number of half-transmissibilities equal the
number of rows in G.cells.faces.</p>
</dd>
</dl>
<dl class="simple">
<dt>COMMENTS:</dt><dd><p>PLEASE NOTE: Face normals have length equal to face areas.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="mpfa.html#mpfa.incompMPFA" title="mpfa.incompMPFA"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">incompMPFA</span></code></a>, <a class="reference internal" href="core.html#core.utils.mrstVerbose" title="core.utils.mrstVerbose"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstVerbose</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.computeTimeOfFlight_DFM">
<span class="sig-name descname"><span class="pre">computeTimeOfFlight_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.computeTimeOfFlight_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Compute time of flight using finite-volume scheme.</p>
<dl class="simple">
<dt>MODIFIED FROM computeTimeOfFlight.m to allow for cell 2 cell connections</dt><dd><p>Copyright (C) in portion 2013 IRIS AS</p>
</dd>
</dl>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">T</span>        <span class="p">=</span> <span class="n">computeTimeOfFlight</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">)</span>
 <span class="n">T</span>        <span class="p">=</span> <span class="n">computeTimeOfFlight</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="p">]</span>    <span class="p">=</span> <span class="n">computeTimeOfFlight</span><span class="p">(...)</span>
<span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="p">=</span> <span class="n">computeTimeOfFlight</span><span class="p">(...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Compute time of flight by solving</p>
<blockquote>
<div><p>nabla·(vT) = phi</p>
</div></blockquote>
<p>using a first-order finite-volume method with upwind flux.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure.</p></li>
<li><p><strong>rock</strong> – Rock data structure.
Must contain a valid porosity field, ‘rock.poro’.</p></li>
<li><p><strong>state</strong> – Reservoir and well solution structure either properly
initialized from functions ‘initResSol’ and ‘initWellSol’
respectively, or the results from a call to function
‘solveIncompFlow’.  Must contain valid cell interface fluxes,
‘state.flux’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>wells</strong> – Well structure as defined by function ‘addWell’.  May be empty
(i.e., wells = []) which is interpreted as a model without any
wells.</p></li>
<li><p><strong>src</strong> – Explicit source contributions as defined by function
‘addSource’.  May be empty (i.e., src = []) which is
interpreted as a reservoir model without explicit sources.</p></li>
<li><p><strong>bc</strong> – Boundary condition structure as defined by function ‘addBC’.
This structure accounts for all external boundary conditions
to the reservoir flow.  May be empty (i.e., bc = []) which is
interpreted as all external no-flow (homogeneous Neumann)
conditions.</p></li>
<li><p><strong>‘reverse’</strong> – Reverse the fluxes and rates.</p></li>
<li><p><strong>‘tracer’</strong> – Cell-array of cell-index vectors for which to solve tracer
equation. One equation is solved for each vector with
tracer injected in cells given indices. Each vector adds
one additional RHS to the original tof-system. Output given
as additional columns in T.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul>
<li><p><strong>T</strong> – Cell values of a piecewise constant approximation to time-of-flight
computed as the solution of the boundary-value problem</p>
<blockquote>
<div><p>(*)    nabla·(vT) = phi</p>
</div></blockquote>
<p>using a finite-volume scheme with single-point upwind approximation
to the flux.</p>
</li>
<li><p><strong>A</strong> – Discrete left-hand side of (*), a G.cells.num-by-G.cells.num matrix
whose entries are</p>
<blockquote>
<div><p>A_ij = min(F_ij, 0), and
A_ii = sum_j max(F_ij, 0) + max(q_i, 0),</p>
</div></blockquote>
<p>where F_ij = -F_ji is the flux from cell i to cell j</p>
<blockquote>
<div><p>F_ij = A_ij·n_ij·v_ij.</p>
</div></blockquote>
<p>and n_ij is the outward-pointing normal of cell i for grid face ij.</p>
<p>OPTIONAL.  Only returned if specifically requested.</p>
</li>
<li><p><strong>q</strong> – Aggregate source term contributions (per grid cell) from wells,
explicit sources and boundary conditions.  These are the
contributions referred to as ‘q_i’ in the definition of the matrix
elements, ‘A_ii’.  Measured in units of m^3/s.</p>
<p>OPTIONAL.  Only returned if specifically requested.</p>
</li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simpleTimeOfFlight</span></code>, <a class="reference internal" href="mimetic.html#mimetic.solveIncompFlow" title="mimetic.solveIncompFlow"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solveIncompFlow</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.computeTrans_DFM">
<span class="sig-name descname"><span class="pre">computeTrans_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.computeTrans_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Compute transmissibilities using a two-point scheme.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="p">=</span> <span class="n">computeTrans_DFM</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">)</span>
<span class="n">T</span> <span class="p">=</span> <span class="n">computeTrans_DFM</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p>This function is modified from the original computeTrans to include
hybrid (essentially lower-dimensional) cells representing fractures etc.
The hybrid cells are located on the interface between two ‘normal’ cells
and have no extension (they are lines in 2D and planes in 3D) in the
geometric grid.
However, they are accounted for in the computational grid and are
assigned an area (2D) or volume (3D). For more information see
Karimi-Fard (SPE 2004).</p>
<p>This function is a part of the DFM-module of MRST, and should be applied
together with other functions of that module.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure as described by grid_structure.</p></li>
<li><p><strong>rock</strong> – <p>Rock data structure with valid field ‘perm’.  The permeability
is assumed to be in measured in units of meters squared (m^2).
Use function ‘darcy’ to convert from darcies to m^2, e.g.,</p>
<blockquote>
<div><p>perm = convertFrom(perm, milli*darcy)</p>
</div></blockquote>
<p>if the permeability is provided in units of millidarcies.</p>
<p>The field rock.perm may have ONE column for a scalar
permeability in each cell, TWO/THREE columns for a diagonal
permeability in each cell (in 2/3 D) and THREE/SIX columns for a
symmetric full tensor permeability.  In the latter case, each
cell gets the permeability tensor</p>
<blockquote>
<div><dl class="simple">
<dt>K_i = [ k1  k2 ]      in two space dimensions</dt><dd><p>[ k2  k3 ]</p>
</dd>
<dt>K_i = [ k1  k2  k3 ]  in three space dimensions</dt><dd><p>[ k2  k4  k5 ]
[ k3  k5  k6 ]</p>
</dd>
</dl>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>K_system</strong> – Define the system permeability is defined in valid values
are ‘xyz’ and ‘loc_xyz’.</p></li>
<li><p><strong>cellCenters</strong> – Compute transmissibilities based on supplied cellCenters
rather than default G.cells.centroids</p></li>
<li><p><strong>cellFaceCenters</strong> – Compute transmissibilities based on supplied
cellFaceCenters rather then default
G.faces.centroids(G.cells.faces(:,1), :)</p></li>
<li><p><strong>hybrid</strong> – if true the distance between the cell center and the face center
is extended half an aperture in the direction of the normal.</p></li>
<li><p><strong>compactNeighboringCell</strong> – Whether hybrid faces should be expanded for
the cells on both sides of the face. Only
activated if hybrid is true</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>T</strong> – half-transmissibilities for each local face of each grid cell in
the grid.  The number of half-transmissibilities equals the number
of rows in G.cells.faces.</p>
</dd>
</dl>
<dl class="simple">
<dt>COMMENTS:</dt><dd><p>PLEASE NOTE: Face normals are assumed to have length equal to the
corresponding face areas.  This property is guaranteed by function
‘computeGeometry’.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>, <a class="reference internal" href="mimetic.html#mimetic.computeMimeticIP" title="mimetic.computeMimeticIP"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeMimeticIP</span></code></a>, <a class="reference internal" href="core.html#core.utils.units.darcy" title="core.utils.units.darcy"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">darcy</span></code></a>, <a class="reference internal" href="core.html#core.params.rock.permTensor" title="core.params.rock.permTensor"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">permTensor</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.distance_to_closest_line">
<span class="sig-name descname"><span class="pre">distance_to_closest_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.distance_to_closest_line" title="Permalink to this definition"></a></dt>
<dd><p>Copyright 2011-2012 University of Bergen</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.explicitTransport_DFM">
<span class="sig-name descname"><span class="pre">explicitTransport_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">tf</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.explicitTransport_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Explicit single point upwind transport solver for two-phase flow.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">explicitTransport_DFM</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">)</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">explicitTransport_DFM</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Function explicitTransport solves the Buckley-Leverett transport
equation</p>
<blockquote>
<div><blockquote>
<div></div></blockquote>
<p>s_t + /· [f(s)(v·n + mo(rho_w - rho_o)n·Kg)] = f(s)q</p>
</div></blockquote>
<p>using a first-order mobility-weighted upwind discretisation in space
and a forward Euler discretisation in time.  The transport equation is
solved on the time interval [0,tf] by calling twophaseJacobian to build
a function computing the residual of the discrete system in addition to
a function taking care of the update of the solution during the
time loop.</p>
<p>This file is modified from the original explicit transport method to
account for hybrid (fracture) cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – Reservoir and well solution structure either properly
initialized from functions ‘initResSol’ and ‘initWellSol’
respectively, or the results from a previous call to function
‘solveIncompFlow’ and, possibly, a transport solver such as
function ‘implicitTransport’.</p></li>
<li><p><strong>G</strong> – Grid data structure discretising the reservoir model.</p></li>
<li><p><strong>tf</strong> – End point of time integration interval (i.e., final time).
Measured in units of seconds.</p></li>
<li><p><strong>rock</strong> – Rock data structure.  Must contain the field ‘rock.poro’,
and in the presence of gravity, valid permeabilities measured
in units of m^2 in field ‘rock.perm’.</p></li>
<li><p><strong>fluid</strong> – Fluid data structure as defined in ‘fluid_structure’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>wells</strong> – Well structure as defined by function ‘addWell’.  This
structure accounts for all injection and production well
contribution to the reservoir flow.
Default value: wells = [], meaning a model without any
wells.</p></li>
<li><p><strong>bc</strong> – Boundary condtion structure as defined by function
‘addBC’.  This structure accounts for all external boundary
contributions to the reservoir flow.
Default value: bc = [] meaning all external no-flow
(homogeneous Neumann) conditions.</p></li>
<li><p><strong>src</strong> – Explicit source contributions as defined by function
‘addSource’. Default value: src = [] meaning no explicit
sources exist in the model.</p></li>
<li><p><strong>onlygrav</strong> – Ignore content of state.flux.         Default false.</p></li>
<li><p><strong>computedt</strong> – Estimate time step.                   Default true.</p></li>
<li><p><strong>max_dt</strong> – If ‘computedt’, limit time step.      Default inf.</p></li>
<li><p><strong>dt_factor</strong> – Safety factor in time step estimate.  Default 0.5.</p></li>
<li><p><strong>dt</strong> – Set time step manually.  Overrides all other options.</p></li>
<li><p><strong>satwarn</strong> – Currently unused.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>state</strong> – Reservoir solution with updated saturation, state.s.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">See</span> <span class="n">simple2phWellExample</span><span class="p">.</span><span class="n">m</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">twophaseJacobian</span></code>, <a class="reference internal" href="incomp.html#incomp.transport.implicitTransport" title="incomp.transport.implicitTransport"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">implicitTransport</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.implicitTransport_DFM">
<span class="sig-name descname"><span class="pre">implicitTransport_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">tf</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.implicitTransport_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Implicit single point upwind transport solver for two-phase flow.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">implicitTransport</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">)</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">implicitTransport</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Function implicitTransport solves the Buckley-Leverett transport
equation</p>
<blockquote>
<div><p>s_t + f(s)_x = q</p>
</div></blockquote>
<p>using a first-order mobility-weighted upwind discretisation in space
and a backward Euler discretisation in time.  The transport equation is
solved on the time interval [0,tf] by calling the private function
‘twophaseJacobian_DFM’ to build functions computing the residual and the
Jacobian matrix of the discrete system in addition to a function taking
care of the update of the soultion solution during a Newton-Raphson
iteration.  These functions are passed to the private function
‘newtonRaphson2ph’ that implements a Newton-Raphson iteration with some
logic to modify time step size in case of non-convergence.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – Reservoir and well solution structure either properly
initialized from function ‘initState’, or the results from a
previous call to function ‘solveIncompFlow’ and, possibly, a
transport solver such as function ‘implicitTransport’.</p></li>
<li><p><strong>G</strong> – Grid data structure discretising the reservoir model.</p></li>
<li><p><strong>tf</strong> – End point of time integration interval (i.e., final time).
Measured in units of seconds.</p></li>
<li><p><strong>rock</strong> – Rock data structure.  Must contain the field ‘rock.poro’ and,
in the presence of gravity or capillary forces, valid
permeabilities measured in units of m^2 in field ‘rock.perm’.</p></li>
<li><p><strong>fluid</strong> – Fluid data structure as described by ‘fluid_structure’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>verbose</strong> – Whether or not time integration progress should be
reported to the screen. Default value: verbose = false.</p></li>
<li><p><strong>wells</strong> – Well structure as defined by function ‘addWell’.  May be
empty (i.e., W = []) which is interpreted as a model without
any wells.</p></li>
<li><p><strong>bc</strong> – Boundary condtion structure as defined by function
‘addBC’. This structure accounts for all external boundary
contributions to the reservoir flow.
Default value: bc = [] meaning all external no-flow
(homogeneous Neumann) conditions.</p></li>
<li><p><strong>src</strong> – Explicit source contributions as defined by function
‘addSource’. Default value: src = [] meaning no explicit
sources exist in the model.</p></li>
<li><p><strong>OnlyGrav</strong> – Only consider transport caused by gravity, (ignore Darcy
flux from pressure solution).  Used for gravity splitting.
Default value: OnlyGrav = false.</p></li>
<li><p><strong>Trans</strong> – two point flux transmissibilities. This will be used in
stead of rock. Usefull for grids with out proper geometry and
or for getting consistency with pressure solver.</p></li>
<li><p><strong>nltol</strong> – Absolute tolerance of iteration.  The numerical solution
must satisfy the condition</p>
<blockquote>
<div><p>NORM(S-S0 + dt/porvol(out - in) - Q, INF) &lt;= nltol</p>
</div></blockquote>
<p>at all times in the interval [0,tf].
Default value: nltol = 1.0e-6.</p>
</li>
<li><p><strong>lstrials</strong> – Maximum number of trials in linesearch method.  Each new
trial corresponds to halving the step size along the
search direction. Default value: lstrials = 20.</p></li>
<li><p><strong>maxnewt</strong> – Maximum number of inner iterations in Newton-Raphson method.
Default value: maxnewt = 25.</p></li>
<li><p><strong>tsref</strong> – Maximum time step refinement power.  The minimum time step
allowed is tf / 2^tsref.
Default value: tsref = 12.</p></li>
<li><p><strong>LinSolve</strong> – Handle to linear system solver software to which the fully
assembled system of linear equations will be passed.
Assumed to support the syntax</p>
<blockquote>
<div><p>x = LinSolve(A, b)</p>
</div></blockquote>
<p>in order to solve a system Ax=b of linear equations.
Default value: LinSolve = &#64;mldivide (backslash).</p>
</li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>state</strong> – Updated reservoir/well solution object.
New values for reservoir saturations, state.s.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">See</span> <span class="n">simple2phWellExample</span><span class="p">.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="incomp.html#incomp.transport.explicitTransport" title="incomp.transport.explicitTransport"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">explicitTransport</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">private/twophaseJacobian</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">private/newtonRaphson2ph</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.incompMPFA_DFM">
<span class="sig-name descname"><span class="pre">incompMPFA_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">T</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.incompMPFA_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Solve incompressible flow problem (fluxes/pressures) using MPFA-O method.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">incompMPFA_DFM</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">fluid</span><span class="p">)</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">incompMPFA_DFM</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function assembles and solves a (block) system of linear equations
defining interface fluxes and cell pressures at the next time step in a
sequential splitting scheme for the reservoir simulation problem
defined by Darcy’s law and a given set of external influences (wells,
sources, and boundary conditions).</p>
<p>This function uses a multi-point flux approximation (MPFA) method with
minimal memory consumption within the constraints of operating on a
fully unstructured polyhedral grid structure.</p>
<p>The function is modified from the original incompMPFA (legacy version) to account for
non-neighbor cell-to-cell connections for hybrid cells.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – Reservoir and well solution structure either properly
initialized from functions ‘initResSol’ and ‘initWellSol’
respectively, or the results from a previous call to function
‘incompMPFA’ (legacy version) and, possibly, a transport solver such as
function ‘implicitTransport’.</p></li>
<li><p><strong>G</strong> – Grid and half-transmissibilities as computed by the function
‘computeTrans’.</p></li>
<li><p><strong>T</strong> – Grid and half-transmissibilities as computed by the function
‘computeTrans’.</p></li>
<li><p><strong>fluid</strong> – Fluid object as defined by function ‘initSimpleFluid’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>wells</strong> – Well structure as defined by functions ‘addWell’ and
‘assembleWellSystem’.  May be empty (i.e., W = struct([]))
which is interpreted as a model without any wells.</p></li>
<li><p><strong>bc</strong> – Boundary condition structure as defined by function ‘addBC’.
This structure accounts for all external boundary conditions to
the reservoir flow.  May be empty (i.e., bc = struct([])) which
is interpreted as all external no-flow (homogeneous Neumann)
conditions.</p></li>
<li><p><strong>src</strong> – Explicit source contributions as defined by function
‘addSource’.  May be empty (i.e., src = struct([])) which is
interpreted as a reservoir model without explicit sources.</p></li>
<li><p><strong>LinSolve</strong> – Handle to linear system solver software to which the
fully assembled system of linear equations will be
passed.  Assumed to support the syntax</p>
<blockquote>
<div><p>x = LinSolve(A, b)</p>
</div></blockquote>
<p>in order to solve a system Ax=b of linear equations.
Default value: LinSolve = &#64;mldivide (backslash).</p>
</li>
<li><p><strong>MatrixOutput</strong> – Whether or not to return the final system matrix ‘A’ to
the caller of function ‘incompTPFA’.
Logical.  Default value: MatrixOutput = FALSE.</p></li>
<li><p><strong>Verbose</strong> – Whether or not to time portions of and emit informational
messages throughout the computational process.
Logical.  Default value dependent on global verbose
setting in function ‘mrstVerbose’.</p></li>
<li><p><strong>cellConnection</strong> – If true, cell connections spesified by T.cellTrans are added
The connections must be spesified in G.cells.neighbors.
A vector flux2 is returned contining the extra fluxes.</p></li>
<li><p><strong>upwind</strong> – If true, the upwind mobility is used, els the harmonic
averange of the mobility is used</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul>
<li><p><strong>xr</strong> – Reservoir solution structure with new values for the fields:
- pressure     – Pressure values for all cells in the</p>
<blockquote>
<div><p>discretised reservoir model, ‘G’.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>boundaryPressure –</dt><dd><p>Pressure values for all boundary interfaces in
the discretised reservoir model, ‘G’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>flux         – Flux across global interfaces corresponding to</dt><dd><p>the rows of ‘G.faces.neighbors’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A            – System matrix.  Only returned if specifically</dt><dd><p>requested by setting option ‘MatrixOutput’.</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><strong>xw</strong> – Well solution structure array, one element for each well in the
model, with new values for the fields:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>flux     – Perforation fluxes through all perforations for</dt><dd><p>corresponding well.  The fluxes are interpreted
as injection fluxes, meaning positive values
correspond to injection into reservoir while
negative values mean production/extraction out of
reservoir.</p>
</dd>
</dl>
</li>
<li><p>pressure – Well pressure.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are no external influences, i.e., if all of the structures
‘W’, ‘bc’, and ‘src’ are empty and there are no effects of gravity,
then the input values ‘xr’ and ‘xw’ are returned unchanged and a
warning is printed in the command window. This warning is printed with
message ID</p>
<blockquote>
<div><p>‘incompMPFA:DrivingForce:Missing’</p>
</div></blockquote>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span>   <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]));</span>
<span class="n">f</span>   <span class="p">=</span> <span class="n">initSingleFluid</span><span class="p">();</span>
<span class="n">rock</span><span class="p">.</span><span class="n">perm</span> <span class="p">=</span> <span class="nb">rand</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">darcy</span><span class="p">()</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span>
<span class="n">bc</span>  <span class="p">=</span> <span class="n">pside</span><span class="p">([],</span> <span class="n">G</span><span class="p">,</span> <span class="s">&#39;LEFT&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">src</span> <span class="p">=</span> <span class="n">addSource</span><span class="p">([],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">W</span>   <span class="p">=</span> <span class="n">verticalWell</span><span class="p">([],</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">...</span>
                   <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="s">&#39;Type&#39;</span><span class="p">,</span> <span class="s">&#39;rate&#39;</span><span class="p">,</span> <span class="s">&#39;Val&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">day</span><span class="p">(),</span> <span class="p">...</span>
                   <span class="s">&#39;InnerProduct&#39;</span><span class="p">,</span> <span class="s">&#39;ip_tpf&#39;</span><span class="p">);</span>
<span class="n">W</span>   <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>   <span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">...</span>
                   <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="s">&#39;Type&#39;</span><span class="p">,</span> <span class="s">&#39;bhp&#39;</span><span class="p">,</span> <span class="p">...</span>
                   <span class="s">&#39;Val&#39;</span><span class="p">,</span>  <span class="mi">1</span><span class="o">*</span><span class="n">barsa</span><span class="p">(),</span> <span class="s">&#39;InnerProduct&#39;</span><span class="p">,</span> <span class="s">&#39;ip_tpf&#39;</span><span class="p">);</span>
<span class="n">T</span>   <span class="p">=</span> <span class="n">computeMultiPointTrans</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">);</span>
<span class="n">xr</span>  <span class="p">=</span> <span class="n">initResSol</span> <span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">xw</span>  <span class="p">=</span> <span class="n">initWellSol</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">[</span><span class="n">xr</span><span class="p">,</span><span class="n">xw</span><span class="p">]</span> <span class="p">=</span> <span class="n">incompMPFA</span><span class="p">(</span><span class="n">xr</span><span class="p">,</span> <span class="n">xw</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s">&#39;bc&#39;</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="s">&#39;src&#39;</span><span class="p">,</span><span class="n">src</span><span class="p">,</span><span class="s">&#39;wells&#39;</span><span class="p">,</span><span class="n">W</span><span class="p">,...</span>
                     <span class="s">&#39;MatrixOutput&#39;</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>

<span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">xr</span><span class="p">.</span><span class="n">cellPressure</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeMultiPointTransLegacy</span></code>, <a class="reference internal" href="core.html#core.params.wells_and_bc.addBC" title="core.params.wells_and_bc.addBC"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addBC</span></code></a>, <a class="reference internal" href="core.html#core.params.wells_and_bc.addSource" title="core.params.wells_and_bc.addSource"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addSource</span></code></a>, <a class="reference internal" href="core.html#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a>, <a class="reference internal" href="incomp.html#incomp.fluid.incompressible.initSingleFluid" title="incomp.fluid.incompressible.initSingleFluid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initSingleFluid</span></code></a>,
<a class="reference internal" href="core.html#core.solvers.initResSol" title="core.solvers.initResSol"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initResSol</span></code></a>, <a class="reference internal" href="core.html#core.solvers.initWellSol" title="core.solvers.initWellSol"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initWellSol</span></code></a>, <a class="reference internal" href="core.html#core.utils.mrstVerbose" title="core.utils.mrstVerbose"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstVerbose</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.incompTPFA_DFM">
<span class="sig-name descname"><span class="pre">incompTPFA_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">T</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.incompTPFA_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Solve incompressible flow problem (fluxes/pressures) using TPFA method.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">incompTPFA_DFM</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">fluid</span><span class="p">)</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">incompTPFA_DFM</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function assembles and solves a (block) system of linear equations
defining interface fluxes and cell pressures at the next time step in a
sequential splitting scheme for the reservoir simulation problem
defined by Darcy’s law and a given set of external influences (wells,
sources, and boundary conditions).</p>
<p>This function uses a two-point flux approximation (TPFA) method with
minimal memory consumption within the constraints of operating on a
fully unstructured polyhedral grid structure.</p>
<p>The function is modified from the original incompMPFA (legacy version) to account for
non-neighbor cell-to-cell connections for hybrid cells.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This file is modified from the original incompTPFA to account for the
precence of hybrid cells in the grid. Furthermore, the mobility can be
treated by upstream weighting instead of harmonic averaging (only for
horizontal flow without capillary pressure).</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – Reservoir and well solution structure either properly
initialized from functions ‘initResSol’ and ‘initWellSol’
respectively, or the results from a previous call to function
‘incompTPFA’ and, possibly, a transport solver such as
function ‘implicitTransport’.</p></li>
<li><p><strong>G</strong> – Grid and half-transmissibilities as computed by the function
‘computeTrans’.</p></li>
<li><p><strong>T</strong> – Grid and half-transmissibilities as computed by the function
‘computeTrans’.</p></li>
<li><p><strong>fluid</strong> – Fluid object as defined by function ‘initSimpleFluid’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>wells</strong> – Well structure as defined by function ‘addWell’.  May be empty
(i.e., W = struct([])) which is interpreted as a model without
any wells.</p></li>
<li><p><strong>bc</strong> – Boundary condition structure as defined by function ‘addBC’.
This structure accounts for all external boundary conditions to
the reservoir flow.  May be empty (i.e., bc = struct([])) which
is interpreted as all external no-flow (homogeneous Neumann)
conditions.</p></li>
<li><p><strong>src</strong> – Explicit source contributions as defined by function
‘addSource’.  May be empty (i.e., src = struct([])) which is
interpreted as a reservoir model without explicit sources.</p></li>
<li><p><strong>LinSolve</strong> – Handle to linear system solver software to which the
fully assembled system of linear equations will be
passed.  Assumed to support the syntax</p>
<blockquote>
<div><p>x = LinSolve(A, b)</p>
</div></blockquote>
<p>in order to solve a system Ax=b of linear equations.
Default value: LinSolve = &#64;mldivide (backslash).</p>
</li>
<li><p><strong>MatrixOutput</strong> – Whether or not to return the final system matrix ‘A’ to
the caller of function ‘incompTPFA’.
Logical.  Default value: MatrixOutput = FALSE.</p></li>
<li><p><strong>verbose</strong> – Enable output.  Default value dependent upon global verbose
settings of function ‘mrstVerbose’.</p></li>
<li><p><strong>condition_number</strong> – Display estimated condition number of linear system.</p></li>
<li><p><strong>cellConnection</strong> – A vector containing the transmissibilities for the cell
connections. The connections must be spesified in
G.cells.neighbors.
A vector state.fluxc2c is returned contining the cell2cell
fluxes.</p></li>
<li><p><strong>upwind</strong> – If true, the upwind mobility is used, els the harmonic
averange of the mobility is used</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>state</strong> – Update reservoir and well solution structure with new values
for the fields:</p>
<blockquote>
<div><ul>
<li><dl class="simple">
<dt>pressure – Pressure values for all cells in the</dt><dd><p>discretised reservoir model, ‘G’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>facePressure –</dt><dd><p>Pressure values for all interfaces in the
discretised reservoir model, ‘G’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>flux     – Flux across global interfaces corresponding to</dt><dd><p>the rows of ‘G.faces.neighbors’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A        – System matrix.  Only returned if specifically</dt><dd><p>requested by setting option ‘MatrixOutput’.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>wellSol  – Well solution structure array, one element for</dt><dd><p>each well in the model, with new values for
the fields:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>flux     – Perforation fluxes through all</dt><dd><p>perforations for corresponding
well.  The fluxes are
interpreted as injection
fluxes, meaning positive
values correspond to injection
into reservoir while negative
values mean
production/extraction out of
reservoir.</p>
</dd>
</dl>
</li>
<li><p>pressure – Well bottom-hole pressure.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>fluxc2c – Fluxes over cell-to-cell connections</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are no external influences, i.e., if all of the structures
‘W’, ‘bc’, and ‘src’ are empty and there are no effects of gravity,
then the input values ‘xr’ and ‘xw’ are returned unchanged and a
warning is printed in the command window. This warning is printed with
message ID</p>
<blockquote>
<div><p>‘incompTPFA:DrivingForce:Missing’</p>
</div></blockquote>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span>   <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]));</span>

<span class="n">f</span>   <span class="p">=</span> <span class="n">initSingleFluid</span><span class="p">(</span><span class="s">&#39;mu&#39;</span> <span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">centi</span><span class="o">*</span><span class="n">poise</span><span class="p">,</span> <span class="p">...</span>
                      <span class="s">&#39;rho&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="o">*</span><span class="n">kilogram</span><span class="o">/</span><span class="n">meter</span>^<span class="mi">3</span><span class="p">);</span>
<span class="n">rock</span><span class="p">.</span><span class="n">perm</span> <span class="p">=</span> <span class="nb">rand</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">darcy</span><span class="p">()</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span>

<span class="n">bc</span>  <span class="p">=</span> <span class="n">pside</span><span class="p">([],</span> <span class="n">G</span><span class="p">,</span> <span class="s">&#39;LEFT&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">barsa</span><span class="p">);</span>
<span class="n">src</span> <span class="p">=</span> <span class="n">addSource</span><span class="p">([],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">W</span>   <span class="p">=</span> <span class="n">verticalWell</span><span class="p">([],</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">[]</span>   <span class="p">,</span> <span class="p">...</span>
                   <span class="s">&#39;Type&#39;</span><span class="p">,</span> <span class="s">&#39;rate&#39;</span><span class="p">,</span> <span class="s">&#39;Val&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">meter</span>^<span class="mi">3</span><span class="o">/</span><span class="n">day</span><span class="p">,</span> <span class="p">...</span>
                   <span class="s">&#39;InnerProduct&#39;</span><span class="p">,</span> <span class="s">&#39;ip_tpf&#39;</span><span class="p">);</span>
<span class="n">W</span>   <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">[],</span> <span class="p">...</span>
                   <span class="s">&#39;Type&#39;</span><span class="p">,</span> <span class="s">&#39;bhp&#39;</span><span class="p">,</span> <span class="s">&#39;Val&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">barsa</span><span class="p">,</span> <span class="p">...</span>
                   <span class="s">&#39;InnerProduct&#39;</span><span class="p">,</span> <span class="s">&#39;ip_tpf&#39;</span><span class="p">);</span>

<span class="n">T</span>   <span class="p">=</span> <span class="n">computeTrans</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">);</span>

<span class="n">state</span>         <span class="p">=</span> <span class="n">initResSol</span> <span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">state</span><span class="p">.</span><span class="n">wellSol</span> <span class="p">=</span> <span class="n">initWellSol</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

<span class="n">state</span> <span class="p">=</span> <span class="n">incompTPFA</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s">&#39;bc&#39;</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="s">&#39;src&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">...</span>
                   <span class="s">&#39;wells&#39;</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="s">&#39;MatrixOutput&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

<span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">state</span><span class="p">.</span><span class="n">pressure</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.solvers.computeTrans" title="core.solvers.computeTrans"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeTrans</span></code></a>, <a class="reference internal" href="core.html#core.params.wells_and_bc.addBC" title="core.params.wells_and_bc.addBC"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addBC</span></code></a>, <a class="reference internal" href="core.html#core.params.wells_and_bc.addSource" title="core.params.wells_and_bc.addSource"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addSource</span></code></a>, <a class="reference internal" href="core.html#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a>, <a class="reference internal" href="incomp.html#incomp.fluid.incompressible.initSingleFluid" title="incomp.fluid.incompressible.initSingleFluid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initSingleFluid</span></code></a>, <a class="reference internal" href="core.html#core.solvers.initResSol" title="core.solvers.initResSol"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initResSol</span></code></a>,
<a class="reference internal" href="core.html#core.solvers.initWellSol" title="core.solvers.initWellSol"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initWellSol</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.lines_intersect">
<span class="sig-name descname"><span class="pre">lines_intersect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x_a_1</span></em>, <em class="sig-param"><span class="pre">y_a_1</span></em>, <em class="sig-param"><span class="pre">x_b_1</span></em>, <em class="sig-param"><span class="pre">y_b_1</span></em>, <em class="sig-param"><span class="pre">x_a_2</span></em>, <em class="sig-param"><span class="pre">y_a_2</span></em>, <em class="sig-param"><span class="pre">x_b_2</span></em>, <em class="sig-param"><span class="pre">y_b_2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.lines_intersect" title="Permalink to this definition"></a></dt>
<dd><p>[pt] = lines_intersect (vertices, edge1, edge2)</p>
<p>Determine the intersection between two lines, if any. t will either be
0 or 1 depending on whether there are any intersections, in that case x
and y will be the coordinates of the point that intersect. The input
arguments is the global list of points, and two tuples that contains
the indices into this list.</p>
<p>Portions Copyright (C) 2006-2007 Uni Research AS
This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.nodeType">
<span class="sig-name descname"><span class="pre">nodeType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">nodes</span></em>, <em class="sig-param"><span class="pre">box</span></em>, <em class="sig-param"><span class="pre">h</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.nodeType" title="Permalink to this definition"></a></dt>
<dd><p>return node type
0: inner node 1: edge node 2: corner node</p>
<p>SYNAPSES
boundaryType = numBoundaries(g,nodes,box,h)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>g - mrst grid structure
nodes - a list of nodes to check</p>
<p>OPTIONAL
box  - bounding box of the domain
h - a distance tolerance to include close nodes</p>
<blockquote>
<div><p>default: sqrt(eps)</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>nodeType - a vector giving the node types of the input nodes</dt><dd><p>0: inner node 1: edge node 2: corner node</p>
</dd>
</dl>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.partition_edges">
<span class="sig-name descname"><span class="pre">partition_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">vertices</span></em>, <em class="sig-param"><span class="pre">old_edges</span></em>, <em class="sig-param"><span class="pre">space</span></em>, <em class="sig-param"><span class="pre">box</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.partition_edges" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>[vertices, new_edges, num_added] = …</dt><dd><p>partition_edges (vertices, old_edges, space, box, opts)</p>
</dd>
</dl>
<p>Make sure that no edges are longer than the give size. If an edge is
longer, it is split up into subsegments which are then joined together.
map is a m-by-2 array which contains in the first column the index of the
vertex added and in the second column the index of a line to which it is
constrained.</p>
<p>Portions Copyright (C) 2006-2007 Uni Research AS
This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.plotEdges">
<span class="sig-name descname"><span class="pre">plotEdges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">coords</span></em>, <em class="sig-param"><span class="pre">edges</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.plotEdges" title="Permalink to this definition"></a></dt>
<dd><p>plot lines
SYNOPSIS</p>
<blockquote>
<div><p>plotEdges(coords,edges,varargin)</p>
</div></blockquote>
<dl>
<dt>PARAMETERS</dt><dd><p>coords - coordinates of the the end points of the edges
edges - end points of the edges</p>
<p>OPTIONAL</p>
<dl class="simple">
<dt>varargin - argument directly applied in plot.m</dt><dd><p>see help plot for all the options</p>
</dd>
</dl>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.read_openoffice">
<span class="sig-name descname"><span class="pre">read_openoffice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filename</span></em>, <em class="sig-param"><span class="pre">ext</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.read_openoffice" title="Permalink to this definition"></a></dt>
<dd><p>Read fractures drawn in Libreoffice, and represent them as points and
edges.</p>
<p>Copyright (C) 2006-2007 Uni Research AS
This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.removeFractureIntersections">
<span class="sig-name descname"><span class="pre">removeFractureIntersections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">vertices</span></em>, <em class="sig-param"><span class="pre">edges</span></em>, <em class="sig-param"><span class="pre">box</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.removeFractureIntersections" title="Permalink to this definition"></a></dt>
<dd><p>Partition intersecting edges by adding a point in the intersection.</p>
<p>Copyright 2011-2012 University of Bergen
This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.removeInternalBoundary_DFM">
<span class="sig-name descname"><span class="pre">removeInternalBoundary_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">N</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.removeInternalBoundary_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Remove internal boundary in grid by merging faces in face list N</p>
<p>This function is modified to account for hybrid cells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">removeInternalBoundary_DFM</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure as described by grid_structure.</p></li>
<li><p><strong>N</strong> – An n x 2 array of face numbers.  Each pair in the array
will be merged to a single face in G.  The connectivity if
the new grid is updated accordingly.  The geometric adjacency
of faces is not checked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Modified grid structure.</p>
</dd>
</dl>
<p>COMMENTS:</p>
<blockquote>
<div><p>What if nodes in f1 are permuted compared to nodes in f2, either due to
sign of face (2D) or due to arbitary starting node (3D)?  For the time
being, this code assumes that nodes that appear in faces that are being
merged coincide exactly — no checking is doen on node positions.  If
nodes are permuted in one of the faces, the resulting grid will be
warped.</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeInteralBoundary</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.remove_closepoints">
<span class="sig-name descname"><span class="pre">remove_closepoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">vertices</span></em>, <em class="sig-param"><span class="pre">edges</span></em>, <em class="sig-param"><span class="pre">old_points</span></em>, <em class="sig-param"><span class="pre">tol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.remove_closepoints" title="Permalink to this definition"></a></dt>
<dd><p>Remove all points that are too close to the lines, since these will only
cause slivers.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.snap_to_grid">
<span class="sig-name descname"><span class="pre">snap_to_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">vertices</span></em>, <em class="sig-param"><span class="pre">box</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.snap_to_grid" title="Permalink to this definition"></a></dt>
<dd><p>Move vertices to the closest (structured) grid point.</p>
<p>Use this function to avoid having more than one point within each (fine)
grid cell. If this is not done, a low quality grid may result</p>
<p>Copyright (C) 2006-2007 Uni Research AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.split_edge">
<span class="sig-name descname"><span class="pre">split_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">vertices</span></em>, <em class="sig-param"><span class="pre">edges</span></em>, <em class="sig-param"><span class="pre">i</span></em>, <em class="sig-param"><span class="pre">pt</span></em>, <em class="sig-param"><span class="pre">box</span></em>, <em class="sig-param"><span class="pre">opts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.split_edge" title="Permalink to this definition"></a></dt>
<dd><p>Split an edge into two parts</p>
<p>Create two new edges from one old. Split an edge at index i into two
at the point (x, y) given by pt and insert the two parts in its
place. (The rest of the edge set is adjusted . It assumes that the point
(x, y) is on the line. The result variable new_line is 0 if no line is
added since the point is already one of the endpoints of the old line, or
1 if a new line is created, i.e. the old line fissioned into two lines
(the value is the number of lines that are added).</p>
<p>Copyright (C) 2006-2007 Uni Research AS
This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.testNormals">
<span class="sig-name descname"><span class="pre">testNormals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.testNormals" title="Permalink to this definition"></a></dt>
<dd><p>Tests if the normals points from neighbor 1 to 2 and returns the index of
the normals that points in the opposite direction.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="p">=</span> <span class="n">testNormals</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>i</strong> – Index of the normals pointing in the wrong direction. Empty
if all the normals points correctly.</p></li>
</ul>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.triangulate">
<span class="sig-name descname"><span class="pre">triangulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">vertices</span></em>, <em class="sig-param"><span class="pre">constraints</span></em>, <em class="sig-param"><span class="pre">tags</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.triangulate" title="Permalink to this definition"></a></dt>
<dd><p>Make a Delaunay Triangulation and return a Mrst grid</p>
<p>SYNOPSIS
g = triangulate(vertices,edges)</p>
<dl>
<dt>PARAMETERS</dt><dd><blockquote>
<div><p>vertices    - the vertices in the triangulation
constraint  - constraint to the triangulation</p>
</div></blockquote>
<dl class="simple">
<dt>Optinal</dt><dd><p>tags        - one tag for each constraint</p>
</dd>
</dl>
<p>RETURNS</p>
<blockquote>
<div><p>g           - grid structure for mrst as described in grid_structre</p>
</div></blockquote>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.twophaseJacobian_DFM">
<span class="sig-name descname"><span class="pre">twophaseJacobian_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.twophaseJacobian_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Residual and Jacobian of single point upwind solver for two-phase flow.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">resSol</span> <span class="p">=</span> <span class="n">twophaseJacobian_DFM</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">)</span>
<span class="n">resSol</span> <span class="p">=</span> <span class="n">twophaseJacobian_DFM</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Function twophaseJacobian returns function handles for the residual
and its Jacobian matrix for the implicit upwind-mobility weighted
dicretization of</p>
<blockquote>
<div><blockquote>
<div></div></blockquote>
<p>s_t + /· [f(s)(v·n + mo(rho_w - rho_o)n·Kg)] = f(s)q</p>
</div></blockquote>
<p>where v·n is the sum of the phase Dary fluxes, f is the fractional
flow function,</p>
<blockquote>
<div><blockquote>
<div><p>mw(s)</p>
</div></blockquote>
<dl class="simple">
<dt>f(s) = ————-</dt><dd><p>mw(s) + mo(s)</p>
</dd>
</dl>
</div></blockquote>
<p>mi = kr_i/mu_i is the phase mobiliy of phase i, mu_i and rho_i are the
phase viscosity and density, respectivelym, g the (vector) acceleration
of gravity and K the permeability.  The source term f(s)q is a
volumetric rate of water.</p>
<p>Using a first-order upwind discretisation in space and a backward Euler
discretisation in time,  the residual of the nonlinear system of
equations that must be solved to move the solution state.s from time=0
to time=tf, are obtained by calling F(state, s0, dt) which yields
Likewise, the Jacobian matrix is obtained using the function Jac.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This file has been modified from the original twophaseJacobian to
account for non-neighbor connections, as described by the field
G.cells.neighbors. The modification is intended for grids with hybrid
cells, but might be of use for other applications as well. Also note
that all modifications needed to apply the implicit transport solver to
a grid with cell-to-cell connections are done within this file.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>resSol</strong> – Reservoir solution structure containing valid
saturation resSol.s with one value for each cell in
the grid.</p></li>
<li><p><strong>G</strong> – Grid data structure discretising the reservoir model.</p></li>
<li><p><strong>rock</strong> – Struct with fields perm and poro.  The permeability field
(‘perm’) is only referenced when solving problems involving
effects of gravity and/or capillary pressure and need not be
specified otherwise.</p></li>
<li><p><strong>fluid</strong> – Data structure describing the fluids in the problem.</p></li>
</ul>
</dd>
</dl>
<p>OPTIONAL PARAMETERS:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> – Residual</p></li>
<li><p><strong>Jac</strong> – Jacobian matrix (with respect to s) of residual.</p></li>
</ul>
</dd>
</dl>
<p>EXAMPLE:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="incomp.html#incomp.transport.implicitTransport" title="incomp.transport.implicitTransport"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">implicitTransport</span></code></a>, <a class="reference internal" href="incomp.html#incomp.transport.explicitTransport" title="incomp.transport.explicitTransport"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">explicitTransport</span></code></a>.</p>
</div>
</dd></dl>

<span class="target" id="module-dfm.plotting"></span><dl class="mat script">
<dt class="sig sig-object mat" id="dfm.plotting.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#dfm.plotting.Contents" title="Permalink to this definition"></a></dt>
<dd><p>Files
plotCellData_DFM.m - Plot exterior grid faces, coloured by given data, to current axes.
plotFaces_DFM.m    - Plot selection of coloured grid faces to current axes (reversed Z axis).
plotFractures.m    - SYNOPSIS:
plotGrid_DFM.m     - Plot exterior grid faces to current axes (reversed Z axis).</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.plotting.plotCellData_DFM">
<span class="sig-name descname"><span class="pre">plotCellData_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">data</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.plotting.plotCellData_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Plot exterior grid faces, coloured by given data, to current axes.</p>
<p>This function has been modified from the original plotGrid to account for
hybrid cells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
 <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
 <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>
 <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotCellData</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>data</strong> – Scalar cell data with which to colour the grid.  One scalar,
indexed colour value for each cell in the grid or one
TrueColor value for each cell.  If a cell subset is specified
in terms of the ‘cells’ parameter, ‘data’ must either contain
one scalar value for each cell in the model or one scalar
value for each cell in this subset.</p></li>
<li><p><strong>cells</strong> – <p>Vector of cell indices defining sub grid.  The graphical
output of function ‘plotCellData’ will be restricted to the
subset of cells from ‘G’ represented by ‘cells’.</p>
<p>If unspecified, function ‘plotCellData’ will behave as if the
user defined</p>
<blockquote>
<div><p>cells = 1 : G.cells.num</p>
</div></blockquote>
<p>meaning graphical output will be produced for all cells in
the grid model ‘G’.  If ‘cells’ is empty (i.e., if
ISEMPTY(cells)), then no graphical output will be produced.</p>
</p></li>
<li><p><strong>'pn'/pv</strong> – List of property names/property values.  OPTIONAL.
This list will be passed directly on to function PATCH
meaning all properties supported by PATCH are valid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> – Handle to resulting patch object.  The patch object is added
directly to the current AXES object (GCA).
OPTIONAL.  Only returned if specifically requested.  If
ISEMPTY(cells), then h==-1.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Function ‘plotCellData’ is implemented directly in terms of the
low-level function PATCH.  If a separate axes is needed for the
graphical output, callers should employ function newplot prior to
calling ‘plotCellData’.</p>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Given</span> <span class="n">a</span> <span class="nb">grid</span> <span class="s">&#39;G&#39;</span> <span class="nb">and</span> <span class="n">a</span> <span class="n">reservoir</span> <span class="n">solution</span> <span class="n">structure</span> <span class="s">&#39;resSol&#39;</span> <span class="n">returned</span>
<span class="n">from</span><span class="p">,</span> <span class="nb">e</span><span class="p">.</span><span class="n">g</span><span class="p">.,</span> <span class="k">function</span> <span class="s">&#39;solveIncompFlow&#39;</span><span class="p">,</span> <span class="nb">plot</span> <span class="n">the</span> <span class="nb">cell</span> <span class="n">pressure</span> <span class="n">in</span> <span class="nb">bar</span><span class="p">:</span>

   <span class="nb">figure</span><span class="p">,</span> <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">convertTo</span><span class="p">(</span><span class="n">resSol</span><span class="p">.</span><span class="n">pressure</span><span class="p">,</span> <span class="n">barsa</span><span class="p">()));</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>, <a class="reference internal" href="core.html#core.plotting.boundaryFaces" title="core.plotting.boundaryFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">boundaryFaces</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.plotting.plotFaces_DFM">
<span class="sig-name descname"><span class="pre">plotFaces_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">faces</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.plotting.plotFaces_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Plot selection of coloured grid faces to current axes (reversed Z axis).</p>
<p>This function has been modified from the original plotGrid to account for
hybrid cells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">)</span>
 <span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
 <span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">colour</span><span class="p">)</span>
 <span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">colour</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotFaces</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>faces</strong> – Vector of face indices.  The graphical output of ‘plotFaces’
will be restricted to the subset of grid faces from ‘G’
represented by ‘faces’.</p></li>
<li><p><strong>colour</strong> – <p>Colour data specification.  Either a MATLAB ‘ColorSpec’
(i.e., an RGB triplet (1-by-3 row vector) or a short or long
colour name such as ‘r’ or ‘cyan’), or a PATCH
‘FaceVertexCData’ table suiteable for either indexed or
‘true-colour’ face colouring.  This data <em>MUST</em> be an m-by-1
column vector or an m-by-3 matrix.  We assume the following
conventions for the size of the colour data:</p>
<blockquote>
<div><ul>
<li><p>ANY(SIZE(colour,1) == [1, NUMEL(faces)])
One (constant) indexed colour for each face in ‘faces’.
This option supports ‘flat’ face shading only.  If
SIZE(colour,1) == 1, then the same colour is used for
all faces in ‘faces’.</p></li>
<li><p>SIZE(colour,1) == G.nodes.num
One (constant) indexed colour for each node in ‘faces’.
This option must be chosen in order to support
interpolated face shading.</p></li>
</ul>
</div></blockquote>
<p>OPTIONAL.  Default value: colour = ‘y’ (shading flat).</p>
</p></li>
<li><p><strong>'pn'/pv</strong> – List of other property name/value pairs.  OPTIONAL.
This list will be passed directly on to function PATCH
meaning all properties supported by PATCH are valid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> – Handle to resulting PATCH object.  The patch object is added to the
current AXES object.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Function ‘plotFaces’ is implemented directly in terms of the low-level
function PATCH.  If a separate axes is needed for the graphical output,
callers should employ function newplot prior to calling ‘plotFaces’.</p>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Plot grid with boundary faces on left side in red colour:</span>
<span class="n">G</span>     <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">faces</span> <span class="p">=</span> <span class="n">boundaryFaceIndices</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;LEFT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">[]);</span>
<span class="n">plotGrid</span> <span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;faceColor&#39;</span><span class="p">,</span> <span class="s">&#39;none&#39;</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.plotting.plotCellData" title="core.plotting.plotCellData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotCellData</span></code></a>, <a class="reference internal" href="core.html#core.plotting.plotGrid" title="core.plotting.plotGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGrid</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">shading</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.plotting.plotFractures">
<span class="sig-name descname"><span class="pre">plotFractures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">cells</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.plotting.plotFractures" title="Permalink to this definition"></a></dt>
<dd><p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotFractures</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
 <span class="n">plotFractures</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotFractures</span><span class="p">(...)</span>
</pre></div>
</div>
<p>Plot 1D fractures in a 2D grid.</p>
<p>The function plotFaces does not work satisfactory for 2D grids, thus the
present function can be used instead to visualize fractures.</p>
<p>For 3D grids, plotFaces is applied.</p>
<p>If the grid structure has a field g.faces.fracNodes, these are plotted.
If not, all faces with g.faces.tags &gt; 0 are ploted instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> – Grid data structure.</p></li>
<li><p><strong>cells</strong> – Index of hybrid cells. If empty, g.cells.hybrid is used
instead</p></li>
<li><p><strong>data</strong> – Data to be plotted. If empty, the fracture geometry is shown</p></li>
</ul>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.plotting.plotGrid_DFM">
<span class="sig-name descname"><span class="pre">plotGrid_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.plotting.plotGrid_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Plot exterior grid faces to current axes (reversed Z axis).</p>
<p>This function has been modified from the original plotGrid to account for
hybrid cells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
 <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>
 <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotGrid</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>cells</strong> – <p>Vector of cell indices defining sub grid.  The graphical
output of function ‘plotGrid’ will be restricted to the
subset of cells from ‘G’ represented by ‘cells’.</p>
<p>If unspecified, function ‘plotGrid’ will behave as if the
caller defined</p>
<blockquote>
<div><p>cells = 1 : G.cells.num</p>
</div></blockquote>
<p>meaning graphical output will be produced for all cells in
the grid model ‘G’.  If ‘cells’ is empty (i.e., if
ISEMPTY(cells)), then no graphical output will be produced.</p>
</p></li>
<li><p><strong>'pn'/pv</strong> – List of property names/property values.  OPTIONAL.
This list will be passed directly on to function PATCH
meaning all properties supported by PATCH are valid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> – Handle to resulting patch object.  The patch object is added
directly to the current AXES object (GCA).
OPTIONAL.  Only returned if specifically requested.  If
ISEMPTY(cells), then h==-1.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Function ‘plotGrid’ is implemented directly in terms of the low-level
function PATCH.  If a separate axes is needed for the graphical output,
callers should employ function newplot prior to calling ‘plotGrid’.</p>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>

<span class="c">% 1) Plot grid with yellow colour on faces (default):</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;EdgeAlpha&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c">% 2) Plot grid with no colour on faces (transparent faces):</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;FaceColor&#39;</span><span class="p">,</span> <span class="s">&#39;none&#39;</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.plotting.plotCellData" title="core.plotting.plotCellData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotCellData</span></code></a>, <a class="reference internal" href="core.html#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code>.</p>
</div>
</dd></dl>

<span class="target" id="module-dfm.msfv_dfm"></span><dl class="mat script">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#dfm.msfv_dfm.Contents" title="Permalink to this definition"></a></dt>
<dd><p>Multiscale Finite Volume Method for Discrete Fracture Matrix models (MSFV-DFM) module
The module depends on the MSFVM and the DFM module</p>
<p>Routines supporting the MSFVM-DFM module. Examples in /examples
Add module by typing MrstModule add MSFV-DFM
AUTHOR <a class="reference external" href="mailto:tor&#46;harald&#46;sandve&#37;&#52;&#48;iris&#46;no">tor<span>&#46;</span>harald<span>&#46;</span>sandve<span>&#64;</span>iris<span>&#46;</span>no</a></p>
<dl>
<dt>new files</dt><dd><p>createGridHierarchy          - Generates the fine-scale grid and the dual-coarse grid</p>
<p>/util/findClosestCell        - Find the closest cells to a given coordinate in 2D
/util/getFractureCells       - Extract cell indexes corresponding to fractures and fracture intersection</p>
<blockquote>
<div><p>with a given tag</p>
</div></blockquote>
<p>/util/makeCartFrac           - Create a net of Cartesian fractures
/util/mergeCells     - merge two cells that shares a face
/util/mergeFaces     - merge two faces that have the same neighbors
/util/mergeFractures         - merge two fracture sets
/util/removeDuplicates       - remove duplicated fractures and vertices
/private/makeCoarseDualGrid - Create the Coarse dual grid
/private/makeFineGridHybrid - Create a fine-grid constrained by fractures and the dual coarse grid</p>
<blockquote>
<div><p>The constrains are represented by hybrid cells of first kind
and their intersection with hybrid cells of second kind</p>
</div></blockquote>
<p>/private/readFractures       - Extract fracture network from files</p>
</dd>
</dl>
<p>Files modified from the MSFVM module.</p>
<blockquote>
<div><p>solveMSFV_TPFA_Incomp_DFM    - Modified to allow for hybrid cells
/util/plotDual_DFM           - Modified to plot hybrid cells
/util/removeCells_mod        - Modified to update additional face fields as tags, centroids etc.</p>
<p>partitionDualDFM          - Create the dual grid structure as used by MSFVM
partitioningByAggregation - Create primal partitioning by aggregation with node cells as seeds.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.createGridHierarchy">
<span class="sig-name descname"><span class="pre">createGridHierarchy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">coarseFractures</span></em>, <em class="sig-param"><span class="pre">fineFractures</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.createGridHierarchy" title="Permalink to this definition"></a></dt>
<dd><p>CREATEGRIDHIERARCHY Generates the fine-scale grid and the dual-coarse grid</p>
<p>SYNOPSIS
[g_dual,g_fine,box,opt] = createGridHierarchy(coarseGrids,fineFractures,varargin)</p>
<p>PARAMETERS</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>coarseFractures - a structure defining the dual coarse grid</dt><dd><p>The structure is an input into build_fractures_mod
which reads fractures drawn a openoffice file (.odp)
or given in a .mat file</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>fineFractures - a cell of structures defining the fine fractures</dt><dd><p>The structures are input into build_fractures_mod (see above)</p>
</dd>
</dl>
</li>
</ul>
<p>OPTIONAL
- load          - path to load grid (if empty nothing is loaded)
- save          - path to save grid (if empty nothing is saved)
- numElements   - number of fine-scale cells (the final number of cells</p>
<blockquote>
<div><p>are usally 10% more then this.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>apertures     - a vector with apertures. One for each tag. (if empty the</dt><dd><p>the apertures specified in the input structures are
used.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>shrinkfactor  - The width of the edge cells that are not fractures are</dt><dd><p>computed such that these edge cells have approximatly
the same size as the inner cells. In order to use a
hybrid representation of these celle their width must
be much smaller than the neighboring cells. A
shrinkfactor can be used to adjust the width of these
cells.</p>
</dd>
</dl>
</li>
</ul>
<p>NB Varargin is pasted directly into subrutines, and options can thus be
pasted directly to its subrutines.</p>
</div></blockquote>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.partitionDualDFM">
<span class="sig-name descname"><span class="pre">partitionDualDFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.partitionDualDFM" title="Permalink to this definition"></a></dt>
<dd><p>Create the dual grid structure as used by MSFVM</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">dual</span> <span class="p">=</span> <span class="n">partitionDualDFM</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>g</strong> – mrst grid structure with additional fields as created
by createGridHierarchy.m</p>
</dd>
</dl>
<dl class="simple">
<dt>OUTPUT:</dt><dd><p>dual - the dual grid structure used by MSFVM</p>
</dd>
</dl>
<p>Copyright 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.partitioningByAggregation">
<span class="sig-name descname"><span class="pre">partitioningByAggregation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">dual</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.partitioningByAggregation" title="Permalink to this definition"></a></dt>
<dd><p>Create primal partitioning by aggregation with node cells as seeds.</p>
<p>SYNOPSIS:
p = partitioningByAggregation(g_fine,dual)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> – Mrst grid structure</p></li>
<li><p><strong>dual</strong> – dual grid as used in the MSFVM module</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>OUTPUT:</dt><dd><p>p - The partition vector</p>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.solveMSFV_TPFA_Incomp_DFM">
<span class="sig-name descname"><span class="pre">solveMSFV_TPFA_Incomp_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">CG</span></em>, <em class="sig-param"><span class="pre">T</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.solveMSFV_TPFA_Incomp_DFM" title="Permalink to this definition"></a></dt>
<dd><p>SOLVEMSFV_TPFA_INCOMP_DFM Modified to allow for hybrid cells
finite volume method.</p>
<p>THIS FILE IS MODIFIED FROM THE ORIGINAL solveMSFV_TPFA_Incomp.m
to allow for hybrid cells and cell to cell connections</p>
<dl class="simple">
<dt>The change are:</dt><dd><ul class="simple">
<li><p>optional input c2cTrans is added to allow for c2c connections
This is used as an input in incompTPFA_DFM</p></li>
<li><p>incompTPFA_DFM is called instead of incompTPFA to allow for
hybrid cells</p></li>
<li><p>a bug in the flux reconstruction is fixed</p></li>
</ul>
</dd>
</dl>
<p>Portions Copyright 2013 IRIS AS</p>
<p>SYNOPSIS:
state = solveMSFV_TPFA_Incomp(state, G, CG, T, fluid)
state = solveMSFV_TPFA_Incomp(state, G, CG, T, fluid, ‘pn1’, pv1, …)</p>
<p>DESCRIPTION:
This function uses a operator formulation of the multiscale finite volume
method to solve a single phase flow problem. The method works on fully
unstructured grids, as long as the coarse grids are successfully created.</p>
<dl>
<dt>REQUIRED PARAMTERS:</dt><dd><dl class="simple">
<dt>state   - reservoir and well solution structure as defined by</dt><dd><p>‘initResSol’, ‘initWellSol’ or a previous call to ‘incompTPFA’.</p>
</dd>
<dt>G, T   - Grid and half-transmissibilities as computed by the function</dt><dd><p>‘computeTrans’.</p>
</dd>
</dl>
<p>fluid  - Fluid object as defined by function ‘initSimpleFluid’.</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul>
<li><p><strong>wells</strong> – Well structure as defined by function ‘addWell’.  May be empty
(i.e., W = struct([])) which is interpreted as a model without
any wells.</p></li>
<li><p><strong>bc</strong> – Boundary condition structure as defined by function ‘addBC’.
This structure accounts for all external boundary conditions to
the reservoir flow.  May be empty (i.e., bc = struct([])) which
is interpreted as all external no-flow (homogeneous Neumann)
conditions.</p></li>
<li><p><strong>src</strong> – Explicit source contributions as defined by function
‘addSource’.  May be empty (i.e., src = struct([])) which is
interpreted as a reservoir model without explicit sources.</p></li>
<li><p><strong>LinSolve</strong> – Handle to linear system solver software which will be
used to solve the linear equation sets.
Assumed to support the syntax</p>
<blockquote>
<div><p>x = LinSolve(A, b)</p>
</div></blockquote>
<p>in order to solve a system Ax=b of linear equations.
Should be capable of solving for a matrix rhs.
Default value: LinSolve = &#64;mldivide (backslash).</p>
</li>
<li><p><strong>Dual</strong> – A dual grid. Will be created if not already defined.</p></li>
<li><p><strong>Verbose</strong> – Controls the amount of output. Default value from
mrstVerbose global</p></li>
<li><p><strong>Reconstruct</strong> – Determines if a conservative flux field will be
constructed after initial pressure solution.</p></li>
<li><p><strong>Discretization</strong> – Will select the type of stencil used for approximating
the pressure equations. Currently only TPFA.</p></li>
<li><p><strong>Iterations</strong> – The number of iterations performed. With subiterations
and a smoother, the total will be subiter*iter.</p></li>
<li><p><strong>Subiterations</strong> – When using smoothers, this gives the number of
smoothing steps.</p></li>
<li><p><strong>Tolerance</strong> – Termination criterion for the iterative variants.</p></li>
<li><p><strong>CoarseDims</strong> – For logical partitioning scheme, the coarse dimensions
must be specified.</p></li>
<li><p><strong>Restart</strong> – The number of steps before GMRES restarts.</p></li>
<li><p><strong>Iterator</strong> – GMRES, DAS or DMS. Selects the iteration type.</p></li>
<li><p><strong>Omega</strong> – Relaxation paramter for the smoothers</p></li>
<li><p><strong>Scheme</strong> – The scheme used for partitioning the dual grid. Only
used when no dual grid is supplied.</p></li>
<li><p><strong>DoSolve</strong> – Will the linear systems be solved or just outputted?</p></li>
<li><p><strong>Speedup</strong> – Alternative formulation of the method leads to great
speed improvements in 3D, but may have different error
values and is in general more sensitive to grid errors</p></li>
<li><p><strong>Update</strong> – If a state from a previous multiscale iteration is
provided, should operators be regenerated?</p></li>
<li><p><strong>DynamicUpdate</strong> – Update pressure basis functions adaptively. Requires
dfs search implemented as components</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – Update reservoir and well solution structure with new values
for the fields:</p>
<blockquote>
<div><ul>
<li><dl class="simple">
<dt>pressure – Pressure values for all cells in the</dt><dd><p>discretised reservoir model, ‘G’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>pressure_reconstructed – Pressure values which gives</dt><dd><p>conservative flux</p>
</dd>
</dl>
</li>
<li><p>pressurecoarse – Coarse pressure used for solution</p></li>
<li><dl class="simple">
<dt>facePressure –</dt><dd><p>Pressure values for all interfaces in the
discretised reservoir model, ‘G’.</p>
</dd>
</dl>
</li>
<li><p>time     – Timing values for benchmarking</p></li>
<li><dl class="simple">
<dt>flux     – Flux across global interfaces corresponding to</dt><dd><p>the rows of ‘G.faces.neighbors’.</p>
</dd>
</dl>
</li>
<li><p>M_ee,A_ii– Relevant matrices for debugging</p></li>
<li><p>DG       – Dual grid used</p></li>
<li><dl class="simple">
<dt>A        – System matrix.  Only returned if specifically</dt><dd><p>requested by setting option ‘MatrixOutput’.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>wellSol  – Well solution structure array, one element for</dt><dd><p>each well in the model, with new values for
the fields:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>flux     – Perforation fluxes through all</dt><dd><p>perforations for corresponding
well.  The fluxes are
interpreted as injection
fluxes, meaning positive
values correspond to injection
into reservoir while negative
values mean
production/extraction out of
reservoir.</p>
</dd>
</dl>
</li>
<li><p>pressure – Well bottom-hole pressure.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>c2cTrans  – cell to cell transmissibilities see</dt><dd><p>computeHybridTrans.m, used as input in
incompTPFA_DFM</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This solver is based on the core MRST function incompTPFA.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="incomp.html#incomp.incompTPFA" title="incomp.incompTPFA"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">incompTPFA</span></code></a>.</p>
</div>
</dd></dl>

<span class="target" id="module-dfm.msfv_dfm.util"></span><dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.util.findClosestCell">
<span class="sig-name descname"><span class="pre">findClosestCell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">y</span></em>, <em class="sig-param"><span class="pre">sub</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.util.findClosestCell" title="Permalink to this definition"></a></dt>
<dd><p>Find the cell with center closest to the point (x,y)</p>
<p>SYNOPSIS
pick = findClosestCell(g,x,y,sub)</p>
<dl>
<dt>PARAMETERS</dt><dd><p>g - mrst grid structure
x,y - x and y coordinates</p>
<p>OPTIONAL
sub - a subset of the cells to search within</p>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.util.getFractureCells">
<span class="sig-name descname"><span class="pre">getFractureCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">tag</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.util.getFractureCells" title="Permalink to this definition"></a></dt>
<dd><p>Return the fracture cells related to a given tag</p>
<p>SYNOPSIS:
[fcells,ncells] = getFractureCells(g,tag)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> – MRST grid structure</p></li>
<li><p><strong>tag</strong> – a list of tags</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>OUTPUT:</dt><dd><p>fcells - fracture cells
ncells - cells in the intersection of the fractures</p>
</dd>
</dl>
<p>Copyright 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.util.makeCartFrac">
<span class="sig-name descname"><span class="pre">makeCartFrac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">n</span></em>, <em class="sig-param"><span class="pre">ftag</span></em>, <em class="sig-param"><span class="pre">box</span></em>, <em class="sig-param"><span class="pre">filename</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.util.makeCartFrac" title="Permalink to this definition"></a></dt>
<dd><p>saves a Cartesian grid in filename</p>
<dl class="simple">
<dt>SYNOPSIS</dt><dd><p>makeCartFrac(n,ftag,box,filename)</p>
</dd>
</dl>
<p>PARAMETERS
n:    a matrix containing the number of internal points for each set of</p>
<blockquote>
<div><p>Cartesian grid i.e. different tags can be used for the different
sets</p>
</div></blockquote>
<p>ftag: tag numbers must have the size of the rows of n.
box:  bounding box
filename: file name where the vertices and edges are stored</p>
<p>Copyright 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.util.mergeCells">
<span class="sig-name descname"><span class="pre">mergeCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">remove_faces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.util.mergeCells" title="Permalink to this definition"></a></dt>
<dd><p>merge two cells separated by the first face in remove_faces
return the updated remove_faces list as well as a grid
with one less number of cells.</p>
<dl>
<dt>SYNOPSIS</dt><dd><p>[g,remove_faces] = mergeCells(g,remove_faces)</p>
</dd>
<dt>PARAMETERS</dt><dd><p>g - mrst grid structure
remove_faces - a list of faces to be removed</p>
<blockquote>
<div><p>NB Only the first face is removed</p>
</div></blockquote>
</dd>
<dt>OUTPUT</dt><dd><p>g - mrst grid structure with one less cell
remove-faces - updated list of faces (- the removed faces)</p>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.util.mergeFaces">
<span class="sig-name descname"><span class="pre">mergeFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.util.mergeFaces" title="Permalink to this definition"></a></dt>
<dd><p>merge faces that has the same pair of neighbors
for standard grid this do not happen
but it may occur when cells is merged using mergeCells.m</p>
<p>SYNAPSIS:
g = mergeFaces(g)</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>g - mrst grid structure</p>
</dd>
<dt>OUTPUT</dt><dd><dl class="simple">
<dt>g - mrst grid structure where faces with the same pair</dt><dd><p>of neighbors are removed</p>
</dd>
</dl>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.util.mergeFractures">
<span class="sig-name descname"><span class="pre">mergeFractures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">vertices</span></em>, <em class="sig-param"><span class="pre">fractures</span></em>, <em class="sig-param"><span class="pre">vert_new</span></em>, <em class="sig-param"><span class="pre">frac_new</span></em>, <em class="sig-param"><span class="pre">box</span></em>, <em class="sig-param"><span class="pre">precision</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.util.mergeFractures" title="Permalink to this definition"></a></dt>
<dd><p>merge two set of fractures. To avoid silver cells
new points close to old fractures are projected onto the old fractures
if both endpoint of a fracture is snapped to the same old fracture
it is removed to avoid duplicated fractures.</p>
<p>SYNAPSES
[vertices,fractures] = mergeFractures(vertices,fractures,vert_new,frac_new,box,precision)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> – original set of vertices</p></li>
<li><p><strong>fractures</strong> – original set of fractures</p></li>
<li><p><strong>vert_new</strong> – new set of vertices</p></li>
<li><p><strong>frac_new</strong> – new set of fractures</p></li>
<li><p><strong>box</strong> – bounding box of the domian</p></li>
<li><p><strong>presicion</strong> – the releative presicion of the grid</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>OUTPUT:</dt><dd><p>vertices  - the merged vertices
fractures - the merged fractures</p>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.util.plotDual_DFM">
<span class="sig-name descname"><span class="pre">plotDual_DFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">dual</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.util.plotDual_DFM" title="Permalink to this definition"></a></dt>
<dd><p>Plot an implicitly defined dual grid for the multiscale finite volume method</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">plotDual_DFM</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">dual</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure</p></li>
<li><p><strong>dual</strong> – <p>Dual grid as defined by for example partitionUIdual.</p>
<p>Modified from plotDual.m to account for hybrid cells</p>
<p>Copyright 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.util.removeCells_mod">
<span class="sig-name descname"><span class="pre">removeCells_mod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">cells</span></em>, <em class="sig-param"><span class="pre">faces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.util.removeCells_mod" title="Permalink to this definition"></a></dt>
<dd><p>Remove cells from grid and renumber cells, faces and nodes.</p>
<p>THIS FILE IS MODIFIED FROM THE ORIGINAL removeCells.m
The following field are updated from the face field
- tags, tags2, areas, normals, fracNodes, centroids
Portions Copyright 2011-2012 University of Bergen.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">removeCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">);</span>
<span class="p">[</span><span class="n">G</span><span class="p">,</span> <span class="n">cellmap</span><span class="p">,</span> <span class="n">facemap</span><span class="p">,</span> <span class="n">nodemap</span><span class="p">]</span> <span class="p">=</span> <span class="n">removeCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Valid grid definition</p></li>
<li><p><strong>cells</strong> – list of cell numbers to be removed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Updated grid definition where cells have been removed.
In addition, any unreferenced faces or nodes are
subsequently removed.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">removeCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">));</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span><span class="nb">view</span><span class="p">(</span><span class="o">-</span><span class="mi">35</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span><span class="n">camlight</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The process of removing cells is irreversible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">deactivateZeroPoro</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="dfm.msfv_dfm.util.removeDuplicates">
<span class="sig-name descname"><span class="pre">removeDuplicates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">vertices</span></em>, <em class="sig-param"><span class="pre">edges</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dfm.msfv_dfm.util.removeDuplicates" title="Permalink to this definition"></a></dt>
<dd><p>Remove duplicated edges and vertices
The first tag is kept
TODO: keep track of the lost tags</p>
<p>SYNAPSES
[vertices,edges] = removeDuplicates(vertices,edges)</p>
<dl class="simple">
<dt>PARAMETERS</dt><dd><p>vertices - original vertices list
edges - original edge list</p>
</dd>
<dt>OUTPUT</dt><dd><p>vertices - vertices list without duplicates
edges - edge list without duplicates</p>
</dd>
</dl>
<p>Copyright 2011-2012 University of Bergen, 2013 IRIS AS</p>
<p>This file is licensed under the GNU General Public License v3.0.</p>
</dd></dl>

<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h2>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="deckformat.html" class="btn btn-neutral float-left" title="deckformat: Reading and conversion of input decks" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="dg.html" class="btn btn-neutral float-right" title="dg: Discontinous Galerkin discretizations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, SINTEF Digital.
      <span class="lastupdated">Last updated on Sep 23, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>