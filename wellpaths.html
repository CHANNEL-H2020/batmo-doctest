<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wellpaths: Generation of wells using general curves &mdash; The Matlab Reservoir Simulation Toolbox 2019b documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="vemmech: Mechanics for general grids using the virtual element method" href="vemmech.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> The Matlab Reservoir Simulation Toolbox
            <img src="_static/mrstlogo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2019b
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="core.html">Core functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-core.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code>: Automatic Differentiation Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-props.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-props</span></code>: PVT, fluid models and other properties for the AD-solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-blackoil.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-blackoil</span></code>: Black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-eor.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-eor</span></code>: Enhanced oil recovery solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-mechanics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-mechanics</span></code>: Coupled flow and mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="adjoint.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">adjoint</span></code>: Two-phase, incompressible adjoint solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="agglom.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">agglom</span></code>: Flow and property-based coarse-grid generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="blackoil-sequential.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">blackoil-sequential</span></code>: Sequential implicit black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="book.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">book</span></code>: Book examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="coarsegrid.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">coarsegrid</span></code>: Generation of coarse grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="compositional.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">compositional</span></code>: Equation-of-state compositional solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="co2lab.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">co2lab</span></code>: Numerical CO<sub>2</sub> laboratory</a></li>
<li class="toctree-l1"><a class="reference internal" href="deckformat.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">deckformat</span></code>: Reading and conversion of input decks</a></li>
<li class="toctree-l1"><a class="reference internal" href="dfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dfm</span></code>: Discrete fracture matrix implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="dg.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dg</span></code>: Discontinous Galerkin discretizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">diagnostics</span></code>: Flow diagnostics functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="dual_porosity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dual-porosity</span></code>: Dual porosity/permeability model for fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="fvbiot.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fvbiot</span></code>: Consistent finite-volume discretizations for poroelasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="geochemistry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">geochemistry</span></code>: Surface geochemistry</a></li>
<li class="toctree-l1"><a class="reference internal" href="heterogeneity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">heterogeneity</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="hfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hfm</span></code>: Hierarchical and embedded fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="incomp.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">incomp</span></code>: Solvers for incompressible flow and transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="libgeometry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">libgeometry</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="linearsolvers.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">linearsolvers</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="matlab_bgl.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">matlab_bgl</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="mimetic.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mimetic</span></code>: Mimetic solvers for pressure problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mpfa</span></code>: Multi-point flux approximation solvers for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst_api.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst_api</span></code>: API for writing C/C++ for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst-gui.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst-gui</span></code>: Graphical user-interfaces for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="msfvm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msfvm</span></code>: Multiscale Finite-Volume method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msmfem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msmfem</span></code>: Multiscale Mixed Finite-Element method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msrsb.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msrsb</span></code>: Multiscale Restriction-Smoothed Basis method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="nwm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nwm</span></code>: Near Wellbore Modelling</a></li>
<li class="toctree-l1"><a class="reference internal" href="opm_gridprocessing.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">opm_gridprocessing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">optimization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="re-mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">re-mpfa</span></code>: Richards’ equation with multi-point flux</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvent.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solvent</span></code>: Solvent solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="spe10.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">spe10</span></code>: Access to the SPE10 benchmark case</a></li>
<li class="toctree-l1"><a class="reference internal" href="steady-state.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">steady-state</span></code> Steady-state upscaling of functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamlines.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">streamlines</span></code>: Compute streamlines</a></li>
<li class="toctree-l1"><a class="reference internal" href="triangle.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">triangle</span></code>: Triangular grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="upscaling.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaling</span></code>: Upscaling of reservoir problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="vem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vem</span></code>: Virtual element method on general grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="vemmech.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vemmech</span></code>: Mechanics for general grids using the virtual element method</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">wellpaths</span></code>: Generation of wells using general curves</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Matlab Reservoir Simulation Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><code class="xref mat mat-func docutils literal notranslate"><span class="pre">wellpaths</span></code>: Generation of wells using general curves</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/wellpaths.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="wellpaths-generation-of-wells-using-general-curves">
<h1><code class="xref mat mat-func docutils literal notranslate"><span class="pre">wellpaths</span></code>: Generation of wells using general curves<a class="headerlink" href="#wellpaths-generation-of-wells-using-general-curves" title="Permalink to this headline"></a></h1>
<p>Functionality for defining wells following curvilinear trajectories. By defining each well trajectory as a series of points, this module can combine multiple trajectories and determine which cells are penetrated by the well path. The trajectories can be interpolated using any of Matlab’s built-in routines (splines, piecewise linear functions, etc).</p>
<span class="target" id="module-wellpaths.utils"></span><dl class="mat script">
<dt class="sig sig-object mat" id="wellpaths.utils.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#wellpaths.utils.Contents" title="Permalink to this definition"></a></dt>
<dd><p>UTILS</p>
<dl class="simple">
<dt>Files</dt><dd><p>combineWellPaths   - Combine multiple simple paths into a full tree
findWellPathCells  - Convert well path to the intersected cells
getWellFromPath    - Convert well path to MRST well.
makeSingleWellpath - Create well path from points (and optional connectivity and active flag)
plotWellPath       - Plot a well path
refineSpline       - Refine a curve to higher resolution using spline interpolation</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="wellpaths.utils.addWellFromTrajectory">
<span class="sig-name descname"><span class="pre">addWellFromTrajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">traj</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#wellpaths.utils.addWellFromTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>This function adds a well based on a piecewise linear trajectory traj.
All function arguments are the same as for addWell except for in place of
cellInx, there should be a nx3 matrix of trajectory coordinates.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="wellpaths.utils.combineWellPaths">
<span class="sig-name descname"><span class="pre">combineWellPaths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">wellpaths</span></em><span class="sig-paren">)</span><a class="headerlink" href="#wellpaths.utils.combineWellPaths" title="Permalink to this definition"></a></dt>
<dd><p>Combine multiple simple paths into a full tree</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wellpath</span> <span class="p">=</span> <span class="n">combineWellPaths</span><span class="p">({</span><span class="n">wp1</span><span class="p">,</span> <span class="n">wp2</span><span class="p">,</span> <span class="n">wp3</span><span class="p">});</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Given multiple simple well paths this function assembles a single well
tree from the inputs. For this to work we assume that:</p>
<blockquote>
<div><ul class="simple">
<li><p>The paths are ordered by depth in the tree. This is not the</p></li>
</ul>
<p>vertical depth, but rather that a path will always be connected to
one of the curves preceding it in the list.
- Paths (aside from the first one) always start with a point that
also exists in one of the preceding paths. This is used to connect
the paths.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wellpaths</strong> – Cell array of simple well paths to be assembled together. A
simple well path is assumed to contain a single list of
points (i.e. it will only represent a line segment).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wellpath</strong> – Composite wellpath made from the simple wellpaths. The
topology will be tree-like in nature.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#wellpaths.utils.makeSingleWellpath" title="wellpaths.utils.makeSingleWellpath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeSingleWellpath</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="wellpaths.utils.computeTraversedCells">
<span class="sig-name descname"><span class="pre">computeTraversedCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">traj</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#wellpaths.utils.computeTraversedCells" title="Permalink to this definition"></a></dt>
<dd><p>Compute intersection details between grid and piecwise linear trajectory</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="p">=</span> <span class="n">computeTraversedCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">traj</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">)</span>
</pre></div>
</div>
<p>DESCRIPTION:</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure with geometry and preferably ‘bbox’-field included
for G.faces (see addBoundingBoxFields)</p></li>
<li><p><strong>traj</strong> – piecewise trajectory given as list of points (nx3)</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>faces</strong> – Indices to subset of G.faces. Default is (1:G.faces.num)’</p></li>
<li><p><strong>tol</strong> – Relative tolerance for intersection testing. Should be &gt; 0 to
avoid effect of round-off.</p></li>
<li><p><strong>exteriorFaceCorrection</strong> – if true, output T.weight is modified to account for
exterior faces. This is done by computing the fracions of the
area-components normal to T.vec open to flow.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>T</strong> – struct containing details of all traversed grid cells:</dt><dd><p>‘cell’   - cell indices
‘vec’    - vector decribing direction and length of cell-segment
‘weight’ - weight of cell-segment, only ~=1 if segment is</p>
<blockquote>
<div><p>shared by more than one cell</p>
</div></blockquote>
</dd>
</dl>
<p>extra   - unprocessed output for debugging purposes etc</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="wellpaths.utils.findWellPathCells">
<span class="sig-name descname"><span class="pre">findWellPathCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">wellpath</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#wellpaths.utils.findWellPathCells" title="Permalink to this definition"></a></dt>
<dd><p>Convert well path to the intersected cells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">cells</span> <span class="p">=</span> <span class="n">findWellPaths</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">wellpath</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>By creating a triangulation and mapping perforations to the closest
cells, this routine realizes the continuous well path into discrete
cells, making it possible to build simulation wells from it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – The grid structure we want to realize the wells on.</p></li>
<li><p><strong>wellpath</strong> – Well path. See “makeSingleWellpath” for spec.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>interpType</strong> – The type of interpolation used to extend the curve between
points. Supports the same types as MATLAB builtin interp1.
Default: Spline.</p></li>
<li><p><strong>triangulation</strong> – The triangulation (typically from delaunayTriangulation)
used to determine proximity in the grid.</p></li>
<li><p><strong>refinement</strong> – Refinement number used to further refine the well curve
before computing which cells it intersect. Default: 100.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cells</strong> – The list of cells the well intersects.</p></li>
<li><p><strong>segment</strong> – Segment indicator for each cell, indicating which wellpath
segment produced that specific completion. If multiple
choices are possible, the segment which comes first in
wellpath.points is used.</p></li>
<li><p><strong>ptsind</strong> – Point indicator, indicating which point in the segment was
the closest to a given cell.</p></li>
<li><p><strong>DT</strong> – Triangulation used to produce the results.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#wellpaths.utils.makeSingleWellpath" title="wellpaths.utils.makeSingleWellpath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeSingleWellpath</span></code></a>, <a class="reference internal" href="#wellpaths.utils.combineWellPaths" title="wellpaths.utils.combineWellPaths"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">combineWellPaths</span></code></a>, <a class="reference internal" href="#wellpaths.utils.getWellFromPath" title="wellpaths.utils.getWellFromPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getWellFromPath</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="wellpaths.utils.getWellFromPath">
<span class="sig-name descname"><span class="pre">getWellFromPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W0</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">wellpath</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#wellpaths.utils.getWellFromPath" title="Permalink to this definition"></a></dt>
<dd><p>Convert well path to MRST well.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="p">=</span> <span class="n">getWellFromPath</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">wellpath</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This routine converts a well path (representing curves and points) into
a well (represented by cells and connectivity).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W0</strong> – Well array to be extended with the new well.</p></li>
<li><p><strong>G</strong> – The grid the well is to be placed in.</p></li>
<li><p><strong>rock</strong> – Rock structure which defines permeability and porosity.</p></li>
<li><p><strong>wellpath</strong> – <dl class="simple">
<dt>Well path as procued by makeSingleWellPath or</dt><dd><p>combineWellPaths.</p>
</dd>
</dl>
<p>OPTIONAL PARAMETERS:</p>
<blockquote>
<div><p>This function calls addWell. Any keyword arguments are
passed onto addWell.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>W</strong> – Updated wells</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently no special effort is made to ensure correct well indices for
the well.</p>
</div>
<p>SEE ALSO:</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="wellpaths.utils.makeSingleWellpath">
<span class="sig-name descname"><span class="pre">makeSingleWellpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pts</span></em>, <em class="sig-param"><span class="pre">conn</span></em>, <em class="sig-param"><span class="pre">active</span></em><span class="sig-paren">)</span><a class="headerlink" href="#wellpaths.utils.makeSingleWellpath" title="Permalink to this definition"></a></dt>
<dd><p>Create well path from points (and optional connectivity and active flag)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wellpath</span> <span class="p">=</span> <span class="n">makeSingleWellpath</span><span class="p">(</span><span class="n">pts</span><span class="p">);</span>
<span class="n">wellpath</span> <span class="p">=</span> <span class="n">makeSingleWellpath</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
<span class="n">wellpath</span> <span class="p">=</span> <span class="n">makeSingleWellpath</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Create a well path from lists of points. The resulting structure will
be a single struct with fields:</p>
<ul>
<li><dl class="simple">
<dt>points:</dt><dd><p>Cell array, each consisting of N x Dim arrays of n points.
Each entry contains the points for one segment that are
assumed to be connected as a line according to their
ordering. The first entry is assumed to be closest to the
starting point of the well (closest here means along the well
bore).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>connectivity:</dt><dd><p>Array of size M x 2 where M is the number of entries in the
.points cell array. If entry number 5 of connectivity is [2 7]
it means that segment number 5 is connected to segment 2, at
point number 7 of segment 2’s internal ordering. In effect,
segment 5 branches off from segment 2 from the coordinate
.points{2}(7, :).</p>
</dd>
</dl>
</li>
<li><dl>
<dt>active:</dt><dd><p>Cell array, containing active flags for the segments between
points. If points{i} contains N x dim entries, active{i}
should contain (N-1) x 1 entries, indicating if the
subsegments are active.</p>
<p>If points is of size 6 x 3 and active looks like this:
[1; % 1 -&gt; 2</p>
<blockquote>
<div><p>1; % 2 -&gt; 3
0; % 3 -&gt; 4
1; % 4 -&gt; 5
1] % 5 -&gt; 6</p>
</div></blockquote>
<p>it means that the part of the segment will be disabled from
point 3 to point 4.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pts</strong> – <dl class="simple">
<dt>Maps directly to points (see above). If pts is a numeric</dt><dd><p>array, it will be interpreted as a cell array with a single
entry.</p>
</dd>
</dl>
<p>connectivity - Maps directly into connectivity.</p>
<p>active       - Maps directly into active.</p>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wellpath</strong> – Wellpath suitable for plotting or producing well
completions.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#wellpaths.utils.plotWellPath" title="wellpaths.utils.plotWellPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotWellPath</span></code></a>, <a class="reference internal" href="#wellpaths.utils.getWellFromPath" title="wellpaths.utils.getWellFromPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getWellFromPath</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="wellpaths.utils.plotWellPath">
<span class="sig-name descname"><span class="pre">plotWellPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">wellpaths</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#wellpaths.utils.plotWellPath" title="Permalink to this definition"></a></dt>
<dd><p>Plot a well path</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">plotWellPath</span><span class="p">(</span><span class="n">wellpath</span><span class="p">)</span>
<span class="n">h</span> <span class="p">=</span> <span class="n">plotWellPath</span><span class="p">(</span><span class="n">wellpath</span><span class="p">,</span> <span class="s">&#39;color&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Plots a given well path, using colors and showing control points along
the curve.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wellpath</strong> – Well path to be plotted. See makeSingleWellpath.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>interpType</strong> – Interpolation type used. Same possible values as for
MATLAB builtin interp1. Default: Spline.</p></li>
<li><p><strong>LineWidth</strong> – Line width of curve used to draw wellpath segments.</p></li>
<li><p><strong>MarkerColor</strong> – Used to colorize the control points.</p></li>
<li><p><strong>Color</strong> – Color of the line segments themselves.</p></li>
<li><p><strong>Refinement</strong> – The path is refined using interpolation to produce nice
curves. Entering a positive number here will refine the
curve by a number of points. Interpreted as a
multiplicative factor.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Two-column array of handles. The first column contains
handles for the line segments and the second for the
control point markers.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#wellpaths.utils.makeSingleWellpath" title="wellpaths.utils.makeSingleWellpath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeSingleWellpath</span></code></a>, <a class="reference internal" href="#wellpaths.utils.findWellPathCells" title="wellpaths.utils.findWellPathCells"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">findWellPathCells</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="wellpaths.utils.refineSpline">
<span class="sig-name descname"><span class="pre">refineSpline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">points</span></em>, <em class="sig-param"><span class="pre">n_refine</span></em>, <em class="sig-param"><span class="pre">interpType</span></em><span class="sig-paren">)</span><a class="headerlink" href="#wellpaths.utils.refineSpline" title="Permalink to this definition"></a></dt>
<dd><p>Refine a curve to higher resolution using spline interpolation</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">pts</span> <span class="p">=</span> <span class="n">refineSpline</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;spline&#39;</span><span class="p">);</span>
<span class="n">pts</span> <span class="p">=</span> <span class="n">refineSpline</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Refine a given curve given as a array of points into</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> – A npts x dim array of points giving the curve to be
refined. Implicitly assumed to be ordered.</p></li>
<li><p><strong>n_refine</strong> – The refinement factor. If the original entries in points
contained n points, the output will have n_refine*n total
points.</p></li>
<li><p><strong>interpType</strong> – Type of interpolation. Supports the same values as the
fourth argument to MATLABs interp1 function. If omitted,
it defaults to ‘spline’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>pts</strong> – Refined points.</p></li>
<li><p><strong>v</strong> – Parametrization of the new points. Continuous values from
1 to npts indicating how far along interpolated values are
on the original trajectory.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h2>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="vemmech.html" class="btn btn-neutral float-left" title="vemmech: Mechanics for general grids using the virtual element method" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, SINTEF Digital.
      <span class="lastupdated">Last updated on Sep 23, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>