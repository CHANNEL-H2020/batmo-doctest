<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ad-core: Automatic Differentiation Core &mdash; The Matlab Reservoir Simulation Toolbox 2019b documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ad-props: PVT, fluid models and other properties for the AD-solvers" href="ad-props.html" />
    <link rel="prev" title="Core functionality" href="core.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> The Matlab Reservoir Simulation Toolbox
            <img src="_static/mrstlogo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2019b
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="core.html">Core functionality</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code>: Automatic Differentiation Core</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#models">Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-ad_core.models">Base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ad_core.models.facilities">Facility and wells</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-ad_core.simulators">Simulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ad_core.solvers">Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ad_core.timesteps">Time-step selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ad_core.upscale">Model upscaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ad_core.plotting">Plotting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ad_core.backends">Automatic differentation backends</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ad_core.utils">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ad-props.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-props</span></code>: PVT, fluid models and other properties for the AD-solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-blackoil.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-blackoil</span></code>: Black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-eor.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-eor</span></code>: Enhanced oil recovery solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-mechanics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-mechanics</span></code>: Coupled flow and mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="adjoint.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">adjoint</span></code>: Two-phase, incompressible adjoint solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="agglom.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">agglom</span></code>: Flow and property-based coarse-grid generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="blackoil-sequential.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">blackoil-sequential</span></code>: Sequential implicit black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="book.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">book</span></code>: Book examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="coarsegrid.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">coarsegrid</span></code>: Generation of coarse grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="compositional.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">compositional</span></code>: Equation-of-state compositional solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="co2lab.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">co2lab</span></code>: Numerical CO<sub>2</sub> laboratory</a></li>
<li class="toctree-l1"><a class="reference internal" href="deckformat.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">deckformat</span></code>: Reading and conversion of input decks</a></li>
<li class="toctree-l1"><a class="reference internal" href="dfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dfm</span></code>: Discrete fracture matrix implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="dg.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dg</span></code>: Discontinous Galerkin discretizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">diagnostics</span></code>: Flow diagnostics functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="dual_porosity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dual-porosity</span></code>: Dual porosity/permeability model for fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="fvbiot.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fvbiot</span></code>: Consistent finite-volume discretizations for poroelasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="geochemistry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">geochemistry</span></code>: Surface geochemistry</a></li>
<li class="toctree-l1"><a class="reference internal" href="heterogeneity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">heterogeneity</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="hfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hfm</span></code>: Hierarchical and embedded fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="incomp.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">incomp</span></code>: Solvers for incompressible flow and transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="libgeometry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">libgeometry</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="linearsolvers.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">linearsolvers</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="matlab_bgl.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">matlab_bgl</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="mimetic.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mimetic</span></code>: Mimetic solvers for pressure problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mpfa</span></code>: Multi-point flux approximation solvers for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst_api.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst_api</span></code>: API for writing C/C++ for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst-gui.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst-gui</span></code>: Graphical user-interfaces for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="msfvm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msfvm</span></code>: Multiscale Finite-Volume method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msmfem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msmfem</span></code>: Multiscale Mixed Finite-Element method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msrsb.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msrsb</span></code>: Multiscale Restriction-Smoothed Basis method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="nwm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nwm</span></code>: Near Wellbore Modelling</a></li>
<li class="toctree-l1"><a class="reference internal" href="opm_gridprocessing.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">opm_gridprocessing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">optimization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="re-mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">re-mpfa</span></code>: Richards’ equation with multi-point flux</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvent.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solvent</span></code>: Solvent solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="spe10.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">spe10</span></code>: Access to the SPE10 benchmark case</a></li>
<li class="toctree-l1"><a class="reference internal" href="steady-state.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">steady-state</span></code> Steady-state upscaling of functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamlines.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">streamlines</span></code>: Compute streamlines</a></li>
<li class="toctree-l1"><a class="reference internal" href="triangle.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">triangle</span></code>: Triangular grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="upscaling.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaling</span></code>: Upscaling of reservoir problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="vem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vem</span></code>: Virtual element method on general grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="vemmech.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vemmech</span></code>: Mechanics for general grids using the virtual element method</a></li>
<li class="toctree-l1"><a class="reference internal" href="wellpaths.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">wellpaths</span></code>: Generation of wells using general curves</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Matlab Reservoir Simulation Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code>: Automatic Differentiation Core</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/ad-core.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="ad-core-automatic-differentiation-core">
<h1><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code>: Automatic Differentiation Core<a class="headerlink" href="#ad-core-automatic-differentiation-core" title="Permalink to this headline"></a></h1>
<p>Object-oriented framework for solvers based on automatic differentiation (MRST AD-OO). This module by itself does not contain any complete simulators, but rather implements the common framework used for many other modules. For instance, the ad-blackoil module contains models for black-oil equations that inherit all basic features from ad-core, the ad-eor module inherits models from ad-blackoil, and so on.</p>
<p>Overview of the solvers:</p>
<div class="figure align-default">
<a class="reference internal image-reference" href="_images/relations.png"><img alt="_images/relations.png" src="_images/relations.png" style="width: 822.5px; height: 359.0px;" /></a>
</div>
<div class="section" id="models">
<h2>Models<a class="headerlink" href="#models" title="Permalink to this headline"></a></h2>
<div class="section" id="module-ad_core.models">
<span id="base-classes"></span><h3>Base classes<a class="headerlink" href="#module-ad_core.models" title="Permalink to this headline"></a></h3>
<dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.models.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.models.Contents" title="Permalink to this definition"></a></dt>
<dd><p>MODELS</p>
<dl class="simple">
<dt>Files</dt><dd><p>GenericReservoirModel -
PhysicalModel          - Base class for all AD models. Implements a generic discretized model.
ReservoirModel         - Base class for physical models
WrapperModel           - Wrapper model which can be inherited for operations on the parent</p>
</dd>
</dl>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">PhysicalModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel" title="Permalink to this definition"></a></dt>
<dd><p>Base class for all AD models. Implements a generic discretized model.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="p">=</span> <span class="n">PhysicalModel</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Base class for implementing physical models for use with automatic
differentiation. This class cannot be used directly.</p>
<p>A physical model consists of a set of discrete operators that can be
used to define the model equations and a nonlinear tolerance that
defines how close the values must be to zero before the equations can
be considered to be fulfilled. In most cases, the operators are defined
over a grid, which is an optional property in this class. In addition,
the class contains a flag informing if the model equations are linear,
and a flag determining verbosity of class functions.</p>
<p>The class contains member functions for:</p>
<blockquote>
<div><ul class="simple">
<li><p>evaluating residual equations and Jacobians</p></li>
<li><p>querying and setting individual variables in the physical state</p></li>
<li><p>executing a single nonlinear step (i.e., a linear solve with a
possible subsequent stabilization step), verifying convergence, and
reporting the status of the step</p></li>
<li><p>verifying the model, associated physical states, or individual
physical properties</p></li>
</ul>
</div></blockquote>
<p>as well as a number of utility functions for updating the physical
state with increments from the linear solve, etc. See the
implementation of the class for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Simulation grid. Can be set to empty.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘property’</strong> – Set property to the specified value.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the standard base class for the AD-OO solvers. As such, it
does not implement any specific discretization or equations and is
seldom instansiated on its own.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ThreePhaseBlackOilModel</span></code>,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">TwoPhaseOilWaterModel</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.capProperty">
<span class="sig-name descname"><span class="pre">capProperty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">minvalue</span></em>, <em class="sig-param"><span class="pre">maxvalue</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.capProperty" title="Permalink to this definition"></a></dt>
<dd><p>Ensure that a property is within a specific range by capping.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">capProperty</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">&#39;someProp&#39;</span><span class="p">,</span> <span class="n">minValOfProp</span><span class="p">)</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">capProperty</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">&#39;someProp&#39;</span><span class="p">,</span> <span class="n">minValOfProp</span><span class="p">,</span> <span class="n">maxValOfProp</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>state</strong> – State <a href="#id1"><span class="problematic" id="id2">`</span></a>struct`to be updated.</p></li>
<li><p><strong>name</strong> – Name of the field to update, as supported by
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">model.getVariableField</span></code>.</p></li>
<li><p><strong>minvalue</strong> – Minimum value of state property <code class="xref mat mat-func docutils literal notranslate"><span class="pre">name</span></code>. Any values
below this threshold will be set to this value. Set
to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">-inf</span></code> for no lower bound.</p></li>
<li><p><strong>maxvalue</strong> – OPTIONAL: Maximum value of state property <code class="xref mat mat-func docutils literal notranslate"><span class="pre">name</span></code>.
Values that are larger than this limit are set to
the limit. For no upper limit, set <code class="xref mat mat-func docutils literal notranslate"><span class="pre">inf</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – State <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> where <code class="xref mat mat-func docutils literal notranslate"><span class="pre">name</span></code> is within the limits.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Make a random field, and limit it to the range [0.2, 0.5].</span>
<span class="n">state</span> <span class="p">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s">&#39;pressure&#39;</span><span class="p">,</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">capProperty</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
<span class="nb">disp</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">getProp</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">&#39;pressure&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.checkConvergence">
<span class="sig-name descname"><span class="pre">checkConvergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.checkConvergence" title="Permalink to this definition"></a></dt>
<dd><p>Check and report convergence based on residual tolerances</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">convergence</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">names</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">checkConvergence</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Basic convergence testing for a linearized problem. By default,
this simply takes the inf norm of all model equations.
Subclasses are free to overload this function for more
sophisticated and robust options.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>problem</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblemAD</span></code> to be checked for convergence.
The default behavior is to check all equations
against <code class="xref mat mat-func docutils literal notranslate"><span class="pre">model.nonlinearTolerance</span></code> in the inf/max
norm.</p></li>
<li><p><strong>n</strong> – OPTIONAL· The norm to be used. Default: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">inf</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>convergence</strong> – Vector of length <code class="xref mat mat-func docutils literal notranslate"><span class="pre">N</span></code> with bools indicating
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">true/false</span></code> if that residual/error measure has
converged.</p></li>
<li><p><strong>values</strong> – Vector of length <code class="xref mat mat-func docutils literal notranslate"><span class="pre">N</span></code> containing the numerical
values checked for convergence.</p></li>
<li><p><strong>names</strong> – Cell array of length <code class="xref mat mat-func docutils literal notranslate"><span class="pre">N</span></code> containing the names
tested for convergence.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By default, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">N</span></code> is equal to the number of equations in
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">problem</span></code> and the convergence simply checks the convergence of
each equation against a generic <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nonlinearTolerance</span></code>.
However, subclasses are free to produce any number of convergence
criterions and they need not correspond to specific equations
at all.</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.checkProperty">
<span class="sig-name descname"><span class="pre">checkProperty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">property</span></em>, <em class="sig-param"><span class="pre">n_el</span></em>, <em class="sig-param"><span class="pre">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.checkProperty" title="Permalink to this definition"></a></dt>
<dd><p>Check dimensions of property and throw error if dims do not match</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span><span class="p">.</span><span class="n">checkProperty</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">&#39;pressure&#39;</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">model</span><span class="p">.</span><span class="n">checkProperty</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">&#39;components&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">ncell</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>state</strong> – State <a href="#id3"><span class="problematic" id="id4">`</span></a>struct`to be checked.</p></li>
<li><p><strong>name</strong> – Name of the field to check, as supported by
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">model.getVariableField</span></code>.</p></li>
<li><p><strong>n_el</strong> – Array of length <code class="xref mat mat-func docutils literal notranslate"><span class="pre">N</span></code> where entry <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i`corresponds</span> <span class="pre">to</span>
<span class="pre">the</span> <span class="pre">size</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">property</span> <span class="pre">in</span> <span class="pre">dimension</span> <span class="pre">`dim(i)</span></code>.</p></li>
<li><p><strong>dim</strong> – Array of length <code class="xref mat mat-func docutils literal notranslate"><span class="pre">N</span></code> corresponding to the dimensions
for which <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n_el</span></code> is to be checked.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.evaluateAllStateFunctions">
<span class="sig-name descname"><span class="pre">evaluateAllStateFunctions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.evaluateAllStateFunctions" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate ALL state functions, provided that the graph has been
initialized via setupStateFunctionGraph.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getAdjointEquations">
<span class="sig-name descname"><span class="pre">getAdjointEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">forces</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getAdjointEquations" title="Permalink to this definition"></a></dt>
<dd><p>Get the adjoint equations (please read note before use!)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">problem</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getAdjointEquations</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">drivingForces</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Function to get equation when using adjoint to calculate
gradients. This make it possible to use different equations to
calculate the solution in the forward mode, for example if
equations are solved explicitly as for hysteretic models.
it is assumed that the solution of the system in forward for the
two different equations are equal i.e <code class="xref mat mat-func docutils literal notranslate"><span class="pre">problem.val</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>state</strong> – Current state to be solved for time t + dt.</p></li>
<li><p><strong>state0</strong> – The converged state at time t.</p></li>
<li><p><strong>dt</strong> – The scalar time-step.</p></li>
<li><p><strong>forces</strong> – Forces struct. See <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDrivingForces</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>problem</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblemAD</span></code> derived class containing the
linearized equations used for the adjoint problem.
This function is normally <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getEquations</span></code> and assumes
that the function supports the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">reverseMode</span></code>
argument.</p></li>
<li><p><strong>state</strong> – State. Possibly updated. See <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getEquations</span></code> for
details.</p></li>
</ul>
</dd>
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>‘reverseMode’</strong> – If set to true, the reverse mode of the
equations are provided.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A caveat is that this function provides the forward-mode
version of the adjoint equations, normally identical to
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">getEquations</span></code>. MRST allows for separate implementations of
adjoint and regular equations in order to allow for rigorous
treatment of hysteresis and other semi-explicit parameters.</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getDrivingForces">
<span class="sig-name descname"><span class="pre">getDrivingForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">control</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getDrivingForces" title="Permalink to this definition"></a></dt>
<dd><p>Get driving forces in expanded format.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">vararg</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getDrivingForces</span><span class="p">(</span><span class="n">schedule</span><span class="p">.</span><span class="n">control</span><span class="p">(</span><span class="n">ix</span><span class="p">))</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>control</strong> – Struct with the driving forces as fields. This should
be a struct with the same fields as in
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">getValidDrivingForces</span></code>, although this is not
explicitly enforced in this routine.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>vararg</strong> –</p>
<p>Cell-array of forces in the format:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s">&#39;W&#39;</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="s">&#39;bc&#39;</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="c">...}</span>
</pre></div>
</div>
<p>This is typically used as input to variable input
argument functions that support various boundary
conditions options.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getEquations">
<span class="sig-name descname"><span class="pre">getEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">forces</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getEquations" title="Permalink to this definition"></a></dt>
<dd><p>Get the set of linearized model equations with possible Jacobians</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">problem</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getEquations</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">drivingForces</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Provide a set of linearized equations. Unless otherwise noted,
these equations will have <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ADI</span></code> type, containing both the value
and Jacobians of the residual equations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>state</strong> – Current state to be solved for time t + dt.</p></li>
<li><p><strong>state0</strong> – The converged state at time t.</p></li>
<li><p><strong>dt</strong> – The scalar time-step.</p></li>
<li><p><strong>forces</strong> – Forces struct. See <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDrivingForces</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘resOnly’</strong> – If supported by the equations, this flag will
result in only the values of the equations being
computed, omitting any Jacobians.</p></li>
<li><p><strong>‘iteration’</strong> – The nonlinear iteration number. This can be
provided so that the underlying equations can
account for the progress of the nonlinear
solution process in a limited degree, for example
by updating some quantities only at the first
iteration.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>problem</strong> – Instance of the wrapper class <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblemAD</span></code>
containing the residual equations as well as
other useful information.</p></li>
<li><p><strong>state</strong> – The equations are allowed to modify the system
state, allowing a limited caching of expensive
calculations only performed when necessary.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getAdjointEquations</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getIncrement">
<span class="sig-name descname"><span class="pre">getIncrement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getIncrement" title="Permalink to this definition"></a></dt>
<dd><p>Get specific named increment from a list of different increments.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">dv</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getIncrement</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Find increment in linearized problem with given name, or
output zero if not found. A linearized problem can give
updates to multiple variables and this makes it easier to get
those values without having to know the order they were input
into the constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>dx</strong> – Cell array of increments corresponding to the names
in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">problem.primaryVariables</span></code>.</p></li>
<li><p><strong>problem</strong> – Instance of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblem</span></code> from which the
increments were computed.</p></li>
<li><p><strong>name</strong> – Name of the variable for which the increment is to be
extracted.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dv</strong> – The value of the increment, if it is found. Otherwise
a scalar zero value is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getMaximumTimestep">
<span class="sig-name descname"><span class="pre">getMaximumTimestep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getMaximumTimestep" title="Permalink to this definition"></a></dt>
<dd><p>Define the maximum allowable time-step based on physics or
discretization choice</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getModelEquations">
<span class="sig-name descname"><span class="pre">getModelEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getModelEquations" title="Permalink to this definition"></a></dt>
<dd><p>Get equations from AD states</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getPrimaryVariables">
<span class="sig-name descname"><span class="pre">getPrimaryVariables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getPrimaryVariables" title="Permalink to this definition"></a></dt>
<dd><p>Get primary variables from state</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getProp">
<span class="sig-name descname"><span class="pre">getProp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getProp" title="Permalink to this definition"></a></dt>
<dd><p>Get a single property from the nonlinear state</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getProp</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">&#39;pressure&#39;</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>state</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> holding the state of the nonlinear problem.</p></li>
<li><p><strong>name</strong> – A property name supported by the model’s
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">getVariableField</span></code> mapping.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>p</strong> – Property taken from the state.</p></li>
<li><p><strong>state</strong> – The state (modified if property evaluation was done)</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getProps</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getProps">
<span class="sig-name descname"><span class="pre">getProps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getProps" title="Permalink to this definition"></a></dt>
<dd><p>Get multiple properties from state in one go</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getProps</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">&#39;pressure&#39;</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>state</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> holding the state of the nonlinear problem.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘FieldName’</strong> – Property names to be extracted. Any number of
properties can be requested.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>varargout</strong> – Equal number of output arguments to the number of
property strings sent in, corresponding to the
respective properties.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getProp</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getValidDrivingForces">
<span class="sig-name descname"><span class="pre">getValidDrivingForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getValidDrivingForces" title="Permalink to this definition"></a></dt>
<dd><p>Get a struct with the default valid driving forces for the model</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">forces</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getValidDrivingForces</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Different models support different types of boundary
conditions. Each model should implement a default struct,
showing the solvers what a typical allowed struct of boundary
conditions looks like in terms of the named fields present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>forces</strong> – A struct with any number of fields. The fields must be
present, but they can be empty.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.getVariableField">
<span class="sig-name descname"><span class="pre">getVariableField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">throwError</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.getVariableField" title="Permalink to this definition"></a></dt>
<dd><p>Map known variable by name to field and column index in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">state</span></code></p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">fn</span><span class="p">,</span> <span class="nb">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getVariableField</span><span class="p">(</span><span class="s">&#39;someKnownField&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get the index/name mapping for the model (such as where
pressure or water saturation is located in state). For this
parent class, this always result in an error, as this model
knows of no variables.</p>
<p>For subclasses, however, this function is the primary method
the class uses to map named values (such as the name of a
component, or the human readable name of some property) and the
compact representation in the state itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>name</strong> – The name of the property for which the storage field in
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">state</span></code> is requested. Attempts at retrieving a field
the model does not know results in an error.</p></li>
<li><p><strong>throwError</strong> – OPTIONAL: If set to false, no error is thrown and
empty fields are returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>fn</strong> – Field name in the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> where <code class="xref mat mat-func docutils literal notranslate"><span class="pre">name</span></code> is stored.</p></li>
<li><p><strong>index</strong> – Column index of the data.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getProp</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">setProp</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.incrementProp">
<span class="sig-name descname"><span class="pre">incrementProp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">increment</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.incrementProp" title="Permalink to this definition"></a></dt>
<dd><p>Increment named state property by given value</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">incrementProp</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">&#39;PropertyName&#39;</span><span class="p">,</span> <span class="n">increment</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>state</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> holding the state of the nonlinear problem.</p></li>
<li><p><strong>name</strong> – Name of the property to updated. See <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getVariableField</span></code></p></li>
<li><p><strong>value</strong> – The increment that will be added to the current value
of property <code class="xref mat mat-func docutils literal notranslate"><span class="pre">name</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – Updated state <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code>.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% For a model which knows of the field &#39;pressure&#39;, increment</span>
<span class="c">% the value by 7 so that the final value is 10 (=3+7).</span>
<span class="n">state</span> <span class="p">=</span> <span class="nb">struct</span><span class="p">(</span>‘<span class="n">pressure</span>’<span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">incrementProp</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> ‘<span class="n">pressure</span>’<span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.initStateAD">
<span class="sig-name descname"><span class="pre">initStateAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">vars</span></em>, <em class="sig-param"><span class="pre">names</span></em>, <em class="sig-param"><span class="pre">origin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.initStateAD" title="Permalink to this definition"></a></dt>
<dd><p>Initialize AD state from double state</p>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.limitUpdateAbsolute">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">limitUpdateAbsolute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dv</span></em>, <em class="sig-param"><span class="pre">maxAbsCh</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.limitUpdateAbsolute" title="Permalink to this definition"></a></dt>
<dd><p>Limit a update by absolute limit</p>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.limitUpdateRelative">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">limitUpdateRelative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dv</span></em>, <em class="sig-param"><span class="pre">val</span></em>, <em class="sig-param"><span class="pre">maxRelCh</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.limitUpdateRelative" title="Permalink to this definition"></a></dt>
<dd><p>Limit a update by relative limit</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.makeStepReport">
<span class="sig-name descname"><span class="pre">makeStepReport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.makeStepReport" title="Permalink to this definition"></a></dt>
<dd><p>Get the standardized report all models provide from <code class="xref mat mat-func docutils literal notranslate"><span class="pre">stepFunction</span></code></p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">report</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">makeStepReport</span><span class="p">(</span><span class="s">&#39;Converged&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Normalized struct with a number of useful fields. The most
important fields are the fields representing <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Failure</span></code> and
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">Converged</span></code> which <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NonLinearSolver</span></code> reacts appropriately to.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>various</strong> – Keyword/value pairs that override the default values.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>report</strong> – Normalized report with defaulted values where not
provided.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">stepFunction</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NonLinearSolverAD</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.prepareReportstep">
<span class="sig-name descname"><span class="pre">prepareReportstep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">dT</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.prepareReportstep" title="Permalink to this definition"></a></dt>
<dd><p>Prepare state and model (temporarily) before solving a report-step</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.prepareTimestep">
<span class="sig-name descname"><span class="pre">prepareTimestep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.prepareTimestep" title="Permalink to this definition"></a></dt>
<dd><p>Prepare state and model (temporarily) before solving a time-step</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">model</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">prepareTimestep</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">drivingForces</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Prepare model and state just before the first call to
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">stepFunction</span></code> in a solution loop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>state</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> representing the current state of the solution
variables to be updated.</p></li>
<li><p><strong>problem</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblemAD</span></code> instance that has
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">primaryVariables</span></code> which matches <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dx</span></code> in length and
meaning.</p></li>
<li><p><strong>dx</strong> – Cell-wise increments. These are typically output from
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD.solveLinearizedProblem</span></code>.</p></li>
<li><p><strong>forces</strong> – The forces used to produce the update. See
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDrivingForces</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>model</strong> – Updated model (non-persistent)</p></li>
<li><p><strong>state</strong> – Updated state with physically reasonable values.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Any changes to the model are temporary for this specific step,
as enforced by the NonLinearSolver. Any changes will not apply
to the next time-step.</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.reduceState">
<span class="sig-name descname"><span class="pre">reduceState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">removeContainers</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.reduceState" title="Permalink to this definition"></a></dt>
<dd><p>Reduce state to doubles, and optionally remove the property
containers to reduce storage space</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.removeStateFunctionGroupings">
<span class="sig-name descname"><span class="pre">removeStateFunctionGroupings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.removeStateFunctionGroupings" title="Permalink to this definition"></a></dt>
<dd><p>Remove all  state functions from model</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">removeStateFunctionGroupings</span><span class="p">();</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.setProp">
<span class="sig-name descname"><span class="pre">setProp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.setProp" title="Permalink to this definition"></a></dt>
<dd><p>Set named state property to given value</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">setProp</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">&#39;PropertyName&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>state</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> holding the state of the nonlinear problem.</p></li>
<li><p><strong>name</strong> – Name of the property to updated. See <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getVariableField</span></code></p></li>
<li><p><strong>value</strong> – The updated value that will be set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – Updated state <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code>.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% This will set state.pressure to 5 if the model knows of a</span>
<span class="c">% state field named pressure. If it is not known, it will</span>
<span class="c">% result in an error.</span>
<span class="n">state</span> <span class="p">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s">&#39;pressure&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">setProp</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s">&#39;pressure&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.setStateFunctionEvaluationMode">
<span class="sig-name descname"><span class="pre">setStateFunctionEvaluationMode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">mode</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.setStateFunctionEvaluationMode" title="Permalink to this definition"></a></dt>
<dd><p>Set evaluation mode for state functions</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.setupStateFunctionGraph">
<span class="sig-name descname"><span class="pre">setupStateFunctionGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.setupStateFunctionGraph" title="Permalink to this definition"></a></dt>
<dd><p>Set up the state function dependency graph to allow for
single-pass evaluation</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.setupStateFunctionGroupings">
<span class="sig-name descname"><span class="pre">setupStateFunctionGroupings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">setDefaults</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.setupStateFunctionGroupings" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Initialize state functions and corresponding groups</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">setupStateFunctionGroupings</span><span class="p">();</span>
<span class="n">model</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">setupStateFunctionGroupings</span><span class="p">(</span><span class="n">setDefaults</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Ensure that all state functions have been set up.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance for which state function groupings
should be set up</p></li>
<li><p><strong>setDefaults</strong> – Boolean indicating if we should set up a
default discretization. Default: true</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>model</strong> – Class instance. If returned, this model is ready for
evaluation of state functions. It may have been changed
in the process.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.solveAdjoint">
<span class="sig-name descname"><span class="pre">solveAdjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">getState</span></em>, <em class="sig-param"><span class="pre">getObj</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">gradient</span></em>, <em class="sig-param"><span class="pre">stepNo</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.solveAdjoint" title="Permalink to this definition"></a></dt>
<dd><p>Solve a single linear adjoint step to obtain the gradient</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="nb">gradient</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">solveAdjoint</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">getState</span><span class="p">,</span> <span class="p">...</span>
                        <span class="n">getObjective</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="nb">gradient</span><span class="p">,</span> <span class="n">itNo</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This solves the linear adjoint equations. This is the backwards
analogue of the forward mode <code class="xref mat mat-func docutils literal notranslate"><span class="pre">stepFunction</span></code> in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code>
as well as the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">solveTimestep</span></code> method in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NonLinearSolver</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>solver</strong> – Linear solver to be used to solve the linearized
system.</p></li>
<li><p><strong>getState</strong> – <p>Function handle. Should support the syntax:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">getState</span><span class="p">(</span><span class="n">stepNo</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain the converged state from the forward
simulation for step <code class="xref mat mat-func docutils literal notranslate"><span class="pre">stepNo</span></code>.</p>
</p></li>
<li><p><strong>getObj</strong> – <p>Function handle providing the objective function for
a specific step <code class="xref mat mat-func docutils literal notranslate"><span class="pre">stepNo</span></code>:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">objfn</span> <span class="p">=</span> <span class="n">getObj</span><span class="p">(</span><span class="n">stepNo</span><span class="p">)</span>
</pre></div>
</div>
</p></li>
<li><p><strong>schedule</strong> – Schedule used to compute the forward simulation.</p></li>
<li><p><strong>gradient</strong> – Current gradient to be updated. See outputs.</p></li>
<li><p><strong>stepNo</strong> – The current control step to be solved.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>gradient</strong> – The updated gradient.</p></li>
<li><p><strong>result</strong> – Solution of the adjoint problem.</p></li>
<li><p><strong>report</strong> – Report with information about the solution process.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.simulators.computeGradientAdjointAD" title="ad_core.simulators.computeGradientAdjointAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGradientAdjointAD</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.stepFunction">
<span class="sig-name descname"><span class="pre">stepFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em>, <em class="sig-param"><span class="pre">linsolver</span></em>, <em class="sig-param"><span class="pre">nonlinsolver</span></em>, <em class="sig-param"><span class="pre">iteration</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.stepFunction" title="Permalink to this definition"></a></dt>
<dd><p>Perform a step that ideally brings the state closer to convergence</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">state</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">stepFunction</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="p">...</span>
                                     <span class="n">forces</span><span class="p">,</span> <span class="n">ls</span><span class="p">,</span> <span class="n">nls</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Perform a single nonlinear step and report the progress towards
convergence. The exact semantics of a nonlinear step varies
from model to model, but the default behavior is to linearize
the equations and solve a single step of the Newton-Rapshon
algorithm for general nonlinear equations.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.updateAfterConvergence">
<span class="sig-name descname"><span class="pre">updateAfterConvergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.updateAfterConvergence" title="Permalink to this definition"></a></dt>
<dd><p>Final update to the state after convergence has been achieved</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">state</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">updateAfterConvergence</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">forces</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Update state based on nonlinear increment after timestep has
converged. Defaults to doing nothing since not all models
require this.</p>
<p>This function allows for the update of secondary variables
instate after convergence has been achieved. This is especially
useful for hysteretic parameters, where future function
evaluations depend on the previous maximum value over all
converged states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>state</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> holding the current solution state.</p></li>
<li><p><strong>forces</strong> – Driving forces used to execute the step. See
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDrivingForces</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>state</strong> – Updated <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> holding the current solution state.</p></li>
<li><p><strong>report</strong> – Report containing information about the update.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.updateForChangedControls">
<span class="sig-name descname"><span class="pre">updateForChangedControls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">forces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.updateForChangedControls" title="Permalink to this definition"></a></dt>
<dd><p>Update model and state when controls/drivingForces has changed</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">model</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">updateForChangedControls</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">forces</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Whenever controls change, this function should ensure that both
model and state are up to date with the present set of driving
forces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>state</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> holding the current solution state.</p></li>
<li><p><strong>forces</strong> – The new driving forces to be used in subsequent calls
to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getEquations</span></code>. See <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDrivingForces</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>model</strong> – Updated class instance.</p></li>
<li><p><strong>state</strong> – Updated <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> holding the current solution state
with accomodations made for any changed controls that
provide e.g. primary variables.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.updateState">
<span class="sig-name descname"><span class="pre">updateState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">forces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.updateState" title="Permalink to this definition"></a></dt>
<dd><p>Update the state based on increments of the primary values</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">state</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">updateState</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">drivingForces</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Update the state’s primary variables (and any secondary
quantities computing during the update process) based on a set
of increments to each of the primary variables contained in
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">problem.primaryVariables</span></code>.</p>
<p>This function should ensure that values are within physically
meaningful values and are meaningful so that the next call to
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">stepFunction</span></code> can produce yet another set of reasonable
increments in a process that eventually results in convergence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>state</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> representing the current state of the solution
variables to be updated.</p></li>
<li><p><strong>problem</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblemAD</span></code> instance that has
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">primaryVariables</span></code> which matches <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dx</span></code> in length and
meaning.</p></li>
<li><p><strong>dx</strong> – Cell-wise increments. These are typically output from
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD.solveLinearizedProblem</span></code>.</p></li>
<li><p><strong>forces</strong> – The forces used to produce the update. See
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDrivingForces</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>state</strong> – Updated state with physically reasonable values.</p></li>
<li><p><strong>report</strong> – Struct with information about the update process.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Specific properties can be manually updated with a variety of
different functions. We trust the user and leave these
functions as public. However, the main gateway to the update of
state is through this function to ensure that all values are
updated simultaneously. For many problems, updates can not be
done separately and all changes in the primary variables must
considered together for the optimal performance.</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.updateStateFromIncrement">
<span class="sig-name descname"><span class="pre">updateStateFromIncrement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">relchangemax</span></em>, <em class="sig-param"><span class="pre">abschangemax</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.updateStateFromIncrement" title="Permalink to this definition"></a></dt>
<dd><p>Update value in state, with optional limits on update magnitude</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">updateStateFromIncrement</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">)</span>
<span class="p">[</span><span class="n">state</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">val0</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">updateStateFromIncrement</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>state</strong> – State <a href="#id5"><span class="problematic" id="id6">`</span></a>struct`to be updated.</p></li>
<li><p><strong>dx</strong> – Increments. Either a <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cell</span></code> array matching the the
primary variables of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">problem</span></code>, or a single value.</p></li>
<li><p><strong>problem</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblem</span></code> used to obtain the increments.
This input argument is only used if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dx</span></code> is a
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">cell</span></code> array and can be replaced by a dummy value if
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">dx</span></code> is a numerical type.</p></li>
<li><p><strong>name</strong> – Name of the field to update, as supported by
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">model.getVariableField</span></code>.</p></li>
<li><p><strong>relchangemax</strong> – OPTIONAL. If provided, this will be interpreted
as the maximum <em>relative</em> change in the variable
allowed.</p></li>
<li><p><strong>abschangemax</strong> – OPTIONAL. If provided, this is the maximum
<em>absolute</em> change in the variable allowed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – State with updated value.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Update pressure with an increment of 10, without any limits,</span>
<span class="c">% resulting in the pressure being 110 after the update.</span>
<span class="n">state</span> <span class="p">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s">&#39;pressure&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">updateStateFromIncrement</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="s">&#39;pressure&#39;</span><span class="p">)</span>
<span class="c">% Alternatively, we can use a relative limit on the update. In</span>
<span class="c">% the following, the pressure will be set to 11 as an immediate</span>
<span class="c">% update to 110 would violate the maximum relative change of</span>
<span class="c">% 0.1 (10 %)</span>
 <span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">updateStateFromIncrement</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="s">&#39;pressure&#39;</span><span class="p">,</span> <span class="p">.</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Relative limits such as these are important when working with
tabulated and nonsmooth properties in a Newton-type loop, as the
initial updates may be far outside the reasonable region of
linearization for a complex problem. On the other hand, limiting
the relative updates can delay convergence for smooth problems
with analytic properties and will, in particular, prevent zero
states from being updated, so use with care.</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.validateModel">
<span class="sig-name descname"><span class="pre">validateModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.validateModel" title="Permalink to this definition"></a></dt>
<dd><p>Validate model and check if it is ready for simulation</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">validateModel</span><span class="p">();</span>
<span class="n">model</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">validateModel</span><span class="p">(</span><span class="n">forces</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Validate that a model is suitable for simulation. If the
missing or inconsistent parameters can be fixed automatically,
an updated model will be returned. Otherwise, an error should
occur.</p>
<p>Second input may be the forces struct argument. This function
should NOT require forces arg to run, however.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance to be validated.</p></li>
<li><p><strong>forces</strong> – (OPTIONAL): The forces to be used. Some models require
setup and configuration specific to the forces used.
This is especially important for the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code>,
which implements the coupling between wells and the
reservoir for <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code> subclasses of
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>model</strong> – Class instance. If returned, this model is ready for
simulation. It may have been changed in the process.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.validateState">
<span class="sig-name descname"><span class="pre">validateState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.PhysicalModel.validateState" title="Permalink to this definition"></a></dt>
<dd><p>Validate state and check if it is ready for simulation</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">validateState</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Validate the state for use with <code class="xref mat mat-func docutils literal notranslate"><span class="pre">model</span></code>. Should check that
required fields are present and of the right dimensions. If
missing fields can be assigned default values, state is return
with the required fields added. If reasonable default values
cannot be assigned, a descriptive error should be thrown
telling the user what is missing or wrong (and ideally how to
fix it).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance for which <code class="xref mat mat-func docutils literal notranslate"><span class="pre">state</span></code> is intended as a
valid state.</p></li>
<li><p><strong>state</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code> which is to be validated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">struct</span></code>. If returned, this state is ready for
simulation with <code class="xref mat mat-func docutils literal notranslate"><span class="pre">model</span></code>. It may have been changed in
the process.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.G">
<span class="sig-name descname"><span class="pre">G</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.PhysicalModel.G" title="Permalink to this definition"></a></dt>
<dd><p>Grid. Can be empty.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.nonlinearTolerance">
<span class="sig-name descname"><span class="pre">nonlinearTolerance</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.PhysicalModel.nonlinearTolerance" title="Permalink to this definition"></a></dt>
<dd><p>Inf norm tolerance for checking residuals</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.operators">
<span class="sig-name descname"><span class="pre">operators</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.PhysicalModel.operators" title="Permalink to this definition"></a></dt>
<dd><p>Operators used for construction of systems</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.stepFunctionIsLinear">
<span class="sig-name descname"><span class="pre">stepFunctionIsLinear</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.PhysicalModel.stepFunctionIsLinear" title="Permalink to this definition"></a></dt>
<dd><p>Model step function is linear.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.PhysicalModel.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.PhysicalModel.verbose" title="Permalink to this definition"></a></dt>
<dd><p>Verbosity from model routines</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">ReservoirModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ad_core.models.PhysicalModel" title="ad_core.models.PhysicalModel"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">PhysicalModel</span></code></a></p>
<p>Base class for physical models</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="p">=</span> <span class="n">ReservoirModel</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Extension of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code> class to accomodate reservoir-specific
features such as fluid and rock as well as commonly used phases and
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Simulation grid.</p></li>
<li><p><strong>rock</strong> – Valid rock used for the model.</p></li>
<li><p><strong>fluid</strong> – Fluid model used for the model.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘property’</strong> – Set property to the specified value.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>Class instance.</strong></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ThreePhaseBlackOilModel</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">TwoPhaseOilWaterModel</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.addBoundaryConditionsAndSources">
<span class="sig-name descname"><span class="pre">addBoundaryConditionsAndSources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">eqs</span></em>, <em class="sig-param"><span class="pre">names</span></em>, <em class="sig-param"><span class="pre">types</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">mob</span></em>, <em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">dissolved</span></em>, <em class="sig-param"><span class="pre">components</span></em>, <em class="sig-param"><span class="pre">forces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.addBoundaryConditionsAndSources" title="Permalink to this definition"></a></dt>
<dd><p>Add in the boundary conditions and source terms to equations</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">eqs</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="p">=</span> <span class="n">addBoundaryConditionsAndSources</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">eqs</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="p">...</span>
                                                     <span class="n">p</span><span class="p">,</span> <span class="n">sat</span><span class="p">,</span> <span class="n">mob</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="p">...</span>
                                                     <span class="n">rs</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="p">...</span>
                                                     <span class="n">drivingForces</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>eqs</strong> – Cell array of equations that are to be updated.</p></li>
<li><p><strong>names</strong> – The names of the equations to be updated. If
phase-pseudocomponents are to be used, the names must
correspond to some combination of “water”, “oil”, “gas”
if no special component treatment is to be introduced.</p></li>
<li><p><strong>types</strong> – Cell array with the types of “eqs”. Note that these
types must be ‘cell’ where source terms is to be added.</p></li>
<li><p><strong>src</strong> – Struct containing all the different source terms that
were computed and added to the equations.</p></li>
<li><p><strong>p</strong> – Cell array of phase pressures.</p></li>
<li><p><strong>s</strong> – Cell array of phase saturations.</p></li>
<li><p><strong>mob</strong> – Cell array of phase mobilities</p></li>
<li><p><strong>rho</strong> – Cell array of phase densities</p></li>
<li><p><strong>dissolved</strong> – Cell array of dissolved components for black-oil
style pseudocompositional models.</p></li>
<li><p><strong>components</strong> – Cell array of equal length to the number of
components. The exact representation may vary
based on the model, but the respective
sub-component is passed onto
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">addComponentContributions</span></code>.</p></li>
<li><p><strong>forces</strong> – DrivingForces struct (see <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getValidDrivingForces</span></code>)
containing (possibily empty) <code class="xref mat mat-func docutils literal notranslate"><span class="pre">src</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">bc</span></code> fields.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>eqs</strong> – Equations with corresponding source terms added.</p></li>
<li><p><strong>state</strong> – Reservoir state. Can be modified to store e.g. boundary
fluxes due to boundary conditions.</p></li>
<li><p><strong>src</strong> – Normalized struct containing the source terms used.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function accomodates both the option of black-oil
pseudocomponents (if the model equations are named “oil”, “gas”
or water) and true components existing in multiple phases.
Mixing the two behaviors can lead to unexpected source terms.</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.addComponentContributions">
<span class="sig-name descname"><span class="pre">addComponentContributions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">cname</span></em>, <em class="sig-param"><span class="pre">eq</span></em>, <em class="sig-param"><span class="pre">component</span></em>, <em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">force</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.addComponentContributions" title="Permalink to this definition"></a></dt>
<dd><p>For a given component conservation equation, compute and add in
source terms for a specific source/bc where the fluxes have
already been computed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – (Base class, automatic)</p></li>
<li><p><strong>cname</strong> – Name of the component. Must be a property known to the
model itself through <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getProp</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getVariableField</span></code>.</p></li>
<li><p><strong>eq</strong> – Equation where the source terms are to be added. Should
be one value per cell in the simulation grid (model.G)
so that the src.sourceCells is meaningful.</p></li>
<li><p><strong>component</strong> – Cell-wise values of the component in question. Used
for outflow source terms only.</p></li>
<li><p><strong>src</strong> – Source struct containing fields for fluxes etc. Should
be constructed from force and the current reservoir
state by <a class="reference internal" href="#ad_core.utils.computeSourcesAndBoundaryConditionsAD" title="ad_core.utils.computeSourcesAndBoundaryConditionsAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeSourcesAndBoundaryConditionsAD</span></code></a>.</p></li>
<li><p><strong>force</strong> – Force struct used to produce src. Should contain the
field defining the component in question, so that the
inflow of the component through the boundary condition
or source terms can accurately by estimated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.adjustStepFromSatBounds">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">adjustStepFromSatBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">ds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.adjustStepFromSatBounds" title="Permalink to this definition"></a></dt>
<dd><p>Ensure that cellwise increment for each phase is done with
the same length, in a manner that avoids saturation
violations.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.compVarIndex">
<span class="sig-name descname"><span class="pre">compVarIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.compVarIndex" title="Permalink to this definition"></a></dt>
<dd><p>Find the index of a component variable by name</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="nb">index</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">compVarIndex</span><span class="p">(</span><span class="s">&#39;co2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>name</strong> – Name of component.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>index</strong> – Index of the component for this model. Empty if
saturation was not known to model.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.evaluateRelPerm">
<span class="sig-name descname"><span class="pre">evaluateRelPerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">sat</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.evaluateRelPerm" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate relative permeability corresponding to active phases</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Single-phase water model</span>
<span class="n">krW</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">evaluateRelPerm</span><span class="p">({</span><span class="n">sW</span><span class="p">});</span>
<span class="c">% Two-phase oil-water model</span>
<span class="p">[</span><span class="n">krW</span><span class="p">,</span> <span class="n">krO</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">evaluateRelPerm</span><span class="p">({</span><span class="n">sW</span><span class="p">,</span> <span class="n">sO</span><span class="p">});</span>
<span class="c">% Two-phase water-gas model</span>
<span class="p">[</span><span class="n">krW</span><span class="p">,</span> <span class="n">krG</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">evaluateRelPerm</span><span class="p">({</span><span class="n">sW</span><span class="p">,</span> <span class="n">sG</span><span class="p">});</span>
<span class="c">% Three-phase oil-water-gas model</span>
<span class="p">[</span><span class="n">krW</span><span class="p">,</span> <span class="n">krO</span><span class="p">,</span> <span class="n">krG</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">evaluateRelPerm</span><span class="p">({</span><span class="n">sW</span><span class="p">,</span> <span class="n">sO</span><span class="p">,</span> <span class="n">sG</span><span class="p">});</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – The model</p></li>
<li><p><strong>sat</strong> – Cell array containing the saturations for all active
phases.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>varargout</strong> – One output argument per phase present,
corresponding to evaluated relative permeability
functions for each phase in the canonical ordering.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">relPermWOG</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">relPermWO</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">relPermOG</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">relPermWG</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getActivePhases">
<span class="sig-name descname"><span class="pre">getActivePhases</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getActivePhases" title="Permalink to this definition"></a></dt>
<dd><p>Get active flag for MRST’s canonical phase ordering (WOG)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">act</span><span class="p">,</span> <span class="n">indices</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getActivePhases</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>isActive</strong> – Total number of known phases array with booleans
indicating if that phase is present. MRST uses a
ordering of water, oil and then gas.</p></li>
<li><p><strong>phInd</strong> – Indices of the phases present. For instance, if
water and gas are the only ones present,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">phInd</span> <span class="pre">=</span> <span class="pre">[1,</span> <span class="pre">3]</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getComponentNames">
<span class="sig-name descname"><span class="pre">getComponentNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getComponentNames" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Get the names of components for the model
.. rubric:: Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">names</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getComponentNames</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>names</strong> – Cell array of component names in no particular order.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getConvergenceValues">
<span class="sig-name descname"><span class="pre">getConvergenceValues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getConvergenceValues" title="Permalink to this definition"></a></dt>
<dd><p>Check convergence criterion. Relies on <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> to check
wells.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.checkConvergence" title="ad_core.models.PhysicalModel.checkConvergence"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.checkConvergence</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getExtraWellContributions">
<span class="sig-name descname"><span class="pre">getExtraWellContributions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">q_s</span></em>, <em class="sig-param"><span class="pre">bh</span></em>, <em class="sig-param"><span class="pre">packed</span></em>, <em class="sig-param"><span class="pre">qMass</span></em>, <em class="sig-param"><span class="pre">qVol</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">iteration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getExtraWellContributions" title="Permalink to this definition"></a></dt>
<dd><p>This function is called by the well model (base class:
SimpleWell) during the assembly of well equations and addition of
well source terms. The purpose of this function, given the
internal variables of the well model, is to compute the additional
closure equations and source terms that the model requires. For
instance, if the model contains different components that require
special treatment (see for example the implementation of this
function in <a class="reference internal" href="ad-eor.html#ad_eor.models.OilWaterPolymerModel" title="ad_eor.models.OilWaterPolymerModel"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">ad_eor.models.OilWaterPolymerModel</span></code></a> in the
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-eor</span></code> module), this function should assemble any additional
equations and corresponding source terms. It is also possible to
add source terms without actually adding well equations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>compEqs</strong> – A cell array of additional equations added to the
system to account for the treatment of components etc
in the well system.</p></li>
<li><p><strong>compSrc</strong> – Cell array of component source terms, ordered and with
the same length as the output from
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel.getComponentNames</span></code>.</p></li>
<li><p><strong>eqNames</strong> – Names of the added equations. Must correspond to the
same entries as <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getExtraWellEquationNames</span></code> (but does
not have to maintain the same ordering).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Input arguments are intentionally undocumented and subject to
change. Please see <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SimpleWell</span></code> for details.</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getExtraWellEquationNames">
<span class="sig-name descname"><span class="pre">getExtraWellEquationNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getExtraWellEquationNames" title="Permalink to this definition"></a></dt>
<dd><p>Get the names and types of extra well equations in model</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">names</span><span class="p">,</span> <span class="n">types</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getExtraWellEquationNames</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Base class.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>names</strong> – Cell array of additional well equations.</p></li>
<li><p><strong>types</strong> – Cell array of corresponding types to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">names</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getExtraWellContributions</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getExtraWellPrimaryVariableNames">
<span class="sig-name descname"><span class="pre">getExtraWellPrimaryVariableNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getExtraWellPrimaryVariableNames" title="Permalink to this definition"></a></dt>
<dd><p>Get the names of extra well primary variables required by model.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">names</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getExtraWellPrimaryVariableNames</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>names</strong> – Cell array of named primary variables.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getExtraWellContributions</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getGravityGradient">
<span class="sig-name descname"><span class="pre">getGravityGradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getGravityGradient" title="Permalink to this definition"></a></dt>
<dd><p>Get the discretized gravity contribution on faces</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">gdz</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getGravityGradient</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>g</strong> – One entry of the gravity contribution per face in the
grid. Does not necessarily assume that gravity is
aligned with one specific direction.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.params.gravity" title="core.params.gravity"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">gravity</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getGravityVector">
<span class="sig-name descname"><span class="pre">getGravityVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getGravityVector" title="Permalink to this definition"></a></dt>
<dd><p>Get the gravity vector used to instantiate the model</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getGravityVector</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>g</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">model.G.griddim</span></code> long vector representing the gravity
accleration constant along increasing depth.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.params.gravity" title="core.params.gravity"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">gravity</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getMaximumTimestep">
<span class="sig-name descname"><span class="pre">getMaximumTimestep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">dt0</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getMaximumTimestep" title="Permalink to this definition"></a></dt>
<dd><p>Define the maximum allowable time-step based on physics or
discretization choice</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getPhaseIndex">
<span class="sig-name descname"><span class="pre">getPhaseIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getPhaseIndex" title="Permalink to this definition"></a></dt>
<dd><p>Query the index of phases in the model’s ordering</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="nb">index</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getPhaseIndex</span><span class="p">(</span><span class="s">&#39;W&#39;</span><span class="p">);</span>
<span class="p">[</span><span class="n">wix</span><span class="p">,</span> <span class="n">gix</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getPhaseIndex</span><span class="p">(</span><span class="s">&#39;W&#39;</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>phasename</strong> – The name of the phase to be found.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>index</strong> – Index of phase <code class="xref mat mat-func docutils literal notranslate"><span class="pre">phasename</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getPhaseIndices">
<span class="sig-name descname"><span class="pre">getPhaseIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getPhaseIndices" title="Permalink to this definition"></a></dt>
<dd><p>Get the active phases in canonical ordering</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getPhaseNames">
<span class="sig-name descname"><span class="pre">getPhaseNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getPhaseNames" title="Permalink to this definition"></a></dt>
<dd><p>Get short and long names of the present phases.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">phNames</span><span class="p">,</span> <span class="n">longNames</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getPhaseNames</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>phNames</strong> – Cell array containing the short hanes (‘W’, ‘O’,
G’) of the phases present</p></li>
<li><p><strong>longNames</strong> – Longer names (‘water’, ‘oil’, ‘gas’) of the phases
present.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getScalingFactorsCPR">
<span class="sig-name descname"><span class="pre">getScalingFactorsCPR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">names</span></em>, <em class="sig-param"><span class="pre">solver</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getScalingFactorsCPR" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Get scaling factors for CPR reduction in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">CPRSolverAD</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>problem</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblemAD</span></code> which is intended for CPR
preconditioning.</p></li>
<li><p><strong>names</strong> – The names of the equations for which the factors are
to be obtained.</p></li>
<li><p><strong>solver</strong> – The <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code> class requesting the scaling
factors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>scaling</strong> – Cell array with either a scalar scaling factor for
each equation, or a vector of equal length to that
equation.</p>
</dd>
</dl>
<dl class="simple">
<dt>SEE ALSO</dt><dd><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">CPRSolverAD</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getSurfaceDensities">
<span class="sig-name descname"><span class="pre">getSurfaceDensities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">regions</span></em>, <em class="sig-param"><span class="pre">phases</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getSurfaceDensities" title="Permalink to this definition"></a></dt>
<dd><p>Get the surface densities of the active phases in canonical
ordering (WOG, with any inactive phases removed).
OPTIONAL INPUTS:
regions - Region indicator to use for output if multiple surface</p>
<blockquote>
<div><p>densities are present. If regions are present, the
output will have equal number of rows as the number of
entries in regions, or to the number of true entries if
it is a logical array.</p>
</div></blockquote>
<dl class="simple">
<dt>phases  - Index into the phases. Will only return values for</dt><dd><p>these phases.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>rhoS</strong> – pvt x n double array of surface densities.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getValidDrivingForces">
<span class="sig-name descname"><span class="pre">getValidDrivingForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getValidDrivingForces" title="Permalink to this definition"></a></dt>
<dd><p>Get valid forces. This class adds support for wells, bc and src.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.getValidDrivingForces" title="ad_core.models.PhysicalModel.getValidDrivingForces"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.getValidDrivingForces</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.getVariableField">
<span class="sig-name descname"><span class="pre">getVariableField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.getVariableField" title="Permalink to this definition"></a></dt>
<dd><p>Map variables to state field.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.getVariableField" title="ad_core.models.PhysicalModel.getVariableField"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.getVariableField</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.insertSources">
<span class="sig-name descname"><span class="pre">insertSources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">eqs</span></em>, <em class="sig-param"><span class="pre">src</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.insertSources" title="Permalink to this definition"></a></dt>
<dd><p>Insert source terms into equations</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.insertWellEquations">
<span class="sig-name descname"><span class="pre">insertWellEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">eqs</span></em>, <em class="sig-param"><span class="pre">names</span></em>, <em class="sig-param"><span class="pre">types</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">wellVars</span></em>, <em class="sig-param"><span class="pre">wellMap</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">mob</span></em>, <em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">dissolved</span></em>, <em class="sig-param"><span class="pre">components</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">opt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.insertWellEquations" title="Permalink to this definition"></a></dt>
<dd><p>Add in the effect of wells to a system of equations, by adding
corresponding source terms and augmenting the system with
additional equations for the wells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eqs</strong> – Cell array of equations that are to be updated.</p></li>
<li><p><strong>names</strong> – The names of the equations to be updated. If
phase-pseudocomponents are to be used, the names must
correspond to some combination of “water”, “oil”, “gas”
if no special component treatment is to be introduced.</p></li>
<li><p><strong>types</strong> – Cell array with the types of “eqs”. Note that these
types must be ‘cell’ where source terms is to be added.</p></li>
<li><p><strong>src</strong> – Struct containing all the different source terms that
were computed and added to the equations.</p></li>
<li><p><strong>various</strong> – Additional input arguments correspond to standard
reservoir-well coupling found in <a href="#id7"><span class="problematic" id="id8">`</span></a>FacilityModel.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.relPermOG">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">relPermOG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">so</span></em>, <em class="sig-param"><span class="pre">sg</span></em>, <em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.relPermOG" title="Permalink to this definition"></a></dt>
<dd><p>Two-phase oil-gas relative permeability function</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">krO</span><span class="p">,</span> <span class="n">krG</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">relPermOG</span><span class="p">(</span><span class="n">so</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sw</strong> – Water saturation</p></li>
<li><p><strong>sg</strong> – Gas saturation</p></li>
<li><p><strong>f</strong> – <p>Struct representing the field. Fields that are used:</p>
<ul>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krO</span></code>: Oil relperm function of oil saturation.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krOG</span></code>: Oil-gas relperm function of gas saturation.
This function is only used if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">krO</span></code> is not found.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krG</span></code>: Gas relperm function of gas saturation.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>krO</strong> – Oil relative permeability.</p></li>
<li><p><strong>krG</strong> – Gas relative permeability</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should typically not be called directly as its
interface is subject to change. Instead, use <code class="xref mat mat-func docutils literal notranslate"><span class="pre">evaluateRelPerm</span></code>.</p>
</div>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.relPermWG">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">relPermWG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">sw</span></em>, <em class="sig-param"><span class="pre">sg</span></em>, <em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.relPermWG" title="Permalink to this definition"></a></dt>
<dd><p>Two-phase water-gas relative permeability function</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">krW</span><span class="p">,</span> <span class="n">krG</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">relPermWG</span><span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sw</strong> – Water saturation</p></li>
<li><p><strong>sg</strong> – Gas saturation</p></li>
<li><p><strong>f</strong> – <p>Struct representing the field. Fields that are used:</p>
<ul>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krW</span></code>: Water relperm function of water saturation.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krG</span></code>: Gas relperm function of gas saturation.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>krW</strong> – Water relative permeability.</p></li>
<li><p><strong>krG</strong> – Gas relative permeability</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should typically not be called directly as its
interface is subject to change. Instead, use <code class="xref mat mat-func docutils literal notranslate"><span class="pre">evaluateRelPerm</span></code>.</p>
</div>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.relPermWO">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">relPermWO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">sw</span></em>, <em class="sig-param"><span class="pre">so</span></em>, <em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.relPermWO" title="Permalink to this definition"></a></dt>
<dd><p>Two-phase water-oil relative permeability function</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">krW</span><span class="p">,</span> <span class="n">krO</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">relPermWO</span><span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="n">so</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sw</strong> – Water saturation</p></li>
<li><p><strong>so</strong> – Oil saturation</p></li>
<li><p><strong>f</strong> – <p>Struct representing the field. Fields that are used:</p>
<ul>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krW</span></code>: Water relperm function of water saturation.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krO</span></code>: Oil relperm function of oil saturation.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krOW</span></code>: Oil-water relperm function of oil saturation.
Only used if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">krO</span></code> is not found.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>krW</strong> – Water relative permeability.</p></li>
<li><p><strong>krO</strong> – Oil relative permeability.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should typically not be called directly as its
interface is subject to change. Instead, use <code class="xref mat mat-func docutils literal notranslate"><span class="pre">evaluateRelPerm</span></code>.</p>
</div>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.relPermWOG">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">relPermWOG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">sw</span></em>, <em class="sig-param"><span class="pre">so</span></em>, <em class="sig-param"><span class="pre">sg</span></em>, <em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.relPermWOG" title="Permalink to this definition"></a></dt>
<dd><p>Three-phase water-oil-gas relative permeability function</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">krW</span><span class="p">,</span> <span class="n">krO</span><span class="p">,</span> <span class="n">krG</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">relPermWOG</span><span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="n">so</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sw</strong> – Water saturation</p></li>
<li><p><strong>so</strong> – Oil saturation</p></li>
<li><p><strong>sg</strong> – Gas saturation</p></li>
<li><p><strong>f</strong> – <p>Struct representing the field. Fields that are used:</p>
<ul>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krW</span></code>:  Water relperm function of water saturation.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krOW</span></code>: Oil-water relperm function of oil saturation.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krOG</span></code>: Oil-gas relperm function of oil saturation.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">krG</span></code>:   Gas relperm function of gas saturation.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">sWcon</span></code>: Connate water saturation. OPTIONAL.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>krW</strong> – Water relative permeability.</p></li>
<li><p><strong>krO</strong> – Oil relative permeability.</p></li>
<li><p><strong>krG</strong> – Gas relative permeability</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should typically not be called directly as its
interface is subject to change. Instead, use <code class="xref mat mat-func docutils literal notranslate"><span class="pre">evaluateRelPerm</span></code>.</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.satVarIndex">
<span class="sig-name descname"><span class="pre">satVarIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.satVarIndex" title="Permalink to this definition"></a></dt>
<dd><p>Find the index of a saturation variable by name</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="nb">index</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">satVarIndex</span><span class="p">(</span><span class="s">&#39;water&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>name</strong> – Name of phase.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>index</strong> – Index of the phase for this model. Empty if saturation
was not found.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.setPhaseData">
<span class="sig-name descname"><span class="pre">setPhaseData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">data</span></em>, <em class="sig-param"><span class="pre">fld</span></em>, <em class="sig-param"><span class="pre">subs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.setPhaseData" title="Permalink to this definition"></a></dt>
<dd><p>Store phase data in state for further output.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">setPhaseData</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s">&#39;someField&#39;</span><span class="p">)</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">setPhaseData</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s">&#39;someField&#39;</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Utility function for storing phase data in the state. This is
used for densities, fluxes, mobilities and so on when requested
from the simulator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>data</strong> – Cell array of data to be stored. One entry per active
phase in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">model</span></code>.</p></li>
<li><p><strong>fld</strong> – The field to be stored.</p></li>
<li><p><strong>subs</strong> – <p>OPTIONAL. The subset for which phase data is to be
stored. Must be a valid index of the type</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="p">.(</span><span class="n">fld</span><span class="p">)(</span><span class="n">subs</span><span class="p">,</span> <span class="n">someIndex</span><span class="p">)</span> <span class="p">=</span> <span class="n">data</span><span class="p">{</span><span class="nb">i</span><span class="p">}</span>
</pre></div>
</div>
<p>for all i. Defaults to all indices.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – state with updated <code class="xref mat mat-func docutils literal notranslate"><span class="pre">fld</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.setupOperators">
<span class="sig-name descname"><span class="pre">setupOperators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.setupOperators" title="Permalink to this definition"></a></dt>
<dd><p>Set up default discretization operators and other static props</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">setupOperators</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function calls the default set of discrete operators as
implemented by <a class="reference internal" href="#ad_core.utils.setupOperatorsTPFA" title="ad_core.utils.setupOperatorsTPFA"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">setupOperatorsTPFA</span></code></a>. The default operators use
standard choices for reservoir simulation similar to what is
found in commercial simulators: Single-point potential upwind
and two-point flux approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>G</strong> – The grid used for computing the operators. Must have
geometry information added (typically from
<a class="reference internal" href="core.html#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>). Although this is a property on the
model, we allow for passing of a different grid for the
operator setup since this is useful in some workflows.</p></li>
<li><p><strong>rock</strong> – Rock structure. See <a class="reference internal" href="core.html#core.params.rock.makeRock" title="core.params.rock.makeRock"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeRock</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>model</strong> – Model with updated <code class="xref mat mat-func docutils literal notranslate"><span class="pre">operators</span></code> property.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is called automatically during class
construction.</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.splitPrimaryVariables">
<span class="sig-name descname"><span class="pre">splitPrimaryVariables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">vars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.splitPrimaryVariables" title="Permalink to this definition"></a></dt>
<dd><p>Split cell array of primary variables into grouping
.. rubric:: Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">restVars</span><span class="p">,</span> <span class="n">satVars</span><span class="p">,</span> <span class="n">wellVars</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">splitPrimaryVariables</span><span class="p">(</span><span class="n">vars</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Split a set of primary variables into three groups:
Well variables, saturation variables and the rest. This is
useful because the saturation variables usually are updated
together, and the well variables are a special case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>vars</strong> – Cell array with names of primary variables</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>restVars</strong> – Names of variables that are not saturations or
belong to the wells.</p></li>
<li><p><strong>satVars</strong> – Names of the saturation variables present in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">vars</span></code>.</p></li>
<li><p><strong>wellVars</strong> – Names of the well variables present in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">vars</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.storeBoundaryFluxes">
<span class="sig-name descname"><span class="pre">storeBoundaryFluxes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">qW</span></em>, <em class="sig-param"><span class="pre">qO</span></em>, <em class="sig-param"><span class="pre">qG</span></em>, <em class="sig-param"><span class="pre">forces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.storeBoundaryFluxes" title="Permalink to this definition"></a></dt>
<dd><p>Store integrated phase fluxes on boundary in state.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Three</span><span class="o">-</span><span class="n">phase</span> <span class="k">case</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storeBoundaryFluxes</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">vW</span><span class="p">,</span> <span class="n">vO</span><span class="p">,</span> <span class="n">vG</span><span class="p">,</span> <span class="n">forces</span><span class="p">);</span>
<span class="c">% Only water and gas in model:</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storeBoundaryFluxes</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">vW</span><span class="p">,</span> <span class="p">[],</span> <span class="n">vG</span><span class="p">,</span> <span class="n">forces</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>vW</strong> – Water fluxes, one value per BC interface.</p></li>
<li><p><strong>vO</strong> – Oil fluxes, one value per BC interface.</p></li>
<li><p><strong>vG</strong> – Gas fluxes, one value per BC interface.</p></li>
<li><p><strong>forces</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">drivingForces</span></code> struct containing any boundary
conditions used to obtain fluxes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – State with stored values</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">storeFluxes</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.storeDensity">
<span class="sig-name descname"><span class="pre">storeDensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">rhoW</span></em>, <em class="sig-param"><span class="pre">rhoO</span></em>, <em class="sig-param"><span class="pre">rhoG</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.storeDensity" title="Permalink to this definition"></a></dt>
<dd><p>Store phase densities per-cell in state.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Three</span><span class="o">-</span><span class="n">phase</span> <span class="k">case</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storeDensity</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rhoW</span><span class="p">,</span> <span class="n">rhoO</span><span class="p">,</span> <span class="n">rhoG</span><span class="p">);</span>
<span class="c">% Only water and gas in model:</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storeDensity</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">rhoW</span><span class="p">,</span> <span class="p">[],</span> <span class="n">rhoG</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>rhoW</strong> – Water densities, one value per internal interface.</p></li>
<li><p><strong>rhoO</strong> – Oil densities, one value per internal interface.</p></li>
<li><p><strong>rhoG</strong> – Gas densities, one value per internal interface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – State with stored values</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">storeMobilities</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.storeFluxes">
<span class="sig-name descname"><span class="pre">storeFluxes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">vW</span></em>, <em class="sig-param"><span class="pre">vO</span></em>, <em class="sig-param"><span class="pre">vG</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.storeFluxes" title="Permalink to this definition"></a></dt>
<dd><p>Store integrated internal phase fluxes in state.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Three</span><span class="o">-</span><span class="n">phase</span> <span class="k">case</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storeFluxes</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">vW</span><span class="p">,</span> <span class="n">vO</span><span class="p">,</span> <span class="n">vG</span><span class="p">);</span>
<span class="c">% Only water and gas in model:</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storeFluxes</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">vW</span><span class="p">,</span> <span class="p">[],</span> <span class="n">vG</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>vW</strong> – Water fluxes, one value per internal interface.</p></li>
<li><p><strong>vO</strong> – Oil fluxes, one value per internal interface.</p></li>
<li><p><strong>vG</strong> – Gas fluxes, one value per internal interface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – State with stored values</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">storeBoundaryFluxes</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.storeMobilities">
<span class="sig-name descname"><span class="pre">storeMobilities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">mobW</span></em>, <em class="sig-param"><span class="pre">mobO</span></em>, <em class="sig-param"><span class="pre">mobG</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.storeMobilities" title="Permalink to this definition"></a></dt>
<dd><p>Store phase mobility per-cell in state.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Three</span><span class="o">-</span><span class="n">phase</span> <span class="k">case</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storebfactors</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">mobW</span><span class="p">,</span> <span class="n">mobO</span><span class="p">,</span> <span class="n">mobG</span><span class="p">);</span>
<span class="c">% Only water and gas in model:</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storebfactors</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">mobW</span><span class="p">,</span> <span class="p">[],</span> <span class="n">mobG</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>mobW</strong> – Water mobilities, one value per internal interface.</p></li>
<li><p><strong>mobO</strong> – Oil mobilities, one value per internal interface.</p></li>
<li><p><strong>mobG</strong> – Gas mobilities, one value per internal interface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – State with stored values</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">storeMobilities</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.storeUpstreamIndices">
<span class="sig-name descname"><span class="pre">storeUpstreamIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">upcw</span></em>, <em class="sig-param"><span class="pre">upco</span></em>, <em class="sig-param"><span class="pre">upcg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.storeUpstreamIndices" title="Permalink to this definition"></a></dt>
<dd><p>Store upstream indices for each phase in state.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Three</span><span class="o">-</span><span class="n">phase</span> <span class="k">case</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storeUpstreamIndices</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">upcw</span><span class="p">,</span> <span class="n">upco</span><span class="p">,</span> <span class="n">upcg</span><span class="p">);</span>
<span class="c">% Only water and gas in model:</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storeUpstreamIndices</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">upcw</span><span class="p">,</span> <span class="p">[],</span> <span class="n">upcg</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>upcw</strong> – Water upwind indicator, one value per internal
interface.</p></li>
<li><p><strong>upco</strong> – Oil upwind indicator, one value per internal
interface.</p></li>
<li><p><strong>upcg</strong> – Gas upwind indicator, one value per internal
interface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – State with stored values</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">storeBoundaryFluxes</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">storeFluxes</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.storebfactors">
<span class="sig-name descname"><span class="pre">storebfactors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">bW</span></em>, <em class="sig-param"><span class="pre">bO</span></em>, <em class="sig-param"><span class="pre">bG</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.storebfactors" title="Permalink to this definition"></a></dt>
<dd><p>Store phase reciprocal FVF per-cell in state.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Three</span><span class="o">-</span><span class="n">phase</span> <span class="k">case</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storebfactors</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bW</span><span class="p">,</span> <span class="n">bO</span><span class="p">,</span> <span class="n">bG</span><span class="p">);</span>
<span class="c">% Only water and gas in model:</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">storebfactors</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bW</span><span class="p">,</span> <span class="p">[],</span> <span class="n">bG</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>bW</strong> – Water reciprocal FVF, one value per internal interface.</p></li>
<li><p><strong>bO</strong> – Oil reciprocal FVF, one value per internal interface.</p></li>
<li><p><strong>bG</strong> – Gas reciprocal FVF, one value per internal interface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – State with stored values</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">storeDensities</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.updateAfterConvergence">
<span class="sig-name descname"><span class="pre">updateAfterConvergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.updateAfterConvergence" title="Permalink to this definition"></a></dt>
<dd><p>Generic update function for reservoir models containing wells.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.updateAfterConvergence" title="ad_core.models.PhysicalModel.updateAfterConvergence"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.updateAfterConvergence</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.updateForChangedControls">
<span class="sig-name descname"><span class="pre">updateForChangedControls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">forces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.updateForChangedControls" title="Permalink to this definition"></a></dt>
<dd><p>Called whenever controls change.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The addition this class makes is also updating the well
solution and the underlying <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.updateForChangedControls" title="ad_core.models.PhysicalModel.updateForChangedControls"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.updateForChangedControls</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.updateSaturations">
<span class="sig-name descname"><span class="pre">updateSaturations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">satVars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.updateSaturations" title="Permalink to this definition"></a></dt>
<dd><p>Update of phase-saturations</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">updateSaturations</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="n">satVars</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Update saturations (likely state.s) under the constraint that
the sum of volume fractions is always equal to 1. This
assumes that we have solved for n - 1 phases when n phases
are present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance</p></li>
<li><p><strong>state</strong> – State to be updated</p></li>
<li><p><strong>dx</strong> – Cell array of increments, some of which correspond
to saturations</p></li>
<li><p><strong>problem</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblemAD</span></code> class instance from which <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dx</span></code>
was obtained.</p></li>
<li><p><strong>satVars</strong> – Cell array with the names of the saturation
variables.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – Updated state with saturations within physical
constraints.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">splitPrimaryVariables</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.updateState">
<span class="sig-name descname"><span class="pre">updateState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.updateState" title="Permalink to this definition"></a></dt>
<dd><p>Generic update function for reservoir models containing wells.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.updateState" title="ad_core.models.PhysicalModel.updateState"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.updateState</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.validateModel">
<span class="sig-name descname"><span class="pre">validateModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.validateModel" title="Permalink to this definition"></a></dt>
<dd><p>Validate model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.validateModel" title="ad_core.models.PhysicalModel.validateModel"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.validateModel</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.validateState">
<span class="sig-name descname"><span class="pre">validateState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.ReservoirModel.validateState" title="Permalink to this definition"></a></dt>
<dd><p>Validate initial state.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.validateState" title="ad_core.models.PhysicalModel.validateState"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.validateState</span></code></a></p>
</div>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.AquiferModel">
<span class="sig-name descname"><span class="pre">AquiferModel</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.AquiferModel" title="Permalink to this definition"></a></dt>
<dd><p>Model used to represent aquifers</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.FacilityModel">
<span class="sig-name descname"><span class="pre">FacilityModel</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.FacilityModel" title="Permalink to this definition"></a></dt>
<dd><p>Facility model used to represent wells</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.FacilityNonLinearSolver">
<span class="sig-name descname"><span class="pre">FacilityNonLinearSolver</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.FacilityNonLinearSolver" title="Permalink to this definition"></a></dt>
<dd><p>Nonlinear solver used when wells are solved separately</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.FlowDiscretization">
<span class="sig-name descname"><span class="pre">FlowDiscretization</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.FlowDiscretization" title="Permalink to this definition"></a></dt>
<dd><p>Grouping for flux discretization</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.FlowPropertyFunctions">
<span class="sig-name descname"><span class="pre">FlowPropertyFunctions</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.FlowPropertyFunctions" title="Permalink to this definition"></a></dt>
<dd><p>Grouping for flow properties</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.PVTPropertyFunctions">
<span class="sig-name descname"><span class="pre">PVTPropertyFunctions</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.PVTPropertyFunctions" title="Permalink to this definition"></a></dt>
<dd><p>Grouping for PVT properties</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.dpMaxAbs">
<span class="sig-name descname"><span class="pre">dpMaxAbs</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.dpMaxAbs" title="Permalink to this definition"></a></dt>
<dd><p>Maximum absolute pressure change</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.dpMaxRel">
<span class="sig-name descname"><span class="pre">dpMaxRel</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.dpMaxRel" title="Permalink to this definition"></a></dt>
<dd><p>Maximum relative pressure change</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.dsMaxAbs">
<span class="sig-name descname"><span class="pre">dsMaxAbs</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.dsMaxAbs" title="Permalink to this definition"></a></dt>
<dd><p>Maximum absolute saturation change</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.extraStateOutput">
<span class="sig-name descname"><span class="pre">extraStateOutput</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.extraStateOutput" title="Permalink to this definition"></a></dt>
<dd><p>Write extra data to states. Depends on submodel type.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.extraWellSolOutput">
<span class="sig-name descname"><span class="pre">extraWellSolOutput</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.extraWellSolOutput" title="Permalink to this definition"></a></dt>
<dd><p>Output extra data to wellSols: GOR, WOR, …</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.fluid">
<span class="sig-name descname"><span class="pre">fluid</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.fluid" title="Permalink to this definition"></a></dt>
<dd><p>The fluid model. See <a class="reference internal" href="ad-props.html#ad_props.initSimpleADIFluid" title="ad_props.initSimpleADIFluid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initSimpleADIFluid</span></code></a>, <a class="reference internal" href="ad-props.html#ad_props.props.initDeckADIFluid" title="ad_props.props.initDeckADIFluid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initDeckADIFluid</span></code></a></p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.gas">
<span class="sig-name descname"><span class="pre">gas</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.gas" title="Permalink to this definition"></a></dt>
<dd><p>Indicator showing if the vapor/gas phase is present</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.gravity">
<span class="sig-name descname"><span class="pre">gravity</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.gravity" title="Permalink to this definition"></a></dt>
<dd><p>Vector for the gravitational force</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.inputdata">
<span class="sig-name descname"><span class="pre">inputdata</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.inputdata" title="Permalink to this definition"></a></dt>
<dd><p>Input data used to instantiate the model</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.maximumPressure">
<span class="sig-name descname"><span class="pre">maximumPressure</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.maximumPressure" title="Permalink to this definition"></a></dt>
<dd><p>Maximum pressure allowed in reservoir</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.minimumPressure">
<span class="sig-name descname"><span class="pre">minimumPressure</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.minimumPressure" title="Permalink to this definition"></a></dt>
<dd><p>Minimum pressure allowed in reservoir</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.oil">
<span class="sig-name descname"><span class="pre">oil</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.oil" title="Permalink to this definition"></a></dt>
<dd><p>Indicator showing if the liquid/oil phase is present</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.outputFluxes">
<span class="sig-name descname"><span class="pre">outputFluxes</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.outputFluxes" title="Permalink to this definition"></a></dt>
<dd><p>Store integrated fluxes in state.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.rock">
<span class="sig-name descname"><span class="pre">rock</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.rock" title="Permalink to this definition"></a></dt>
<dd><p>The rock structure (perm/poro/ntg). See <a class="reference internal" href="core.html#core.params.rock.makeRock" title="core.params.rock.makeRock"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeRock</span></code></a>.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.useCNVConvergence">
<span class="sig-name descname"><span class="pre">useCNVConvergence</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.useCNVConvergence" title="Permalink to this definition"></a></dt>
<dd><p>Use volume-scaled tolerance scheme</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.ReservoirModel.water">
<span class="sig-name descname"><span class="pre">water</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.ReservoirModel.water" title="Permalink to this definition"></a></dt>
<dd><p>Indicator showing if the aqueous/water phase is present</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.models.WrapperModel">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">WrapperModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">parentModel</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.WrapperModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ad_core.models.PhysicalModel" title="ad_core.models.PhysicalModel"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">PhysicalModel</span></code></a></p>
<p>Wrapper model which can be inherited for operations on the parent
model.</p>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.WrapperModel.prepareReportstep">
<span class="sig-name descname"><span class="pre">prepareReportstep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.WrapperModel.prepareReportstep" title="Permalink to this definition"></a></dt>
<dd><p>Prepare state and model (temporarily) before solving a report-step</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.WrapperModel.prepareTimestep">
<span class="sig-name descname"><span class="pre">prepareTimestep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.WrapperModel.prepareTimestep" title="Permalink to this definition"></a></dt>
<dd><p>Prepare state and model (temporarily) before solving a time-step</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ad_core.models.facilities">
<span id="facility-and-wells"></span><h3>Facility and wells<a class="headerlink" href="#module-ad_core.models.facilities" title="Permalink to this headline"></a></h3>
<dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.models.facilities.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.models.facilities.Contents" title="Permalink to this definition"></a></dt>
<dd><p>FACILITIES</p>
<dl class="simple">
<dt>Files</dt><dd><p>combineMSwithRegularWells           - Combine regular and MS wells, accounting for missing fields
computeWellContributionsSingleWell  - Main internal function for computing well equations and source terms
GenericFacilityModel                -
FacilityModel                       - A model coupling facilities and wells to the reservoir
MultisegmentWell                    - Derived class implementing multisegment wells
nozzleValve                         - Nozzle valve model
packPerforationProperties           - Extract variables corresponding to a specific well
selectFacilityFromDeck              - Pick FacilityModel from input deck
setupMSWellEquationSingleWell       - Setup well residual equations for multi-segmented wells - and only those.
setupWellControlEquationsSingleWell - Setup well controll (residual) equations
SimpleWell                          - Base class implementing a single, instantaneous equilibrium well model
unpackPerforationProperties         - Unpack the properties extracted by packPerforationProperties. Internal function.
wellBoreFriction                    - Empricial model for well-bore friction
UniformFacilityModel                - Simplified facility model which is sometimes faster
reorderWellPerforationsByDepth      - Undocumented Utility Function</p>
</dd>
</dl>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">FacilityModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ad_core.models.PhysicalModel" title="ad_core.models.PhysicalModel"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">PhysicalModel</span></code></a></p>
<p>A model coupling facilities and wells to the reservoir</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="p">=</span> <span class="n">FacilityModel</span><span class="p">(</span><span class="n">reservoirModel</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>The <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> is the layer between a <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code> and the
facilities. The facilities consist of a number of different wells
that are implemented in their own subclasses.</p>
<p>Different wells have different governing equations, primary
variables and convergence criterions. This class seamlessly handles
wells appearing and disappearing, controls changing and even well
type changing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>resModel</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code> derived class the facilities are
coupled to.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘property’</strong> – Set property to the specified value.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SimpleWell</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.checkFacilityConvergence">
<span class="sig-name descname"><span class="pre">checkFacilityConvergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">problem</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.checkFacilityConvergence" title="Permalink to this definition"></a></dt>
<dd><p>Check if facility and submodels has converged</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">convergence</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">evaluated</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span> <span class="n">checkFacilityConvergence</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance.</p></li>
<li><p><strong>problem</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblemAD</span></code> to be checked for
convergence.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>conv</strong> – Array of convergence flags for all tests.</p></li>
<li><p><strong>vals</strong> – Values checked to obtain <code class="xref mat mat-func docutils literal notranslate"><span class="pre">conv</span></code>.</p></li>
<li><p><strong>names</strong> – The names of the convergence checks/equations.</p></li>
<li><p><strong>eval</strong> – Logical array into problem.equations indicating which
residual equations we have actually checked
convergence for.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getActiveWellCells">
<span class="sig-name descname"><span class="pre">getActiveWellCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getActiveWellCells" title="Permalink to this definition"></a></dt>
<dd><p>Get the perforated cells in active wells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wc</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getActiveWellCells</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Facility model class instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wc</strong> – Array of well cells that are active, and belong to
active wells.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getAllPrimaryVariables">
<span class="sig-name descname"><span class="pre">getAllPrimaryVariables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getAllPrimaryVariables" title="Permalink to this definition"></a></dt>
<dd><p>Get all primary variables (basic + extra)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">variables</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">wellmap</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getAllPrimaryVariables</span><span class="p">(</span><span class="n">wellSol</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Gets all primary variables, both basic (rates, bhp) and added
variables (added by different wells and from the model
itself).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance</p></li>
<li><p><strong>wellSol</strong> – The wellSol struct</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>names</strong> – Cell array. Each cell is a string with the name
of an variable.</p></li>
<li><p><strong>variables</strong> – Column of cells. Each element, variables{i}, is a vector given
the value corresponding to variable with name
names{i}. This vector is composed of stacked values
over all the wells that contains this variable.</p></li>
<li><p><strong>wellmap</strong> – A combined struct containing mappings for both
the standard and extra primary variables.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getBasicPrimaryVariables</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getExtraPrimaryVariables</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getBasicPrimaryVariableNames">
<span class="sig-name descname"><span class="pre">getBasicPrimaryVariableNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getBasicPrimaryVariableNames" title="Permalink to this definition"></a></dt>
<dd><p>Get the names of the basic primary variables present in all wells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">names</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getBasicPrimaryVariableNames</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get a list of the basic names of primary variables that will
be required to solve a problem with the current set of wells.
The basic primary variables are always present in MRST, and
correspond to the phase rates for each phase present, as
well as the bottom-hole pressures. This ensures that all
solvers have a minimum feature set for well controls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>names</strong> – Cell array of the names of the basic primary
variables.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getBasicPrimaryVariables">
<span class="sig-name descname"><span class="pre">getBasicPrimaryVariables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getBasicPrimaryVariables" title="Permalink to this definition"></a></dt>
<dd><p>Get the basic primary variables common to all well models.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">vars</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">map</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getBasicPrimaryVariables</span><span class="p">(</span><span class="n">wellSol</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get phase rates for the active phases and the bhp.
In addition, the map contains indicators used to
find the phase rates and BHP values in “variables”
since these are of special importance to many
applications and are considered canonical (i.e. they
are always solution variables in MRST, and functions
can assume that they will always be found in the
variable set for wells).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>variables</strong> – Cell array of the primary variables.</p></li>
<li><p><strong>names</strong> – Cell array with the names of the primary
variables.</p></li>
<li><p><strong>map</strong> – Struct with details on which variables
correspond to ordered phase rates and the
bottom hole pressures.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getEquations">
<span class="sig-name descname"><span class="pre">getEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getEquations" title="Permalink to this definition"></a></dt>
<dd><p>Get stand-alone equations for the wells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">problem</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getEquations</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">drivingForces</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>The well equations can be solved as a separate nonlinear
system with the reservoir as a fixed quantity. This is
useful for debugging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> instance.</p></li>
<li><p><strong>wellSol0</strong> – wellSol struct at previous time-step.</p></li>
<li><p><strong>wellSol</strong> – wellSol struct at current time-step.</p></li>
<li><p><strong>dt</strong> – Time-step.</p></li>
<li><p><strong>forces</strong> – Forces struct for the wells.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘resOnly’</strong> – If supported by the equations, this flag will
result in only the values of the equations being
computed, omitting any Jacobians.</p></li>
<li><p><strong>‘iteration’</strong> – The nonlinear iteration number. This can be
provided so that the underlying equations can
account for the progress of the nonlinear
solution process in a limited degree, for example
by updating some quantities only at the first
iteration.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>problem</strong> – Instance of the wrapper class <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblemAD</span></code>
containing the residual equations as well as
other useful information.</p></li>
<li><p><strong>state</strong> – The equations are allowed to modify the system
state, allowing a limited caching of expensive
calculations only performed when necessary.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getExtraPrimaryVariables">
<span class="sig-name descname"><span class="pre">getExtraPrimaryVariables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getExtraPrimaryVariables" title="Permalink to this definition"></a></dt>
<dd><p>Get additional primary variables (not in the basic set)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">variables</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">wellmap</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getExtraPrimaryVariables</span><span class="p">(</span><span class="n">wellSol</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get extra primary variables are variables required by more
advanced wells that are in addition to the basic facility
variables (rates + bhp).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance</p></li>
<li><p><strong>wellSol</strong> – The wellSol struct</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>names</strong> – Column of cells. Each cell is a string with the name
of an extra-variable.</p></li>
<li><p><strong>variables</strong> – Column of cells. Each element, variables{i}, is a vector given
the value corresponding to extra-variable with name
names{i}. This vector is composed of stacked values
over all the wells that contains this extra-variable.</p></li>
<li><p><strong>wellmap</strong> – The facility model contains the extra-variables of all
the well models that are used. Let us consider the well
with well number wno (in the set of active wells), then
the Well model is belongs to has its own
extra-variables (a subset of those of the Facility
model). We consider the j-th extra-variable of
the Well model. Then, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">extraMap(wno,</span> <span class="pre">j)</span></code>
says that this extra-variable corresponds to
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">names{i}</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getBasicPrimaryVariables</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getIndicesOfActiveWells">
<span class="sig-name descname"><span class="pre">getIndicesOfActiveWells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getIndicesOfActiveWells" title="Permalink to this definition"></a></dt>
<dd><p>Get indices of active wells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">actIx</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getIndicesOfActiveWells</span><span class="p">(</span><span class="n">wellSol</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance</p></li>
<li><p><strong>wellSol</strong> – The wellSol struct</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>actIx</strong> – The indices of the active wells in the global list
of all wells (active &amp; inactive)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getNumberOfActiveWells">
<span class="sig-name descname"><span class="pre">getNumberOfActiveWells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getNumberOfActiveWells" title="Permalink to this definition"></a></dt>
<dd><p>Get number of wells active initialized in facility</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getNumberOfActiveWells</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nwell</strong> – Number of active wells</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getNumberOfWells">
<span class="sig-name descname"><span class="pre">getNumberOfWells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getNumberOfWells" title="Permalink to this definition"></a></dt>
<dd><p>Get number of wells initialized in facility</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getNumberOfWells</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nwell</strong> – Number of wells</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getPrimaryVariableNames">
<span class="sig-name descname"><span class="pre">getPrimaryVariableNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getPrimaryVariableNames" title="Permalink to this definition"></a></dt>
<dd><p>Get the names of primary variables present in all wells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">names</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getPrimaryVariableNames</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get a list of the names of primary variables that will be
required to solve a problem with the current set of wells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>names</strong> – Cell array of the names of the primary variables.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getProp">
<span class="sig-name descname"><span class="pre">getProp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">facility</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getProp" title="Permalink to this definition"></a></dt>
<dd><p>Helper function to get (possible) control values for all
active wells. This function will always prioritize primary
variables (AD status) over doubles used for controls.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getValidDrivingForces">
<span class="sig-name descname"><span class="pre">getValidDrivingForces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getValidDrivingForces" title="Permalink to this definition"></a></dt>
<dd><p>Get valid driving forces.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.getValidDrivingForces" title="ad_core.models.PhysicalModel.getValidDrivingForces"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.getValidDrivingForces</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getWellCells">
<span class="sig-name descname"><span class="pre">getWellCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">subs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getWellCells" title="Permalink to this definition"></a></dt>
<dd><p>Get the perforated cells of all wells, regardless of status</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wc</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getWellCells</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Facility model class instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wc</strong> – Array of well cells</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getWellContributions">
<span class="sig-name descname"><span class="pre">getWellContributions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">wellvars</span></em>, <em class="sig-param"><span class="pre">wellMap</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">mob</span></em>, <em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">dissolved</span></em>, <em class="sig-param"><span class="pre">comp</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">iteration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getWellContributions" title="Permalink to this definition"></a></dt>
<dd><p>Get sources, well equations and updated wellSol</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">sources</span><span class="p">,</span> <span class="n">wellSystem</span><span class="p">,</span> <span class="n">wellSol</span><span class="p">]</span> <span class="p">=</span> <span class="n">fm</span><span class="p">.</span><span class="n">getWellContributions</span><span class="p">(...</span>
<span class="n">wellSol0</span><span class="p">,</span> <span class="n">wellSol</span><span class="p">,</span> <span class="n">wellvars</span><span class="p">,</span> <span class="n">wellMap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">mob</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">dissolved</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">iteration</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get the source terms due to the wells, control and well
equations and updated well sol. Main gateway for adding wells
to a set of equations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Facility model class instance.</p></li>
<li><p><strong>wellSol0</strong> – wellSol struct at previous time-step.</p></li>
<li><p><strong>wellSol</strong> – wellSol struct at current time-step.</p></li>
<li><p><strong>wellvars</strong> – Well variables. Output from
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">getAllPrimaryVariables</span></code>.</p></li>
<li><p><strong>wellMap</strong> – Well mapping. Output from
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">getAllPrimaryVariables</span></code>.</p></li>
<li><p><strong>p</strong> – Pressure defined in all cells of the underlying
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code>. Normally, this is the oil
pressure.</p></li>
<li><p><strong>mob</strong> – Cell array of phase mobilities defined in all
cells of the reservoir.</p></li>
<li><p><strong>rho</strong> – Cell array of phase densities defined in all
cells of the reservoir.</p></li>
<li><p><strong>dissolved</strong> – Black-oil style dissolution. See
<code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_blackoil.models.ThreePhaseBlackoilModel.getDissolutionMatrix</span></code>.</p></li>
<li><p><strong>comp</strong> – Cell array of components in the reservoir.</p></li>
<li><p><strong>dt</strong> – The time-step.</p></li>
<li><p><strong>iteration</strong> – The current nonlinear iteration for which the
sources are to be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>sources</strong> – Struct containing source terms for phases,
components and the corresponding cells.</p></li>
<li><p><strong>wellSystem</strong> – Struct containing the well equations
(reservoir to wellbore, and
control-equations).</p></li>
<li><p><strong>wellSol</strong> – Updated wellSol struct.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getWellStatusMask">
<span class="sig-name descname"><span class="pre">getWellStatusMask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getWellStatusMask" title="Permalink to this definition"></a></dt>
<dd><p>Get status mask for active wells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">act</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getWellStatusMask</span><span class="p">(</span><span class="n">wellSol</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get the well status of all wells. The status is true if the
well is present and active. Wells can be disabled in two
ways: Their status flag can be set to false in the well
struct, or the wellSol.status flag can be set to false by
the simulator itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance</p></li>
<li><p><strong>wellSol</strong> – The wellSol struct</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>act</strong> – Array with equal length to the total number of
wells, with booleans indicating if a specific well
is currently active.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getWellStruct">
<span class="sig-name descname"><span class="pre">getWellStruct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">subs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getWellStruct" title="Permalink to this definition"></a></dt>
<dd><p>Get the well struct representing the current set of wells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getWellStruct</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>W</strong> – Standard well struct.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.getWellVariableMap">
<span class="sig-name descname"><span class="pre">getWellVariableMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wf</span></em>, <em class="sig-param"><span class="pre">ws</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.getWellVariableMap" title="Permalink to this definition"></a></dt>
<dd><p>Get mapping indicating which variable belong to each well</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">isVarWell</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">getWellVariableMap</span><span class="p">(</span><span class="s">&#39;someVar&#39;</span><span class="p">,</span> <span class="n">wellSol</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Class instance of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code></p></li>
<li><p><strong>wf</strong> – String of variable for which the mapping will be
generated.</p></li>
<li><p><strong>ws</strong> – Current wellSol.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>isVarWell</strong> – Array equal in length to the total number of
variables with name <code class="xref mat mat-func docutils literal notranslate"><span class="pre">wf</span></code>. The entries
correspond to which well owns that specific
variable number. This allows multiple wells to
have for example bottom-hole pressures as a
variable, without having to split them up by
name in the reservoir equations.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.handleRepeatedPerforatedcells">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">handleRepeatedPerforatedcells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">wc</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.handleRepeatedPerforatedcells" title="Permalink to this definition"></a></dt>
<dd><p>Handle multiple wells perforated in the same cells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">wc</span><span class="p">,</span> <span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">]</span> <span class="p">=</span> <span class="n">handleRepeatedPerforatedcells</span><span class="p">(</span><span class="n">wc</span><span class="p">,</span> <span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function treats repeated indices in wc (typically due to
multiple wells intersecting a single cell). The output will
have no repeats in wc, and add together any terms in cqs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wc</strong> – Well cells with possible repeats.</p></li>
<li><p><strong>varargin</strong> – Any number of arrays that should be processed
to account for repeated entries.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>wc</strong> – Well cells with repeats removed.</p></li>
<li><p><strong>varargout</strong> – Variable inputs processed to fix repeated
indices.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.setWellSolStatistics">
<span class="sig-name descname"><span class="pre">setWellSolStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">ws</span></em>, <em class="sig-param"><span class="pre">sources</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.setWellSolStatistics" title="Permalink to this definition"></a></dt>
<dd><p>Add statistics to wellSol (wcut, gor, …)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wellSol</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">setWellSolStatistics</span><span class="p">(</span><span class="n">wellSol</span><span class="p">,</span> <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Facility model class instance.</p></li>
<li><p><strong>wellSol</strong> – wellSol struct at current time-step.</p></li>
<li><p><strong>sources</strong> – Source struct from <code class="xref mat mat-func docutils literal notranslate"><span class="pre">getWellContributions</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wellSol</strong> – Updated wellSol struct where additional useful
information has been added</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.setupWells">
<span class="sig-name descname"><span class="pre">setupWells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">wellmodels</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.setupWells" title="Permalink to this definition"></a></dt>
<dd><p>Set up well models for changed controls or the first
simulation step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>W</strong> – Well struct (obtained from e.g. <a class="reference internal" href="core.html#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a> or
<a class="reference internal" href="deckformat.html#deckformat.params.wells_and_bc.processWells" title="deckformat.params.wells_and_bc.processWells"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processWells</span></code></a>)</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>wellmodels</strong> – Cell array of equal length to W, containing class
instances for each well (e.g. <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SimpleWell</span></code>,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">MultisegmentWell</span></code>, or classes derived from
these).  If not provided, well models be
constructed from the input.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – Updated <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code> instance ready for use with
wells of type <code class="xref mat mat-func docutils literal notranslate"><span class="pre">W</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.updateAfterConvergence">
<span class="sig-name descname"><span class="pre">updateAfterConvergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.updateAfterConvergence" title="Permalink to this definition"></a></dt>
<dd><p>Generic update function for reservoir models containing wells.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.updateAfterConvergence" title="ad_core.models.PhysicalModel.updateAfterConvergence"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.updateAfterConvergence</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.updateState">
<span class="sig-name descname"><span class="pre">updateState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.updateState" title="Permalink to this definition"></a></dt>
<dd><p>Update state.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.updateState" title="ad_core.models.PhysicalModel.updateState"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.updateState</span></code></a></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.updateWellSol">
<span class="sig-name descname"><span class="pre">updateWellSol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em>, <em class="sig-param"><span class="pre">restVars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.updateWellSol" title="Permalink to this definition"></a></dt>
<dd><p>Update the wellSol based on increments</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">wellSol</span><span class="p">,</span> <span class="n">restVars</span><span class="p">]</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">updateWellSol</span><span class="p">(</span><span class="n">wellSol</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">forces</span><span class="p">,</span> <span class="n">restVars</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Facility model class instance</p></li>
<li><p><strong>wellSol</strong> – Well solution struct</p></li>
<li><p><strong>problem</strong> – Linearized problem used to produce dx.</p></li>
<li><p><strong>dx</strong> – Increments corresponding to
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">problem.primaryVariables</span></code></p></li>
<li><p><strong>forces</strong> – Boundary condition struct</p></li>
<li><p><strong>restVars</strong> – Variables that have not yet been updated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>state</strong> – Updated Well solution struct</p></li>
<li><p><strong>restVars</strong> – Variables that have not yet been updated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.updateWellSolAfterStep">
<span class="sig-name descname"><span class="pre">updateWellSolAfterStep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.updateWellSolAfterStep" title="Permalink to this definition"></a></dt>
<dd><p>Update wellSol after step (check for closed wells, etc)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wellSol</span> <span class="p">=</span> <span class="n">model</span><span class="p">.</span><span class="n">updateWellSolAfterStep</span><span class="p">(</span><span class="n">wellSol</span><span class="p">,</span> <span class="n">wellSol0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Facility model class instance.</p></li>
<li><p><strong>wellSol0</strong> – wellSol struct at previous time-step.</p></li>
<li><p><strong>wellSol</strong> – wellSol struct at current time-step.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wellSol</strong> – Updated wellSol struct.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.validateState">
<span class="sig-name descname"><span class="pre">validateState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.validateState" title="Permalink to this definition"></a></dt>
<dd><p>Validate state.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.models.PhysicalModel.validateState" title="ad_core.models.PhysicalModel.validateState"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">ad_core.models.PhysicalModel.validateState</span></code></a></p>
</div>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.FacilityFlowDiscretization">
<span class="sig-name descname"><span class="pre">FacilityFlowDiscretization</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.FacilityFlowDiscretization" title="Permalink to this definition"></a></dt>
<dd><p>Convergence tolerance for BHP-type controls</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.ReservoirModel">
<span class="sig-name descname"><span class="pre">ReservoirModel</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.ReservoirModel" title="Permalink to this definition"></a></dt>
<dd><p>The model instance the FacilityModel is coupled to</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.VFPTablesInjector">
<span class="sig-name descname"><span class="pre">VFPTablesInjector</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.VFPTablesInjector" title="Permalink to this definition"></a></dt>
<dd><p>Injector VFP Tables. EXPERIMENTAL.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.VFPTablesProducer">
<span class="sig-name descname"><span class="pre">VFPTablesProducer</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.VFPTablesProducer" title="Permalink to this definition"></a></dt>
<dd><p>Producer VFP Tables. EXPERIMENTAL.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.WellModels">
<span class="sig-name descname"><span class="pre">WellModels</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.WellModels" title="Permalink to this definition"></a></dt>
<dd><p>Cell array of instantiated wells</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.addedEquationNames">
<span class="sig-name descname"><span class="pre">addedEquationNames</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'{}'</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.addedEquationNames" title="Permalink to this definition"></a></dt>
<dd><p>Canonical list of additional equations</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.addedEquationTypes">
<span class="sig-name descname"><span class="pre">addedEquationTypes</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'{}'</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.addedEquationTypes" title="Permalink to this definition"></a></dt>
<dd><p>Canonical list of the types of the added equations</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.addedPrimaryVarNames">
<span class="sig-name descname"><span class="pre">addedPrimaryVarNames</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'{}'</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.addedPrimaryVarNames" title="Permalink to this definition"></a></dt>
<dd><p>Canonical list of all extra primary variables added by the wells</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.addedPrimaryVarNamesIsFromResModel">
<span class="sig-name descname"><span class="pre">addedPrimaryVarNamesIsFromResModel</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'[]'</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.addedPrimaryVarNamesIsFromResModel" title="Permalink to this definition"></a></dt>
<dd><p>Indicator, per primary variable, if it was added by the reservoir model (true) or if it is from the well itself (false)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.primaryVariableSet">
<span class="sig-name descname"><span class="pre">primaryVariableSet</span></span><em class="property"> <span class="pre">=</span> <span class="pre">&quot;'standard'&quot;</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.primaryVariableSet" title="Permalink to this definition"></a></dt>
<dd><p>Default: bhp + phase surface rates</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.setWellTargets">
<span class="sig-name descname"><span class="pre">setWellTargets</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'true'</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.setWellTargets" title="Permalink to this definition"></a></dt>
<dd><p>Explicitly wellSol values to imposed targets after each iteration</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.toleranceWellMS">
<span class="sig-name descname"><span class="pre">toleranceWellMS</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.toleranceWellMS" title="Permalink to this definition"></a></dt>
<dd><p>Convergence tolerance for multisegment wells</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.FacilityModel.toleranceWellRate">
<span class="sig-name descname"><span class="pre">toleranceWellRate</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.FacilityModel.toleranceWellRate" title="Permalink to this definition"></a></dt>
<dd><p>Convergence tolerance for rate-type controls</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.models.facilities.MultisegmentWell">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">MultisegmentWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.MultisegmentWell" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ad_core.models.facilities.SimpleWell" title="ad_core.models.facilities.SimpleWell"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">SimpleWell</span></code></a></p>
<p>Derived class implementing multisegment wells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wm</span> <span class="p">=</span> <span class="n">MultisegmentWell</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This well extends SimpleWell to general multisegment wells. These
wells can take on complex topological structures, including loops
for e.g. annular flow modelling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>W</strong> – Well struct. See <a class="reference internal" href="core.html#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a> and <a class="reference internal" href="deckformat.html#deckformat.params.wells_and_bc.processWells" title="deckformat.params.wells_and_bc.processWells"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processWells</span></code></a>. Should have been
converted into a multisegment well using <a class="reference internal" href="#ad_core.utils.convert2MSWell" title="ad_core.utils.convert2MSWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convert2MSWell</span></code></a>.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘property’</strong> – Set property to the specified value.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MultisegmentWell</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.utils.convert2MSWell" title="ad_core.utils.convert2MSWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convert2MSWell</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SimpleWell</span></code>,</p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.MultisegmentWell.computeWellEquations">
<span class="sig-name descname"><span class="pre">computeWellEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em>, <em class="sig-param"><span class="pre">q_s</span></em>, <em class="sig-param"><span class="pre">bh</span></em>, <em class="sig-param"><span class="pre">packed</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">iteration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.MultisegmentWell.computeWellEquations" title="Permalink to this definition"></a></dt>
<dd><p>Node pressures for the well</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.MultisegmentWell.ensureWellSolConsistency">
<span class="sig-name descname"><span class="pre">ensureWellSolConsistency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">ws</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.MultisegmentWell.ensureWellSolConsistency" title="Permalink to this definition"></a></dt>
<dd><p>#ok
guarantees that the sum of rW, rO, rG remains equal to one.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.MultisegmentWell.getVariableField">
<span class="sig-name descname"><span class="pre">getVariableField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.MultisegmentWell.getVariableField" title="Permalink to this definition"></a></dt>
<dd><p>Get the index/name mapping for the model (such as where
pressure or water saturation is located in state)</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">SimpleWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ad_core.models.PhysicalModel" title="ad_core.models.PhysicalModel"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">PhysicalModel</span></code></a></p>
<p>Base class implementing a single, instantaneous equilibrium well model</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wm</span> <span class="p">=</span> <span class="n">SimpleWell</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Base class for wells in the AD-OO framework. The base class is also
the default well implementation. For this will model, the
assumptions are that the well-bore flow is rapid compared to the
time-steps taken by the reservoir simulator, making instantaneous
equilibrium and mixing in the well-bore a reasonable assumption.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>W</strong> – Well struct. See <a class="reference internal" href="core.html#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a> and <a class="reference internal" href="deckformat.html#deckformat.params.wells_and_bc.processWells" title="deckformat.params.wells_and_bc.processWells"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processWells</span></code></a>.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘property’</strong> – Set property to the specified value.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – Class instance of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SimpleWell</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MultisegmentWell</span></code>,</p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.SimpleWell">
<span class="sig-name descname"><span class="pre">SimpleWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.SimpleWell" title="Permalink to this definition"></a></dt>
<dd><p>Class constructor</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.computeComponentContributions">
<span class="sig-name descname"><span class="pre">computeComponentContributions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em>, <em class="sig-param"><span class="pre">q_s</span></em>, <em class="sig-param"><span class="pre">bh</span></em>, <em class="sig-param"><span class="pre">packed</span></em>, <em class="sig-param"><span class="pre">qMass</span></em>, <em class="sig-param"><span class="pre">qVol</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">iteration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.computeComponentContributions" title="Permalink to this definition"></a></dt>
<dd><p>Compute component equations and component source terms</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad_core.models.ReservoirModel.getExtraWellContributions</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.computeWellEquations">
<span class="sig-name descname"><span class="pre">computeWellEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em>, <em class="sig-param"><span class="pre">q_s</span></em>, <em class="sig-param"><span class="pre">bh</span></em>, <em class="sig-param"><span class="pre">packed</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">iteration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.computeWellEquations" title="Permalink to this definition"></a></dt>
<dd><p>Compute well equations and well phase/pseudocomponent source terms</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.ensureWellSolConsistency">
<span class="sig-name descname"><span class="pre">ensureWellSolConsistency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">ws</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.ensureWellSolConsistency" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Run after the update step to ensure consistency of wellSol</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.getExtraEquationNames">
<span class="sig-name descname"><span class="pre">getExtraEquationNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.getExtraEquationNames" title="Permalink to this definition"></a></dt>
<dd><p>Returns the names and types of the additional equation names
this well model introduces.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">names</span><span class="p">,</span> <span class="n">types</span><span class="p">]</span> <span class="p">=</span> <span class="n">well</span><span class="p">.</span><span class="n">getExtraEquationNames</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>We have two options: Either the
well itself can add additional equations (modelling e.g. flow
in the well-bore) or the reservoir can add additional
equations (typically for additional components)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>well</strong> – Well class instance</p></li>
<li><p><strong>resmodel</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code> class instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>names</strong> – Names of additional equations.</p></li>
<li><p><strong>types</strong> – Type hints for the additional equations.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.getExtraPrimaryVariableNames">
<span class="sig-name descname"><span class="pre">getExtraPrimaryVariableNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.getExtraPrimaryVariableNames" title="Permalink to this definition"></a></dt>
<dd><p>Get additional primary variables added by this well.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">names</span><span class="p">,</span> <span class="n">fromRes</span><span class="p">]</span> <span class="p">=</span> <span class="n">well</span><span class="p">.</span><span class="n">getExtraPrimaryVariableNames</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Additional primary variables in this context are variables
that are not the default MRST values (surface rates for each
pseudocomponent/phase and bottomhole pressure).</p>
<p>In addition, this function returns a indicator per variable
if it was added by the reservoir model, or the well model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>well</strong> – Well class instance</p></li>
<li><p><strong>resmodel</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code> class instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>names</strong> – Names of additional primary variables.</p></li>
<li><p><strong>fromRes</strong> – Boolean array indicating if the added variables
originate from the well, or the reservoir.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.getExtraPrimaryVariables">
<span class="sig-name descname"><span class="pre">getExtraPrimaryVariables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.getExtraPrimaryVariables" title="Permalink to this definition"></a></dt>
<dd><p>Returns the values and names of extra primary variables added
by this well.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">names</span><span class="p">,</span> <span class="n">types</span><span class="p">]</span> <span class="p">=</span> <span class="n">well</span><span class="p">.</span><span class="n">getExtraEquationNames</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>well</strong> – Well class instance</p></li>
<li><p><strong>resmodel</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code> class instance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>vars</strong> – Cell array of extra primary variables</p></li>
<li><p><strong>names</strong> – Cell array with names of extra primary variables</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getExtraPrimaryVariableNames</span></code></p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.getVariableCounts">
<span class="sig-name descname"><span class="pre">getVariableCounts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">wm</span></em>, <em class="sig-param"><span class="pre">fld</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.getVariableCounts" title="Permalink to this definition"></a></dt>
<dd><p>Get number of primary variables of a specific type for well</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">counts</span> <span class="p">=</span> <span class="n">wellmodel</span><span class="p">.</span><span class="n">getVariableCounts</span><span class="p">(</span><span class="s">&#39;bhp&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Should return the number of primary variables added by this
well for field “fld”. The simple base class only uses a
single variable to represent any kind of well field, but in
e.g. <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MultisegmentWell</span></code>, this function may return values
larger than 1.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A value of zero should be returned for a unknown field.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wellmodel</strong> – Well model class instance.</p></li>
<li><p><strong>fld</strong> – Primary variable name.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>counts</strong> – Number of variables of this type required by the
well model.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.getWellEquationNames">
<span class="sig-name descname"><span class="pre">getWellEquationNames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.getWellEquationNames" title="Permalink to this definition"></a></dt>
<dd><p>Get the names and types for the well equations of the model.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.isInjector">
<span class="sig-name descname"><span class="pre">isInjector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.isInjector" title="Permalink to this definition"></a></dt>
<dd><p>Check if well is an injector</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">isInj</span> <span class="p">=</span> <span class="n">well</span><span class="p">.</span><span class="n">isInjector</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>well</strong> – Well class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>isInjector</strong> – boolean indicating if well is specified as an
injector. Wells with sign zero is in this
context defined as producers.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.updateConnectionPressureDrop">
<span class="sig-name descname"><span class="pre">updateConnectionPressureDrop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">q_s</span></em>, <em class="sig-param"><span class="pre">bhp</span></em>, <em class="sig-param"><span class="pre">packed</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">iteration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.updateConnectionPressureDrop" title="Permalink to this definition"></a></dt>
<dd><p>Update the pressure drop within the well bore, according to a
hydrostatic pressure distribution from the bottom-hole to the
individual perforations.</p>
<p>To avoid dense linear systems, this update only happens at
the start of each nonlinear loop.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.updateConnectionPressureDropState">
<span class="sig-name descname"><span class="pre">updateConnectionPressureDropState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">rho_res</span></em>, <em class="sig-param"><span class="pre">rho_well</span></em>, <em class="sig-param"><span class="pre">mob_res</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.updateConnectionPressureDropState" title="Permalink to this definition"></a></dt>
<dd><p>Simpler version</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.updateLimits">
<span class="sig-name descname"><span class="pre">updateLimits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">q_s</span></em>, <em class="sig-param"><span class="pre">bhp</span></em>, <em class="sig-param"><span class="pre">wellvars</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">mob</span></em>, <em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">dissolved</span></em>, <em class="sig-param"><span class="pre">comp</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">iteration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.updateLimits" title="Permalink to this definition"></a></dt>
<dd><p>Update solution variables and wellSol based on the well
limits. If limits have been reached, this function will
attempt to re-initialize the values and change the controls
so that the next step keeps within the prescribed ranges.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.updateWell">
<span class="sig-name descname"><span class="pre">updateWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">W</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.updateWell" title="Permalink to this definition"></a></dt>
<dd><p>Update well with a new control struct.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">well</span> <span class="p">=</span> <span class="n">well</span><span class="p">.</span><span class="n">updateWell</span><span class="p">(</span><span class="n">W</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Well model.</p></li>
<li><p><strong>W</strong> – Well struct representing the same wells, but with
changed controls, active perforations and so on.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>model</strong> – Updated well model.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.updateWellSol">
<span class="sig-name descname"><span class="pre">updateWellSol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">variables</span></em>, <em class="sig-param"><span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.updateWellSol" title="Permalink to this definition"></a></dt>
<dd><p>Update function for the wellSol struct</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.updateWellSolAfterStep">
<span class="sig-name descname"><span class="pre">updateWellSolAfterStep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.updateWellSolAfterStep" title="Permalink to this definition"></a></dt>
<dd><p>Updates the wellSol after a step is complete (book-keeping)</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.validateWellSol">
<span class="sig-name descname"><span class="pre">validateWellSol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em>, <em class="sig-param"><span class="pre">wsol</span></em>, <em class="sig-param"><span class="pre">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.validateWellSol" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Validate wellSol for simulation</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wellSol</span> <span class="p">=</span> <span class="n">well</span><span class="p">.</span><span class="n">validateWellSol</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">wellSol</span><span class="p">,</span> <span class="n">resSol</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Validate if wellSol is suitable for simulation. This function
may modify the wellSol if the errors are fixable at runtime,
otherwise it should throw an error. Note that this function
is analogous to validateState in the base model class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>well</strong> – Well model class instance.</p></li>
<li><p><strong>model</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code> class instance.</p></li>
<li><p><strong>wellSol</strong> – Well solution to be updated.</p></li>
<li><p><strong>resSol</strong> – Reservoir state</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wellSol</strong> – Updated well solution struct.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.VFPTable">
<span class="sig-name descname"><span class="pre">VFPTable</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.VFPTable" title="Permalink to this definition"></a></dt>
<dd><p>Vertical lift table. EXPERIMENTAL.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.W">
<span class="sig-name descname"><span class="pre">W</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.W" title="Permalink to this definition"></a></dt>
<dd><p>Struct defining the well (see <a class="reference internal" href="core.html#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a>)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.allowControlSwitching">
<span class="sig-name descname"><span class="pre">allowControlSwitching</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.allowControlSwitching" title="Permalink to this definition"></a></dt>
<dd><p>Limit reached results in well switching to another control</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.allowCrossflow">
<span class="sig-name descname"><span class="pre">allowCrossflow</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.allowCrossflow" title="Permalink to this definition"></a></dt>
<dd><p>Boolean indicating if the well perforations allow cross-flow</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.allowSignChange">
<span class="sig-name descname"><span class="pre">allowSignChange</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.allowSignChange" title="Permalink to this definition"></a></dt>
<dd><p>BHP-controlled well is allowed to switch between production and injection</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.dpMaxAbs">
<span class="sig-name descname"><span class="pre">dpMaxAbs</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.dpMaxAbs" title="Permalink to this definition"></a></dt>
<dd><p>Maximum allowable absolute change in well pressure</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.dpMaxRel">
<span class="sig-name descname"><span class="pre">dpMaxRel</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.dpMaxRel" title="Permalink to this definition"></a></dt>
<dd><p>Maximum allowable relative change in well pressure</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.models.facilities.SimpleWell.dsMaxAbs">
<span class="sig-name descname"><span class="pre">dsMaxAbs</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.models.facilities.SimpleWell.dsMaxAbs" title="Permalink to this definition"></a></dt>
<dd><p>Maximum allowable change in well composition/saturation</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.models.facilities.UniformFacilityModel">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">UniformFacilityModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.UniformFacilityModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ad_core.models.facilities.FacilityModel" title="ad_core.models.facilities.FacilityModel"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">FacilityModel</span></code></a></p>
<p>Simplified facility model which is sometimes faster</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.models.facilities.combineMSwithRegularWells">
<span class="sig-name descname"><span class="pre">combineMSwithRegularWells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W_regular</span></em>, <em class="sig-param"><span class="pre">W_ms</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.combineMSwithRegularWells" title="Permalink to this definition"></a></dt>
<dd><p>Combine regular and MS wells, accounting for missing fields</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.models.facilities.computeWellContributionsSingleWell">
<span class="sig-name descname"><span class="pre">computeWellContributionsSingleWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">wellmodel</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">resmodel</span></em>, <em class="sig-param"><span class="pre">q_s</span></em>, <em class="sig-param"><span class="pre">pBH</span></em>, <em class="sig-param"><span class="pre">packed</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.computeWellContributionsSingleWell" title="Permalink to this definition"></a></dt>
<dd><p>Main internal function for computing well equations and source terms</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.models.facilities.nozzleValve">
<span class="sig-name descname"><span class="pre">nozzleValve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">D</span></em>, <em class="sig-param"><span class="pre">dischargeCoeff</span></em>, <em class="sig-param"><span class="pre">flowtype</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.nozzleValve" title="Permalink to this definition"></a></dt>
<dd><p>Nozzle valve model</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.models.facilities.packPerforationProperties">
<span class="sig-name descname"><span class="pre">packPerforationProperties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">mob</span></em>, <em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">dissolved</span></em>, <em class="sig-param"><span class="pre">comp</span></em>, <em class="sig-param"><span class="pre">wellvars</span></em>, <em class="sig-param"><span class="pre">wellvarnames</span></em>, <em class="sig-param"><span class="pre">varmaps</span></em>, <em class="sig-param"><span class="pre">wellmap</span></em>, <em class="sig-param"><span class="pre">ix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.packPerforationProperties" title="Permalink to this definition"></a></dt>
<dd><p>Extract variables corresponding to a specific well</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">packed</span> <span class="p">=</span> <span class="n">packPerforationProperties</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">mob</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">dissolved</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">wellvars</span><span class="p">,</span> <span class="n">wellvarnames</span><span class="p">,</span> <span class="n">varmaps</span><span class="p">,</span> <span class="n">wellmap</span><span class="p">,</span> <span class="n">ix</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> – Well struct for the specific well under consideration.</p></li>
<li><p><strong>p</strong> – Reservoir pressure for all cells in the domain.</p></li>
<li><p><strong>mob</strong> – Cell array with phase mobilities in each cell in the
reservoir. Number of active phases long.</p></li>
<li><p><strong>rho</strong> – Cell array with phase densities in each cell in the
reservoir. Number of active phases long.</p></li>
<li><p><strong>dissolved</strong> – Black-oil specific array of rs/rv. See the function
ThreePhaseBlackOilModel&gt;getDissolutionMatrix
for details. Should be empty for models without dissolution
ratios.</p></li>
<li><p><strong>comp</strong> – Cell array of components. Each entry should contain all
reservoir cell values of that component, subject to whatever
ordering is natural for the model itself.</p></li>
<li><p><strong>wellvars</strong> – Extended variable set added by the FacilityModel (see
SimpleWell&gt;getExtraPrimaryVariables)</p></li>
<li><p><strong>wellvarnames</strong> – Internal book-keeping for</p></li>
<li><p><strong>varmaps</strong> – Internal book-keeping for</p></li>
<li><p><strong>wellmap</strong> – Internal book-keeping for</p></li>
<li><p><strong>ix</strong> – Internal book-keeping for</p></li>
<li><p><strong>variables.</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">additional</span> <span class="pre">added</span> <span class="pre">primary</span></code></span>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>packed</strong> – Struct where the values for the perforations of the well has
been extracted.</p>
</dd>
</dl>
<p>NOTE: This function is intended for internal use in FacilityModel.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>FacilityModel</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.models.facilities.reorderWellPerforationsByDepth">
<span class="sig-name descname"><span class="pre">reorderWellPerforationsByDepth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">active</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.reorderWellPerforationsByDepth" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.models.facilities.selectFacilityFromDeck">
<span class="sig-name descname"><span class="pre">selectFacilityFromDeck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deck</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.selectFacilityFromDeck" title="Permalink to this definition"></a></dt>
<dd><p>Pick FacilityModel from input deck</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.models.facilities.setupMSWellEquationSingleWell">
<span class="sig-name descname"><span class="pre">setupMSWellEquationSingleWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">wm</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol0</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">q_s</span></em>, <em class="sig-param"><span class="pre">bhp</span></em>, <em class="sig-param"><span class="pre">pN</span></em>, <em class="sig-param"><span class="pre">alpha</span></em>, <em class="sig-param"><span class="pre">vmix</span></em>, <em class="sig-param"><span class="pre">resProps</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">iteration</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.setupMSWellEquationSingleWell" title="Permalink to this definition"></a></dt>
<dd><p>Setup well residual equations for multi-segmented wells - and only those.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span>function [eqs, eqsMS, cq_s, mix_s, status, cstatus, cq_r] = setupMSWellEquations(wm, ...
                                                model, wellSol0, dt, bhp, q_s, pN, vmix, alpha, wellNo)
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wm</strong> – Simulation well model.</p></li>
<li><p><strong>model</strong> – Resservoir Simulation model.</p></li>
<li><p><strong>wellSol0</strong> – List of well solution structures from previous step</p></li>
<li><p><strong>dt</strong> – time step</p></li>
<li><p><strong>bhp</strong> – bottom hole pressure</p></li>
<li><p><strong>q_s</strong> – volumetric phase injection/production rate</p></li>
<li><p><strong>pN</strong> – pressure at nodes</p></li>
<li><p><strong>vmix</strong> – mixture mass flux in segments</p></li>
<li><p><strong>alpha</strong> – phase composition ratio at nodes</p></li>
<li><p><strong>wellNo</strong> – Well number identifying the well for which the equations are going to
be assembled (should correspond to a multisegmented well)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul>
<li><p><strong>eqs</strong> – <em>Standard</em> well equations: Cell array of mass balance equations at the connections
- 1 equation for each phase,</p></li>
<li><p><strong>eqsMS</strong> – multisegment well equations: Cell array of mass balance equations for
each node and of pressure equations</p>
<blockquote>
<div><ul class="simple">
<li><p>mass conservation equations for each phase,
Dimension for each equation: number of nodes - 1</p></li>
<li><p>pressure equation
Dimension: number of segments</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>cq_s</strong> – List of vectors containing volumetric component
source-terms (surface conds).</p></li>
<li><p><strong>mix_s</strong> – List of vectors containing volumetric mixture of components
in wellbores at connections (surface conds).</p></li>
<li><p><strong>status</strong> – Logic vector of well statuses</p></li>
<li><p><strong>cstatus</strong> – Logic vector of well connection statuses</p></li>
<li><p><strong>cq_r</strong> – List of vectors containing volumetric phase
source-terms (reservoir conds).</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.models.facilities.setupWellControlEquationsSingleWell">
<span class="sig-name descname"><span class="pre">setupWellControlEquationsSingleWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">well</span></em>, <em class="sig-param"><span class="pre">sol0</span></em>, <em class="sig-param"><span class="pre">sol</span></em>, <em class="sig-param"><span class="pre">pBH</span></em>, <em class="sig-param"><span class="pre">q_s</span></em>, <em class="sig-param"><span class="pre">status</span></em>, <em class="sig-param"><span class="pre">mix_s</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.setupWellControlEquationsSingleWell" title="Permalink to this definition"></a></dt>
<dd><p>Setup well controll (residual) equations</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="nb">eq</span> <span class="p">=</span> <span class="n">setupWellControlEquations</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">pBH</span><span class="p">,</span> <span class="n">q_s</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">mix_s</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sol</strong> – List of current well solution structures containing
control type for each well</p></li>
<li><p><strong>pBH</strong> – Vector of well bhps</p></li>
<li><p><strong>q_s</strong> – List of vectors of well component volume-rates
(surface conds)</p></li>
<li><p><strong>status</strong> – Logic vector of well statuses</p></li>
<li><p><strong>mix_s</strong> – List of vectors containing volumetric mixture of components
in wellbroe at connections (surface conds).</p></li>
<li><p><strong>model</strong> – Simulation model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>eq</strong> – Well control equations</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>WellModel, computeWellContributionsNew.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.models.facilities.unpackPerforationProperties">
<span class="sig-name descname"><span class="pre">unpackPerforationProperties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">packed</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.unpackPerforationProperties" title="Permalink to this definition"></a></dt>
<dd><p>Unpack the properties extracted by packPerforationProperties. Internal function.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.models.facilities.wellBoreFriction">
<span class="sig-name descname"><span class="pre">wellBoreFriction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">mu</span></em>, <em class="sig-param"><span class="pre">D</span></em>, <em class="sig-param"><span class="pre">L</span></em>, <em class="sig-param"><span class="pre">roughness</span></em>, <em class="sig-param"><span class="pre">flowtype</span></em>, <em class="sig-param"><span class="pre">assumeTurbulent</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.models.facilities.wellBoreFriction" title="Permalink to this definition"></a></dt>
<dd><p>Empricial model for well-bore friction</p>
</dd></dl>

<span class="target" id="module-ad_core.models.facilities.vfp"></span><dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.models.facilities.vfp.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.models.facilities.vfp.Contents" title="Permalink to this definition"></a></dt>
<dd><p>VFP</p>
<dl class="simple">
<dt>Files</dt><dd><p>VFPTable -</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-ad_core.simulators">
<span id="simulators"></span><h2>Simulators<a class="headerlink" href="#module-ad_core.simulators" title="Permalink to this headline"></a></h2>
<dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.simulators.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.simulators.Contents" title="Permalink to this definition"></a></dt>
<dd><p>SIMULATORS</p>
<dl class="simple">
<dt>Files</dt><dd><p>computeSensitivitiesAdjointAD - Compute parameter sensitivities using adjoint simulation
computeGradientAdjointAD      - Compute gradients using an adjoint/backward simulation that is linear in each step
computeGradientPerturbationAD - Compute gradients using finite difference approximation by perturbing controls
simulateScheduleAD            - Run a schedule for a non-linear physical model using an automatic differention</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.simulators.computeGradientAdjointAD">
<span class="sig-name descname"><span class="pre">computeGradientAdjointAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">states</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">getObjective</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.simulators.computeGradientAdjointAD" title="Permalink to this definition"></a></dt>
<dd><p>Compute gradients using an adjoint/backward simulation that is linear in each step</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grad</span> <span class="p">=</span> <span class="n">computeGradientAdjointAD</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">getObjective</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>For a given schedule, compute gradients of objective with respect to well
controls by solving adjoint equations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state0</strong> – Physical model state at t = 0</p></li>
<li><p><strong>states</strong> – All previous states. Must support the syntax
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">state</span> <span class="pre">=</span> <span class="pre">states{i}</span></code>. If the problem is too large to fit in
memory, it can use ResultHandler class to retrieve files
from the disk.</p></li>
<li><p><strong>model</strong> – Subclass of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code> class such as
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ThreePhaseBlackOilModel</span></code> that models the physical
effects we want to study.</p></li>
<li><p><strong>schedule</strong> – Schedule suitable for <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>.</p></li>
<li><p><strong>getObjective</strong> – Function handle for getting objective function value
for a given timestep with derivatives. Format: &#64;(tstep)</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘Verbose’</strong> – Indicate if extra output is to be printed such as
detailed convergence reports and so on.</p></li>
<li><p><strong>‘scaling’</strong> – Struct with fields <code class="xref mat mat-func docutils literal notranslate"><span class="pre">rate</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">pressure</span></code> used to
scale the relevant control equations, if the model
supports it.</p></li>
<li><p><strong>‘LinearSolver’</strong> – Subclass of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code> suitable for solving the
adjoint systems.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>gradients</strong> – Cell array of gradients for each control step.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.simulators.computeGradientPerturbationAD" title="ad_core.simulators.computeGradientPerturbationAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGradientPerturbationAD</span></code></a>, <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.simulators.computeGradientPerturbationAD">
<span class="sig-name descname"><span class="pre">computeGradientPerturbationAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">getObjective</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.simulators.computeGradientPerturbationAD" title="Permalink to this definition"></a></dt>
<dd><p>Compute gradients using finite difference approximation by perturbing controls</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grad</span> <span class="p">=</span> <span class="n">computeGradientPerturbationAD</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">getObjective</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>For a given schedule, compute gradients with regards to well controls
by perturbing all controls ever so slightly and re-running the
simulation.</p>
<p>As the cost of this routine grows is approximately</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">(</span># <span class="n">wells</span><span class="p">)</span><span class="n">x</span><span class="p">(</span># <span class="n">ctrl</span> <span class="n">step</span><span class="p">)</span> <span class="n">x</span> <span class="n">cost</span> <span class="n">of</span> <span class="n">schedule</span>
</pre></div>
</div>
<p>it can be potentially extremely expensive. It is better to use the
<a class="reference internal" href="#ad_core.simulators.computeGradientAdjointAD" title="ad_core.simulators.computeGradientAdjointAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGradientAdjointAD</span></code></a> routine for most practical purposes. This
routine is primarily designed for validation of said routine.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state0</strong> – Physical model state at <code class="xref mat mat-func docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">0</span></code></p></li>
<li><p><strong>model</strong> – Subclass of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code> class such as
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ThreePhaseBlackOilModel</span></code> that models the physical
effects we want to study.</p></li>
<li><p><strong>schedule</strong> – Schedule suitable for <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>.</p></li>
<li><p><strong>getObjective</strong> – Function handle for getting objective function value
from a set of wellSols.
Function handle format: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">&#64;(wellSols,</span> <span class="pre">states,</span> <span class="pre">schedule)</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘Verbose’</strong> – Indicate if extra output is to be printed such as
detailed convergence reports and so on.</p></li>
<li><p><strong>‘scaling’</strong> – Struct with fields <code class="xref mat mat-func docutils literal notranslate"><span class="pre">rate</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">pressure</span></code> used to
scale the numerical perturbation.</p></li>
<li><p><strong>‘perturbation’</strong> – Magnitude of perturbation. Default <code class="xref mat mat-func docutils literal notranslate"><span class="pre">1e-7</span></code>.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>grad</strong> – Gradients for each step.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.simulators.computeGradientAdjointAD" title="ad_core.simulators.computeGradientAdjointAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGradientAdjointAD</span></code></a>, <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.simulators.computeSensitivitiesAdjointAD">
<span class="sig-name descname"><span class="pre">computeSensitivitiesAdjointAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">setup</span></em>, <em class="sig-param"><span class="pre">states</span></em>, <em class="sig-param"><span class="pre">param</span></em>, <em class="sig-param"><span class="pre">getObjective</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.simulators.computeSensitivitiesAdjointAD" title="Permalink to this definition"></a></dt>
<dd><p>Compute parameter sensitivities using adjoint simulation</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">sens</span> <span class="p">=</span> <span class="n">computeSensitivitiesAdjointAD</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">getObjective</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>For a given schedule, compute senistivities with regards to parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>SimulatorSetup</strong> – <p>structure containing:
state0   - Physical model state at <code class="xref mat mat-func docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">0</span></code>
model    - Subclass of PhysicalModel class such as</p>
<blockquote>
<div><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">GenericBlackOilModel</span></code> that models the physical
effects we want to study.</p>
</div></blockquote>
<p>schedule - Schedule suitable for <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>.</p>
</p></li>
<li><p><strong>states</strong> – All previous states. Must support the syntax
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">state</span> <span class="pre">=</span> <span class="pre">states{i}</span></code>. If the problem is too large to fit in
memory, it can use <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ResultHandler</span></code> class to retrieve files
from the disk.</p></li>
<li><p><strong>param</strong> – array of parameters of class ModelParameter</p></li>
<li><p><strong>getObjective</strong> – Function handle for getting objective function value
for a given timestep with derivatives. Format: &#64;(tstep)</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘LinearSolver’</strong> – Subclass of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code> suitable for solving the
adjoint systems.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sens</strong> – Structure with parameter sensitivites of the form
sens.(paramName) = paramValue</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGradientAD</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.simulators.simulateScheduleAD">
<span class="sig-name descname"><span class="pre">simulateScheduleAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">initState</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.simulators.simulateScheduleAD" title="Permalink to this definition"></a></dt>
<dd><p>Run a schedule for a non-linear physical model using an automatic differention</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wellSols</span> <span class="p">=</span> <span class="n">simulateScheduleAD</span><span class="p">(</span><span class="n">initState</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">schedule</span><span class="p">)</span>

<span class="p">[</span><span class="n">wellSols</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span>  <span class="p">=</span> <span class="n">simulateScheduleAD</span><span class="p">(</span><span class="n">initState</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">schedule</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function takes in a valid schedule file (see required parameters)
and runs a simulation through all timesteps for a given model and
initial state.</p>
<p>simulateScheduleAD is the outer bookkeeping routine used for running
simulations with non-trivial control changes. It relies on the model
and (non)linear solver classes to do the heavy lifting.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initState</strong> – Initial reservoir/model state. It should have whatever
fields are associated with the physical model, with
reasonable values. It is the responsibility of the user
to ensure that the state is properly initialized.</p></li>
<li><p><strong>model</strong> – The physical model that determines jacobians/convergence
for the problem. This must be a subclass of the
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code> base class.</p></li>
<li><p><strong>schedule</strong> – <p>Schedule containing fields step and control, defined as
follows:</p>
<blockquote>
<div><ul>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">schedule.control</span></code> is a struct array containing
fields that the model knows how to process.
Typically, this will be the fields such as <code class="xref mat mat-func docutils literal notranslate"><span class="pre">W</span></code>
for wells or <code class="xref mat mat-func docutils literal notranslate"><span class="pre">bc</span></code> for boundary conditions.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">schedule.step</span></code> contains two arrays of equal
size named <code class="xref mat mat-func docutils literal notranslate"><span class="pre">val</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">control</span></code>. Control is a
index into the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">schedule.control</span></code> array,
indicating which control is to be used for the
timestep.`schedule.step.val` is the timestep
used for that control step.</p></li>
</ul>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>‘Verbose’</strong> – Indicate if extra output is to be printed such as
detailed convergence reports and so on.</p></li>
<li><p><strong>‘OutputMinisteps’</strong> – The solver may not use timesteps equal to the
control steps depending on problem stiffness and
timestep selection. Enabling this option will make
the solver output the states and reports for all
steps actually taken and not just at the control
steps. See also <a class="reference internal" href="#ad_core.utils.convertReportToSchedule" title="ad_core.utils.convertReportToSchedule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertReportToSchedule</span></code></a> which can
be used to construct a new schedule from these
timesteps.</p></li>
<li><p><strong>‘initialGuess’</strong> – A cell array with one entry per control-step. If
provided, the state from this cell array is passed as
initial guess for the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NonLinearSolver</span></code>. See:
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">NonLinearSolver.solveTimestep</span></code>, optional arguments.</p></li>
<li><p><strong>‘NonLinearSolver’</strong> – An instance of the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NonLinearSolver</span></code> class. Consider
using this if you for example want a special timestep
selection algorithm. See the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NonLinearSolver</span></code> class
docs for more information.</p></li>
<li><p><strong>‘OutputHandler’</strong> – Output handler class, for example for writing states
to disk during the simulation or in-situ
visualization. See the ResultHandler base class.</p></li>
<li><p><strong>‘WellOutputHandler’</strong> – Same as ‘OutputHandler’, but for the well
solutions for the individual report steps. Well
solutions are also stored using OutputHandler, but
using WellOutputHandler is convenient for quickly
loading well solutions only.</p></li>
<li><p><strong>‘ReportHandler’</strong> – Same as ‘OutputHandler’, but for the reports for the
individual report steps.</p></li>
<li><p><strong>‘LinearSolver’</strong> – Class instance subclassed from <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code>. Used
to solve linearized problems in the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NonLinearSolver</span></code>
class. Note that if you are passing a
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">NonLinearSolver</span></code>, you might as well put it there.</p></li>
<li><p><strong>‘afterStepFn’</strong> – Function handle to an optional function that will be
called after each successful report step in the
schedule. The function should take in the following
input arguments:
- model: The model used in the schedule
- states: A cell array of all states that are</p>
<blockquote>
<div><p>computed, as well as possible empty entries
where the states have not been computed yet.</p>
</div></blockquote>
<ul class="simple">
<li><p>reports: A cell array of reports for each step,
with empty entries for steps that have not been
reached yet.</p></li>
<li><p>solver: The NonLinearSolver instance.</p></li>
<li><p>schedule: The current schedule.</p></li>
<li><p>simtime: Array with the time in seconds taken by
the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NonLinearSolver</span></code> to compute each step.
Entries not computed will contain zeros.</p></li>
</ul>
<p>See <a class="reference internal" href="#ad_core.plotting.getPlotAfterStep" title="ad_core.plotting.getPlotAfterStep"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getPlotAfterStep</span></code></a> for more information and
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">howtoAddPlotHook</span></code> for a worked example.</p>
</li>
<li><p><strong>‘processOutputFn’</strong> – Function handle to an optional function that
processes the simulation output (wellSols, states
and reports) before they are stored to state using
the output handlers. Allows for storing only data
of interest, which is useful when dealing with
large models. Changes made to the output by this
function are only applied to the data that is
stored, and will not affect what is passed on to
the next timestep.</p></li>
<li><p><strong>‘controlLogicFn’</strong> – Function handle to optional function that will be
called after each step enabling schedule updates to
be triggered on specified events. Input arguemnts:
- state: The current state
- schedule: The current schedule
- report: Current report
- i: The current report step such that current</p>
<blockquote>
<div><p>control step equals schedule.step.control(i)</p>
</div></blockquote>
<p>The function must have three outputs:
- schedule: Possibly updated schedule
- report: Possibly updated report
- isAltered: Flag indicated whether the schedule</p>
<blockquote>
<div><p>was updated or not</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wellSols</strong> – Well solution at each control step (or timestep if
‘OutputMinisteps’ is enabled.)</p></li>
<li><p><strong>states</strong> – State at each control step (or timestep if
‘OutputMinisteps’ is enabled.)</p></li>
<li><p><strong>schedulereport</strong> – Report for the simulation. Contains detailed info for
the whole schedule run, as well as arrays containing
reports for the whole stack of routines called during
the simulation.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For examples of valid models, see <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ThreePhaseBlackOilModel</span></code> or
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">TwoPhaseOilWaterModel</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.simulators.computeGradientAdjointAD" title="ad_core.simulators.computeGradientAdjointAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGradientAdjointAD</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-ad_core.solvers">
<span id="solvers"></span><h2>Solvers<a class="headerlink" href="#module-ad_core.solvers" title="Permalink to this headline"></a></h2>
<dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.solvers.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.solvers.Contents" title="Permalink to this definition"></a></dt>
<dd><p>SOLVERS</p>
<dl class="simple">
<dt>Files</dt><dd><p>AMGCL_CPRSolverAD      - Linear solver that calls external compiled multigrid solver
AMGCL_CPRSolverBlockAD - Linear solver that calls external compiled multigrid solver
AGMGSolverAD           - Linear solver that calls external compiled multigrid solver
AMGCLSolverAD          - Linear solver that calls external compiled multigrid solver
AMGCLSolverBlockAD     - Linear solver that calls external compiled multigrid solver
BackslashSolverAD      - Linear solver that calls standard MATLAB direct solver mldivide “&quot;
CPRSolverAD            - Solve a problem with a pressure component using constrained a pressure residual method
getNonLinearSolver     - Set up reasonable defaults for the nonlinear solver for a field
GMRES_ILUSolverAD      - Preconditioned GMRES solver.
HandleLinearSolverAD   - Simple solver for wrapping functions on the form x = fn(A, b);
LinearizedProblem      - A linearized problem within a non-linear iteration
LinearSolverAD         - Base class for linear solvers in the AD framework
NonLinearSolver        - Generalized Newton-like nonlinear solver
NoOpSolverAD           - Linear solver that does nothing.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.AGMGSolverAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">AGMGSolverAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.AGMGSolverAD" title="Permalink to this definition"></a></dt>
<dd><p>Linear solver that calls external compiled multigrid solver</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">AGMGSolverAD</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This solver calls the AGMG package and supports setup/cleanup of the
multigrid solver for multiple solves of the same problem.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This solver requires AGMG to be installed and working.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">BackslashSolverAD</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.AGMGSolverAD.cleanupSolver">
<span class="sig-name descname"><span class="pre">cleanupSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.AGMGSolverAD.cleanupSolver" title="Permalink to this definition"></a></dt>
<dd><p>Clean up solver after use (if needed)</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.AGMGSolverAD.setupSolver">
<span class="sig-name descname"><span class="pre">setupSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.AGMGSolverAD.setupSolver" title="Permalink to this definition"></a></dt>
<dd><p>Run setup on a solver for a given system</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AGMGSolverAD.reuseSetup">
<span class="sig-name descname"><span class="pre">reuseSetup</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.AGMGSolverAD.reuseSetup" title="Permalink to this definition"></a></dt>
<dd><p>Will reuse the setup phase to improve speed for e.g. a GMRES loop with the same matrix system. However, some systems report segfaults with this option enabled.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AGMGSolverAD.setupDone">
<span class="sig-name descname"><span class="pre">setupDone</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.AGMGSolverAD.setupDone" title="Permalink to this definition"></a></dt>
<dd><p>Internal book-keeping variable</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AGMGSolverAD.singleApply">
<span class="sig-name descname"><span class="pre">singleApply</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'false'</span></em><a class="headerlink" href="#ad_core.solvers.AGMGSolverAD.singleApply" title="Permalink to this definition"></a></dt>
<dd><p>Just apply the preconditioner once, do not solve to tolerance</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCLSolverAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">AMGCLSolverAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.AMGCLSolverAD" title="Permalink to this definition"></a></dt>
<dd><p>Linear solver that calls external compiled multigrid solver</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">AMGCLSolverAD</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>AD-interface for the AMGCL interface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This solver requires AMGCL to be installed and working.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">BackslashSolverAD</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCLSolverAD.cleanupSolver">
<span class="sig-name descname"><span class="pre">cleanupSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.AMGCLSolverAD.cleanupSolver" title="Permalink to this definition"></a></dt>
<dd><p>#ok</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCLSolverAD.amgcl_setup">
<span class="sig-name descname"><span class="pre">amgcl_setup</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1'</span></em><a class="headerlink" href="#ad_core.solvers.AMGCLSolverAD.amgcl_setup" title="Permalink to this definition"></a></dt>
<dd><p>1 for no reuse, 2 for re-use</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCLSolverBlockAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">AMGCLSolverBlockAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.AMGCLSolverBlockAD" title="Permalink to this definition"></a></dt>
<dd><p>Linear solver that calls external compiled multigrid solver</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">AMGCLSolverAD</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>AD-interface for the AMGCL interface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This solver requires AMGCL to be installed and working.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">BackslashSolverAD</span></code></p>
</div>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">AMGCL_CPRSolverAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverAD" title="Permalink to this definition"></a></dt>
<dd><p>Linear solver that calls external compiled multigrid solver</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">AMGCLSolverAD</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>AD-interface for the AMGCL interface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This solver requires AMGCL to be installed and working.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">BackslashSolverAD</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverAD.getDiagonalInverse">
<span class="sig-name descname"><span class="pre">getDiagonalInverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverAD.getDiagonalInverse" title="Permalink to this definition"></a></dt>
<dd><p>Reciprocal of diagonal matrix</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverAD.undoScaling">
<span class="sig-name descname"><span class="pre">undoScaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">scaling</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverAD.undoScaling" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Undo effects of scaling applied to linear system</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverAD.couplingTol">
<span class="sig-name descname"><span class="pre">couplingTol</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'0.02'</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverAD.couplingTol" title="Permalink to this definition"></a></dt>
<dd><p>tolerance for drs</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverAD.decoupling">
<span class="sig-name descname"><span class="pre">decoupling</span></span><em class="property"> <span class="pre">=</span> <span class="pre">&quot;'trueIMPES'&quot;</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverAD.decoupling" title="Permalink to this definition"></a></dt>
<dd><p>trueimpes, quasiimpes, none</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverAD.diagonalTol">
<span class="sig-name descname"><span class="pre">diagonalTol</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'0.2'</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverAD.diagonalTol" title="Permalink to this definition"></a></dt>
<dd><p>tolerance if strategy ends with _drs</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverAD.doApplyScalingCPR">
<span class="sig-name descname"><span class="pre">doApplyScalingCPR</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverAD.doApplyScalingCPR" title="Permalink to this definition"></a></dt>
<dd><p>true / false</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverAD.pressureScaling">
<span class="sig-name descname"><span class="pre">pressureScaling</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverAD.pressureScaling" title="Permalink to this definition"></a></dt>
<dd><p>scaling factor for pressure - automatically determined</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverAD.strategy">
<span class="sig-name descname"><span class="pre">strategy</span></span><em class="property"> <span class="pre">=</span> <span class="pre">&quot;'mrst'&quot;</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverAD.strategy" title="Permalink to this definition"></a></dt>
<dd><p>mrst, mrst_drs, amgcl, amgcl_drs</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverAD.useSYMRCMOrdering">
<span class="sig-name descname"><span class="pre">useSYMRCMOrdering</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverAD.useSYMRCMOrdering" title="Permalink to this definition"></a></dt>
<dd><p>true / false</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverBlockAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">AMGCL_CPRSolverBlockAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverBlockAD" title="Permalink to this definition"></a></dt>
<dd><p>Linear solver that calls external compiled multigrid solver</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">AMGCLSolverAD</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>AD-interface for the AMGCL interface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This solver requires AMGCL to be installed and working.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">BackslashSolverAD</span></code></p>
</div>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverBlockAD.couplingTol">
<span class="sig-name descname"><span class="pre">couplingTol</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'0.02'</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverBlockAD.couplingTol" title="Permalink to this definition"></a></dt>
<dd><p>tolerance for drs</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverBlockAD.diagonalTol">
<span class="sig-name descname"><span class="pre">diagonalTol</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'0.2'</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverBlockAD.diagonalTol" title="Permalink to this definition"></a></dt>
<dd><p>tolerance if strategy ends with _drs</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverBlockAD.pressureScaling">
<span class="sig-name descname"><span class="pre">pressureScaling</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverBlockAD.pressureScaling" title="Permalink to this definition"></a></dt>
<dd><p>scaling factor for pressure - automatically determined</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.AMGCL_CPRSolverBlockAD.strategy">
<span class="sig-name descname"><span class="pre">strategy</span></span><em class="property"> <span class="pre">=</span> <span class="pre">&quot;'amgcl'&quot;</span></em><a class="headerlink" href="#ad_core.solvers.AMGCL_CPRSolverBlockAD.strategy" title="Permalink to this definition"></a></dt>
<dd><p>amgcl, amgcl_drs</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.BackslashSolverAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">BackslashSolverAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.BackslashSolverAD" title="Permalink to this definition"></a></dt>
<dd><p>Linear solver that calls standard MATLAB direct solver mldivide “&quot;</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">BackslashSolverAD</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This solver solves linearized problems using matlab builtin mldivide.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code></p>
</div>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.CPRSolverAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">CPRSolverAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.CPRSolverAD" title="Permalink to this definition"></a></dt>
<dd><p>Solve a problem with a pressure component using constrained a pressure residual method</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">CPRSolverAD</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Solve a linearized problem with a significant elliptic/pressure
feature via a two stage preconditioner for GMRES. By exposing the
elliptic component as a separate system, a special elliptic solver can
be used to handle the tightly coupled pressure system.</p>
<p>For second stage, ILU(0) is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>‘property’</strong> – Set property to value.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">BackslashSolverAD</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblem</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.CPRSolverAD.solveLinearProblem">
<span class="sig-name descname"><span class="pre">solveLinearProblem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">problem0</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.CPRSolverAD.solveLinearProblem" title="Permalink to this definition"></a></dt>
<dd><p>Solve a linearized problem using a constrained pressure
residual preconditioner</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.CPRSolverAD.solveLinearSystem">
<span class="sig-name descname"><span class="pre">solveLinearSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.CPRSolverAD.solveLinearSystem" title="Permalink to this definition"></a></dt>
<dd><p>#ok</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.CPRSolverAD.diagonalTol">
<span class="sig-name descname"><span class="pre">diagonalTol</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.CPRSolverAD.diagonalTol" title="Permalink to this definition"></a></dt>
<dd><p>Diagonal tolerance in [0,1].</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.CPRSolverAD.ellipticSign">
<span class="sig-name descname"><span class="pre">ellipticSign</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'-1'</span></em><a class="headerlink" href="#ad_core.solvers.CPRSolverAD.ellipticSign" title="Permalink to this definition"></a></dt>
<dd><p>Sign to use for pressure system - negative default for compatibility with AGMG</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.CPRSolverAD.ellipticSolver">
<span class="sig-name descname"><span class="pre">ellipticSolver</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.CPRSolverAD.ellipticSolver" title="Permalink to this definition"></a></dt>
<dd><p>LinearSolverAD subclass suitable for the elliptic submatrix.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.CPRSolverAD.ellipticVarName">
<span class="sig-name descname"><span class="pre">ellipticVarName</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.CPRSolverAD.ellipticVarName" title="Permalink to this definition"></a></dt>
<dd><p>Name of elliptic-like variable which will be solved using elliptic solver</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.CPRSolverAD.pressureScaling">
<span class="sig-name descname"><span class="pre">pressureScaling</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.CPRSolverAD.pressureScaling" title="Permalink to this definition"></a></dt>
<dd><p>Scaling factor applied to pressure equations</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.CPRSolverAD.relativeTolerance">
<span class="sig-name descname"><span class="pre">relativeTolerance</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.CPRSolverAD.relativeTolerance" title="Permalink to this definition"></a></dt>
<dd><p>Relative tolerance for elliptic solver</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.CPRSolverAD.trueIMPES">
<span class="sig-name descname"><span class="pre">trueIMPES</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.CPRSolverAD.trueIMPES" title="Permalink to this definition"></a></dt>
<dd><p>Use true impes decoupling strategy (if supported by model)</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.GMRES_ILUSolverAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">GMRES_ILUSolverAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.GMRES_ILUSolverAD" title="Permalink to this definition"></a></dt>
<dd><p>Preconditioned GMRES solver.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">GMRES_ILUSolverAD</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Solve a linearized problem using a GMRES solver with ILU
preconditioner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘property’</strong> – Set property to value.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">BackslashSolverAD</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">CPRSolverAD</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblem</span></code>,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code></p>
</div>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.GMRES_ILUSolverAD.dropTolerance">
<span class="sig-name descname"><span class="pre">dropTolerance</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.GMRES_ILUSolverAD.dropTolerance" title="Permalink to this definition"></a></dt>
<dd><p>Modified ilu type: ‘row’, ‘col’, {‘off’}</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.GMRES_ILUSolverAD.ilutype">
<span class="sig-name descname"><span class="pre">ilutype</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.GMRES_ILUSolverAD.ilutype" title="Permalink to this definition"></a></dt>
<dd><p>Drop tolerance for elements (default: 0)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.GMRES_ILUSolverAD.modifiedIncompleteILU">
<span class="sig-name descname"><span class="pre">modifiedIncompleteILU</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.GMRES_ILUSolverAD.modifiedIncompleteILU" title="Permalink to this definition"></a></dt>
<dd><p>Boolean indicating replacement of zero diagonal entries</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.GMRES_ILUSolverAD.pivotThreshold">
<span class="sig-name descname"><span class="pre">pivotThreshold</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.GMRES_ILUSolverAD.pivotThreshold" title="Permalink to this definition"></a></dt>
<dd><p>Reorder equations when diagonal entries are zero for ilu0</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.GMRES_ILUSolverAD.udiagReplacement">
<span class="sig-name descname"><span class="pre">udiagReplacement</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.GMRES_ILUSolverAD.udiagReplacement" title="Permalink to this definition"></a></dt>
<dd><p>Pivoting threshold for ilupt. Default 1.</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.HandleLinearSolverAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">HandleLinearSolverAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fcn</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.HandleLinearSolverAD" title="Permalink to this definition"></a></dt>
<dd><p>Simple solver for wrapping functions on the form x = fn(A, b);</p>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.HandleLinearSolverAD.getDescription">
<span class="sig-name descname"><span class="pre">getDescription</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.HandleLinearSolverAD.getDescription" title="Permalink to this definition"></a></dt>
<dd><p>Get the description and a short name used for display
purposes.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.HandleLinearSolverAD.solveLinearSystem">
<span class="sig-name descname"><span class="pre">solveLinearSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.HandleLinearSolverAD.solveLinearSystem" title="Permalink to this definition"></a></dt>
<dd><p>#ok</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">LinearSolverAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD" title="Permalink to this definition"></a></dt>
<dd><p>Base class for linear solvers in the AD framework</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">LinearSolverAD</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Base class for linear solvers. Implement methods for solving linearized
problems and adjoints. Also supports setup/cleanup functions
before/after use for initialize once-type usage.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘property’</strong> – Set property to value.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is intended as superclass. It cannot actually solve
problems.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">BackslashSolverAD</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">CPRSolverAD</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearizedProblem</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.applyScaling">
<span class="sig-name descname"><span class="pre">applyScaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">x0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.applyScaling" title="Permalink to this definition"></a></dt>
<dd><p>Apply left or right diagonal scaling</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.cleanupSolver">
<span class="sig-name descname"><span class="pre">cleanupSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.cleanupSolver" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Clean up solver after use (if needed)</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.getDescription">
<span class="sig-name descname"><span class="pre">getDescription</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.getDescription" title="Permalink to this definition"></a></dt>
<dd><p>Get the description and a short name used for display
purposes.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.getDiagonalInverse">
<span class="sig-name descname"><span class="pre">getDiagonalInverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.getDiagonalInverse" title="Permalink to this definition"></a></dt>
<dd><p>Reciprocal of diagonal matrix</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.getSolveReport">
<span class="sig-name descname"><span class="pre">getSolveReport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.getSolveReport" title="Permalink to this definition"></a></dt>
<dd><p>#ok</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.preconditionerInverse">
<span class="sig-name descname"><span class="pre">preconditionerInverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">M</span></em>, <em class="sig-param"><span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.preconditionerInverse" title="Permalink to this definition"></a></dt>
<dd><p>Apply a preconditioner. Either a handle or a matrix.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.recoverLinearSystem">
<span class="sig-name descname"><span class="pre">recoverLinearSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">sys</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.recoverLinearSystem" title="Permalink to this definition"></a></dt>
<dd><p>Recover eliminated variables</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.recoverLinearSystemAdjoint">
<span class="sig-name descname"><span class="pre">recoverLinearSystemAdjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">sys</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.recoverLinearSystemAdjoint" title="Permalink to this definition"></a></dt>
<dd><p>Recover eliminated variables</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.reduceLinearSystem">
<span class="sig-name descname"><span class="pre">reduceLinearSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">isAdjoint</span></em>, <em class="sig-param"><span class="pre">x0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.reduceLinearSystem" title="Permalink to this definition"></a></dt>
<dd><p>Perform Schur complement reduction of linear system</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.setupSolver">
<span class="sig-name descname"><span class="pre">setupSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.setupSolver" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Run setup on a solver for a given system</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.solveAdjointProblem">
<span class="sig-name descname"><span class="pre">solveAdjointProblem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">problemPrev</span></em>, <em class="sig-param"><span class="pre">problemCurr</span></em>, <em class="sig-param"><span class="pre">adjVec</span></em>, <em class="sig-param"><span class="pre">objective</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.solveAdjointProblem" title="Permalink to this definition"></a></dt>
<dd><p>#ok</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.solveCellReducedLinearProblem">
<span class="sig-name descname"><span class="pre">solveCellReducedLinearProblem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.solveCellReducedLinearProblem" title="Permalink to this definition"></a></dt>
<dd><p>Reduce a problem to cell-variables, solve and then recover
the eliminated variables afterwards.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.solveLinearProblem">
<span class="sig-name descname"><span class="pre">solveLinearProblem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.solveLinearProblem" title="Permalink to this definition"></a></dt>
<dd><p>Solve a linearized problem</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.solveLinearSystem">
<span class="sig-name descname"><span class="pre">solveLinearSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.solveLinearSystem" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Solve the linear system to a given tolerance</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.storeIncrements">
<span class="sig-name descname"><span class="pre">storeIncrements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">result</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.storeIncrements" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Extract the results from a vector into a cell array with one
entry per primary variable in the linearized problem.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.undoScaling">
<span class="sig-name descname"><span class="pre">undoScaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">scaling</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.undoScaling" title="Permalink to this definition"></a></dt>
<dd><p>Undo effects of scaling applied to linear system</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.undoScalingAdjoint">
<span class="sig-name descname"><span class="pre">undoScalingAdjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">scaling</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.undoScalingAdjoint" title="Permalink to this definition"></a></dt>
<dd><p>Undo effects of scaling applied to linear system (adjoint
version)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.applyLeftDiagonalScaling">
<span class="sig-name descname"><span class="pre">applyLeftDiagonalScaling</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.applyLeftDiagonalScaling" title="Permalink to this definition"></a></dt>
<dd><p>Apply left diagonal scaling before solving</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.applyRightDiagonalScaling">
<span class="sig-name descname"><span class="pre">applyRightDiagonalScaling</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.applyRightDiagonalScaling" title="Permalink to this definition"></a></dt>
<dd><p>Apply right diagonal scaling before solving</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.equationOrdering">
<span class="sig-name descname"><span class="pre">equationOrdering</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.equationOrdering" title="Permalink to this definition"></a></dt>
<dd><p>Equation ordering to be used for linear solver. Row vector of equal length to the size of the linear system.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.extraReport">
<span class="sig-name descname"><span class="pre">extraReport</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.extraReport" title="Permalink to this definition"></a></dt>
<dd><p>Enable this to produce additional report output</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.id">
<span class="sig-name descname"><span class="pre">id</span></span><em class="property"> <span class="pre">=</span> <span class="pre">&quot;''&quot;</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.id" title="Permalink to this definition"></a></dt>
<dd><p>Short text string identifying the specific solver. Appended to the short name (see getDescription)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.keepNumber">
<span class="sig-name descname"><span class="pre">keepNumber</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.keepNumber" title="Permalink to this definition"></a></dt>
<dd><p>If set, linear solver will reduce the system to the first keepNumber entries</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.maxIterations">
<span class="sig-name descname"><span class="pre">maxIterations</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.maxIterations" title="Permalink to this definition"></a></dt>
<dd><p>Max number of iterations used</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.reduceToCell">
<span class="sig-name descname"><span class="pre">reduceToCell</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.reduceToCell" title="Permalink to this definition"></a></dt>
<dd><p>Reduce to per-cell system before solving</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.replaceInf">
<span class="sig-name descname"><span class="pre">replaceInf</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.replaceInf" title="Permalink to this definition"></a></dt>
<dd><p>Boolean indicating if the solver should replace Inf in the results</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.replaceNaN">
<span class="sig-name descname"><span class="pre">replaceNaN</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.replaceNaN" title="Permalink to this definition"></a></dt>
<dd><p>Boolean indicating if the solver should replace NaN in the results</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.replacementInf">
<span class="sig-name descname"><span class="pre">replacementInf</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.replacementInf" title="Permalink to this definition"></a></dt>
<dd><p>If replaceInf is enabled, this is the value that will be inserted</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.replacementNaN">
<span class="sig-name descname"><span class="pre">replacementNaN</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.replacementNaN" title="Permalink to this definition"></a></dt>
<dd><p>If replaceNaN is enabled, this is the value that will be inserted</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.tolerance">
<span class="sig-name descname"><span class="pre">tolerance</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.tolerance" title="Permalink to this definition"></a></dt>
<dd><p>Linear solver tolerance</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.useSparseReduction">
<span class="sig-name descname"><span class="pre">useSparseReduction</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.useSparseReduction" title="Permalink to this definition"></a></dt>
<dd><p>If true, sparse indexing will be used with keepNumber option</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.variableOrdering">
<span class="sig-name descname"><span class="pre">variableOrdering</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.variableOrdering" title="Permalink to this definition"></a></dt>
<dd><p>Variable ordering to be used for linear solver. Row vector of equal length to the size of the linear system.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearSolverAD.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearSolverAD.verbose" title="Permalink to this definition"></a></dt>
<dd><p>Verbose output enabler</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">LinearizedProblem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem" title="Permalink to this definition"></a></dt>
<dd><p>A linearized problem within a non-linear iteration</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">problem</span> <span class="p">=</span> <span class="n">LinearizedProblem</span><span class="p">(</span><span class="n">primvars</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
<span class="n">problem</span> <span class="p">=</span> <span class="n">LinearizedProblem</span><span class="p">(</span><span class="n">primvars</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
<span class="n">problem</span> <span class="p">=</span> <span class="n">LinearizedProblem</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">eqtypes</span><span class="p">,</span> <span class="n">eqnames</span><span class="p">,</span> <span class="n">primvars</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
<span class="n">problem</span> <span class="p">=</span> <span class="n">LinearizedProblem</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">eqtypes</span><span class="p">,</span> <span class="n">eqnames</span><span class="p">,</span> <span class="n">primvars</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>A class that implements storage of an instance of a linearized problem
discretized using AD. This class contains the residual equations
evaluated for a single state along with meta-information about the
equations and the primary variables they are differentiated with
respect to.</p>
<p>A linearized problem can be transformed into a linear system and solved
using <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code>-derived subclasses, given that the number of
equations matches the number of primary variables.</p>
<p>In particular, the class contains member functions for:</p>
<blockquote>
<div><ul class="simple">
<li><p>assembling a linear system from the Jacobian block matrices stored
for each individual (continuous) equation</p></li>
<li><p>appending/prepending additional equations</p></li>
<li><p>using a block-Gaussian method to eliminate individual variables or
all variables that are not of a specified type</p></li>
<li><p>recovering increments corresponding to variables that have
previously been eliminated</p></li>
<li><p>computing the norm of each residual equation</p></li>
</ul>
</div></blockquote>
<p>as well as a number of utility functions for sanity checks, quering of
indices and the number of equations, clearing the linear system, etc.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.appendEquations">
<span class="sig-name descname"><span class="pre">appendEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">equations</span></em>, <em class="sig-param"><span class="pre">types</span></em>, <em class="sig-param"><span class="pre">names</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.appendEquations" title="Permalink to this definition"></a></dt>
<dd><p>Add one or more equations to the beginning of the current
list of equations.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.assembleSystem">
<span class="sig-name descname"><span class="pre">assembleSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.assembleSystem" title="Permalink to this definition"></a></dt>
<dd><p>Assemble the linear system from the individual Jacobians and
residual functions. Note the return parameter, as problem is not a
handle class.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.checkInputs">
<span class="sig-name descname"><span class="pre">checkInputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">equations</span></em>, <em class="sig-param"><span class="pre">types</span></em>, <em class="sig-param"><span class="pre">names</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.checkInputs" title="Permalink to this definition"></a></dt>
<dd><p>#ok</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.clearSystem">
<span class="sig-name descname"><span class="pre">clearSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.clearSystem" title="Permalink to this definition"></a></dt>
<dd><p>Remove pre-assembled linear system. Typically used if the
equations are manually changed, and one does not want to evaluate
inconsistent linear systems.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.countOfType">
<span class="sig-name descname"><span class="pre">countOfType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.countOfType" title="Permalink to this definition"></a></dt>
<dd><p>Count the number of equations that are of a specific type.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.eliminateVariable">
<span class="sig-name descname"><span class="pre">eliminateVariable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">variable</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.eliminateVariable" title="Permalink to this definition"></a></dt>
<dd><p>Eliminate a variable from the problem using the equation with
the same index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variable</strong> – The name of the variable (corresponding to an entry in
problem.names) that is to be eliminated.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>problem</strong> – Modified problem.</p></li>
<li><p><strong>eliminatedEquation</strong> – The equation that was eliminated.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For non-diagonal matrices, the cost of the equation elimination
can be large.</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.getEquationVarNum">
<span class="sig-name descname"><span class="pre">getEquationVarNum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.getEquationVarNum" title="Permalink to this definition"></a></dt>
<dd><p>Get number of subequations for one or more equations. A single
equation is a collection of a number of equations grouped by the
constructor. Typically, all subequations should be of the same
:param n: (OPTIONAL) Indices of the equations for which the number</p>
<blockquote>
<div><p>of subequations is desired. If omitted, the function
returns the number for all equations.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>varnum</strong> – Array with the number of subequations for the requested
equations.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.getLinearSystem">
<span class="sig-name descname"><span class="pre">getLinearSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.getLinearSystem" title="Permalink to this definition"></a></dt>
<dd><p>Get the linear system from the individual Jacobians and residual
equations in a format suitable for general linear solvers. If the
equations are not already assembled, this will result in a call
to assembleSystem. If you will retrieve the linear system
multiple times, it is better to call assembleSystem beforehand.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.indexOfEquationName">
<span class="sig-name descname"><span class="pre">indexOfEquationName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.indexOfEquationName" title="Permalink to this definition"></a></dt>
<dd><p>Get the index into the list of equations for a specific name</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.indexOfPrimaryVariable">
<span class="sig-name descname"><span class="pre">indexOfPrimaryVariable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.indexOfPrimaryVariable" title="Permalink to this definition"></a></dt>
<dd><p>Get the index of a primary variable by name.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.indexOfType">
<span class="sig-name descname"><span class="pre">indexOfType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.indexOfType" title="Permalink to this definition"></a></dt>
<dd><p>Get the index(es) of a type of variable by name.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.norm" title="Permalink to this definition"></a></dt>
<dd><p>Get the norm of each equation. This is an overloaded function.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.numeq">
<span class="sig-name descname"><span class="pre">numeq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.numeq" title="Permalink to this definition"></a></dt>
<dd><p>Get the number of distinct equations. Note that an equation here
can refer to multiple subequations of the same type (e.g. a 100
cell problem where the equations are oil and water conservation
laws will have two equations in total, with each having 100
sub-entries.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.popIncrement">
<span class="sig-name descname"><span class="pre">popIncrement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">dx</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.popIncrement" title="Permalink to this definition"></a></dt>
<dd><p>Get named/logic position update from a set of increments.
Optionally, return dx and problem where the increment has then
been removed.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.prependEquations">
<span class="sig-name descname"><span class="pre">prependEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">equations</span></em>, <em class="sig-param"><span class="pre">types</span></em>, <em class="sig-param"><span class="pre">names</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.prependEquations" title="Permalink to this definition"></a></dt>
<dd><p>Add one or more equations to the end of the current list of
equations.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.processResultAfterSolve">
<span class="sig-name descname"><span class="pre">processResultAfterSolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">result</span></em>, <em class="sig-param"><span class="pre">report</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.processResultAfterSolve" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Do nothing</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.recoverFromSingleVariableType">
<span class="sig-name descname"><span class="pre">recoverFromSingleVariableType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reducedProblem</span></em>, <em class="sig-param"><span class="pre">originalProblem</span></em>, <em class="sig-param"><span class="pre">incrementsReduced</span></em>, <em class="sig-param"><span class="pre">eliminated</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.recoverFromSingleVariableType" title="Permalink to this definition"></a></dt>
<dd><p>Recover the increments in primary variables corresponding to
equations that have previously been eliminated by for instance
“reduceToSingleVariableType”.
:param originalProblem: The problem before elimination.
:param incrementsReduced: Increments from the solution of the reduced</p>
<blockquote>
<div><p>problem.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>eliminated</strong> – The eliminated equations.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dx</strong> – All increments, as if the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">originalProblem</span></code> was solved
directly.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.reduceToSingleVariableType">
<span class="sig-name descname"><span class="pre">reduceToSingleVariableType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.reduceToSingleVariableType" title="Permalink to this definition"></a></dt>
<dd><p>Eliminate all equations that are not of a given type</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>type</strong> – String matching one of problem.types. Equations that DO NOT
have that type will be eliminated.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>problem</strong> – Modified problem.</p></li>
<li><p><strong>eliminated</strong> – Eliminated equations. Can be used to recover the
eliminated values later.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Can have a severe cost depending on the sparsity patterns
involved in the different equations. Typical usage is to
eliminate non-cell equations (wells, control equations).</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.reorderEquations">
<span class="sig-name descname"><span class="pre">reorderEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">newIndices</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.reorderEquations" title="Permalink to this definition"></a></dt>
<dd><p>Reorder equations based on a set of indices.
ARGUMENTS:
- newIndices: numeq(problem) long array of new indices into the</p>
<blockquote>
<div><p>equations.</p>
</div></blockquote>
<p>OUTPUT:
- problem   : Problem with re-numbered equations.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.A">
<span class="sig-name descname"><span class="pre">A</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.A" title="Permalink to this definition"></a></dt>
<dd><p>Linear system after assembling Jacobians.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.b">
<span class="sig-name descname"><span class="pre">b</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.b" title="Permalink to this definition"></a></dt>
<dd><p>Right hand side for linearized system. See A.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.drivingForces">
<span class="sig-name descname"><span class="pre">drivingForces</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.drivingForces" title="Permalink to this definition"></a></dt>
<dd><p>The driving forces struct used to generate the equations.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.dt">
<span class="sig-name descname"><span class="pre">dt</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.dt" title="Permalink to this definition"></a></dt>
<dd><p>The time step length (Not relevant for all problems)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.equationNames">
<span class="sig-name descname"><span class="pre">equationNames</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.equationNames" title="Permalink to this definition"></a></dt>
<dd><p>Cell array of equal length to number of equations, giving them unique names</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.equations">
<span class="sig-name descname"><span class="pre">equations</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.equations" title="Permalink to this definition"></a></dt>
<dd><p>Cell array of the equations. Can be doubles, or more typically ADI objects.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.iterationNo">
<span class="sig-name descname"><span class="pre">iterationNo</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.iterationNo" title="Permalink to this definition"></a></dt>
<dd><p>Nonlinear iteration number corresponding to problem.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.primaryVariables">
<span class="sig-name descname"><span class="pre">primaryVariables</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.primaryVariables" title="Permalink to this definition"></a></dt>
<dd><p>Cell array containing the names of the primary variables.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.state">
<span class="sig-name descname"><span class="pre">state</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.state" title="Permalink to this definition"></a></dt>
<dd><p>The problem state used to produce the equations</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.LinearizedProblem.types">
<span class="sig-name descname"><span class="pre">types</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.LinearizedProblem.types" title="Permalink to this definition"></a></dt>
<dd><p>Cell array of equal length to number of equations, with strings indicating their types</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.NoOpSolverAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">NoOpSolverAD</span></span><a class="headerlink" href="#ad_core.solvers.NoOpSolverAD" title="Permalink to this definition"></a></dt>
<dd><p>Linear solver that does nothing.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">NoOpSolverAD</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Debug solver. It has the correct interfaces, but it always returns zero
as the solution for the problem. It is, however, very fast…</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You should not use this solver.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BackslashSolverAD</p>
</div>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">NonLinearSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.NonLinearSolver" title="Permalink to this definition"></a></dt>
<dd><p>Generalized Newton-like nonlinear solver</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">NonLinearSolver</span><span class="p">()</span>

<span class="n">solver</span> <span class="p">=</span> <span class="n">NonLinearSolver</span><span class="p">(</span><span class="s">&#39;maxIterations&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>The NonLinearSolver class is a general non-linear solver based on
Newton’s method. It is capable of timestep selection and cutting based
on convergence rates and can be extended via subclassing or modular
linear solvers and timestep classes.</p>
<p>Convergence is handled by the PhysicalModel class. The NonLinearSolver
simply responds based on what the model reports in terms of convergence
to ensure some level of encapsulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>A NonLinearSolver class instance ready for use.</strong></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SimpleTimeStepSelector</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.checkForOscillations">
<span class="sig-name descname"><span class="pre">checkForOscillations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">res</span></em>, <em class="sig-param"><span class="pre">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.checkForOscillations" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Check if residuals are oscillating. They are oscillating of
the ratio of forward and backwards differences for a specific
residual is negative.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.checkForStagnation">
<span class="sig-name descname"><span class="pre">checkForStagnation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">res</span></em>, <em class="sig-param"><span class="pre">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.checkForStagnation" title="Permalink to this definition"></a></dt>
<dd><p>Check if residuals have stagnated. Residuals are flagged as
stagnating if the relative change is smaller than
the tolerance (in absolute value).</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.solveMinistep">
<span class="sig-name descname"><span class="pre">solveMinistep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">drivingForces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.solveMinistep" title="Permalink to this definition"></a></dt>
<dd><p>Attempt to solve a single mini timestep while trying to avoid
stagnation or oscillating residuals.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.solveTimestep">
<span class="sig-name descname"><span class="pre">solveTimestep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">dT</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.solveTimestep" title="Permalink to this definition"></a></dt>
<dd><p>Solve a timestep for a non-linear system using one or more substeps
:param state0: State at the beginning of the timestep
:param dT: Timestep size. The solver will move forwards</p>
<blockquote>
<div><p>either as a single step or multiple substeps
depending on convergence rates and sub timestep
selection.</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Model inheriting from PhysicalModel with a
valid implementation of the “stepFunction”
member function.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>‘W’</strong> – Wells for the timestep. (struct)</p></li>
<li><p><strong>‘bc’</strong> – Boundary conditions for the problem (struct).</p></li>
<li><p><strong>‘src’</strong> – Source terms for the timestep (struct).</p></li>
<li><p><strong>NOTE</strong> – Wells, boundary conditions and source terms are the
standard types of external forces in MRST. However,
the model input determines which of these are
actually implemented for that specific step function.
Not all combinations are meaningful for all models.</p>
<p>Some models may implement other types of external
forces that have other names, specified in the
model’s “getValidDrivingForces” method.</p>
</li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – Problem state after timestep, i.e. if state0
held pressure, saturations, … at T_0, state
now holds the same values at T_0 + dT.</p></li>
<li><p><strong>report</strong> – Report struct, containing some standard
information (iteration count, convergence
status etc) in addition to any reports the
stepFunction contains.</p></li>
<li><p><strong>ministates</strong> – Cell array containing all ministeps used to get
to T = T_0 + dt. If the solver decided to take
a single step and was successful, this will
just be {state}.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PhysicalModel</p>
</div>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.stabilizeNewtonIncrements">
<span class="sig-name descname"><span class="pre">stabilizeNewtonIncrements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">problem</span></em>, <em class="sig-param"><span class="pre">dx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.stabilizeNewtonIncrements" title="Permalink to this definition"></a></dt>
<dd><p>#ok&lt;INUSL&gt;
Attempt to stabilize newton increment by changing the values
of the increments.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.LinearSolver">
<span class="sig-name descname"><span class="pre">LinearSolver</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.LinearSolver" title="Permalink to this definition"></a></dt>
<dd><p>The solver used to solve the linearized problems during the simulation.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.acceptanceFactor">
<span class="sig-name descname"><span class="pre">acceptanceFactor</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.acceptanceFactor" title="Permalink to this definition"></a></dt>
<dd><p>If we run out of iterations, this factor used for a relaxed tolerance check.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.alwaysUseStabilization">
<span class="sig-name descname"><span class="pre">alwaysUseStabilization</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'false'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.alwaysUseStabilization" title="Permalink to this definition"></a></dt>
<dd><p>Debug option to always use line search or relaxation</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.continueOnFailure">
<span class="sig-name descname"><span class="pre">continueOnFailure</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'false'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.continueOnFailure" title="Permalink to this definition"></a></dt>
<dd><p>Continue even if failure is reported by the model. Results are most likely not useful. Intended for nested nonlinear solvers.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.enforceResidualDecrease">
<span class="sig-name descname"><span class="pre">enforceResidualDecrease</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'false'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.enforceResidualDecrease" title="Permalink to this definition"></a></dt>
<dd><p>Abort a solution if no reduction is residual is happening.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.errorOnFailure">
<span class="sig-name descname"><span class="pre">errorOnFailure</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'true'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.errorOnFailure" title="Permalink to this definition"></a></dt>
<dd><p>If error on failure is not enabled, the solver will return even though it did not converge. May be useful for debugging. Results should not be relied upon if this is enabled. If errorOnFailure is disabled, the solver will continue after a failed timestep, treating it as a simply non-converged result with the maximum number of iterations</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.identifier">
<span class="sig-name descname"><span class="pre">identifier</span></span><em class="property"> <span class="pre">=</span> <span class="pre">&quot;''&quot;</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.identifier" title="Permalink to this definition"></a></dt>
<dd><p>String identifier for the nonlinear solver</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.linesearchConvergenceNames">
<span class="sig-name descname"><span class="pre">linesearchConvergenceNames</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'{}'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.linesearchConvergenceNames" title="Permalink to this definition"></a></dt>
<dd><p>Residual names to be checked in linesearch</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.linesearchDecreaseFactor">
<span class="sig-name descname"><span class="pre">linesearchDecreaseFactor</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.linesearchDecreaseFactor" title="Permalink to this definition"></a></dt>
<dd><p>Required reduction factor in residual (default 1)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.linesearchMaxIterations">
<span class="sig-name descname"><span class="pre">linesearchMaxIterations</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'10'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.linesearchMaxIterations" title="Permalink to this definition"></a></dt>
<dd><p>Max iterations in linesearch</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.linesearchReductionFactor">
<span class="sig-name descname"><span class="pre">linesearchReductionFactor</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1/2'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.linesearchReductionFactor" title="Permalink to this definition"></a></dt>
<dd><p>Reduction factor for each step in LS</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.linesearchReductionFn">
<span class="sig-name descname"><span class="pre">linesearchReductionFn</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'[]'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.linesearchReductionFn" title="Permalink to this definition"></a></dt>
<dd><p>Function for combining multiple residuals into value used by linesearch</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.linesearchResidualScaling">
<span class="sig-name descname"><span class="pre">linesearchResidualScaling</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'[]'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.linesearchResidualScaling" title="Permalink to this definition"></a></dt>
<dd><p>Residual scaling for each equation</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.maxIterations">
<span class="sig-name descname"><span class="pre">maxIterations</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'25'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.maxIterations" title="Permalink to this definition"></a></dt>
<dd><p>The max number of iterations during a ministep.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.maxRelaxation">
<span class="sig-name descname"><span class="pre">maxRelaxation</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1.0'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.maxRelaxation" title="Permalink to this definition"></a></dt>
<dd><p>Largest possible relaxation factor</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.maxTimestepCuts">
<span class="sig-name descname"><span class="pre">maxTimestepCuts</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'6'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.maxTimestepCuts" title="Permalink to this definition"></a></dt>
<dd><p>The maximum number of times the timestep can be halved before it is counted as a failed attempt</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.minIterations">
<span class="sig-name descname"><span class="pre">minIterations</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.minIterations" title="Permalink to this definition"></a></dt>
<dd><p>The minimum number of solves during a ministep.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.minRelaxation">
<span class="sig-name descname"><span class="pre">minRelaxation</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'0.5'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.minRelaxation" title="Permalink to this definition"></a></dt>
<dd><p>Lowest possible relaxation factor</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.oscillationThreshold">
<span class="sig-name descname"><span class="pre">oscillationThreshold</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1.0'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.oscillationThreshold" title="Permalink to this definition"></a></dt>
<dd><p>Fraction of non-converged values that must oscillate/stagnate before relaxation is activated</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.relaxationDecrement">
<span class="sig-name descname"><span class="pre">relaxationDecrement</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'[]'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.relaxationDecrement" title="Permalink to this definition"></a></dt>
<dd><p>Change in relaxation on stagnation/oscillation</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.relaxationIncrement">
<span class="sig-name descname"><span class="pre">relaxationIncrement</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'0.1'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.relaxationIncrement" title="Permalink to this definition"></a></dt>
<dd><p>Change in relaxation on stagnation/oscillation</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.relaxationParameter">
<span class="sig-name descname"><span class="pre">relaxationParameter</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.relaxationParameter" title="Permalink to this definition"></a></dt>
<dd><p>Relaxation parameter between 0 and 1.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.relaxationType">
<span class="sig-name descname"><span class="pre">relaxationType</span></span><em class="property"> <span class="pre">=</span> <span class="pre">&quot;'dampen'&quot;</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.relaxationType" title="Permalink to this definition"></a></dt>
<dd><p>Relaxation is reduced by this when stagnation occurs</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.reportLevel">
<span class="sig-name descname"><span class="pre">reportLevel</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'0'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.reportLevel" title="Permalink to this definition"></a></dt>
<dd><p>Amount of data to be output in report. Higher numbers may give more output.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.stagnateTol">
<span class="sig-name descname"><span class="pre">stagnateTol</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1e-2'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.stagnateTol" title="Permalink to this definition"></a></dt>
<dd><p>Stagnation tolerance - used in relaxation to determine of a residual value is no longer decreasing</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.timeStepSelector">
<span class="sig-name descname"><span class="pre">timeStepSelector</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.timeStepSelector" title="Permalink to this definition"></a></dt>
<dd><p>Subclass of SimpleTimeStepSelector used to select timesteps</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.useLinesearch">
<span class="sig-name descname"><span class="pre">useLinesearch</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'false'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.useLinesearch" title="Permalink to this definition"></a></dt>
<dd><p>True to enable line-search in residual</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.useRelaxation">
<span class="sig-name descname"><span class="pre">useRelaxation</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'false'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.useRelaxation" title="Permalink to this definition"></a></dt>
<dd><p>Boolean indicating if Newton increments should be relaxed.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.solvers.NonLinearSolver.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'[]'</span></em><a class="headerlink" href="#ad_core.solvers.NonLinearSolver.verbose" title="Permalink to this definition"></a></dt>
<dd><p>Verbose flag used to get extra output during simulation.</p>
</dd></dl>

</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.solvers.getNonLinearSolver">
<span class="sig-name descname"><span class="pre">getNonLinearSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.solvers.getNonLinearSolver" title="Permalink to this definition"></a></dt>
<dd><p>Set up reasonable defaults for the nonlinear solver for a field
simulation with significant size and complexity</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="p">=</span> <span class="n">getNonLinearSolver</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Simulation model (subclass of PhysicalModel).</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘DynamicTimesteps’</strong> – Set up a simple iteration count timestep
selector.</p></li>
<li><p><strong>‘useCPR’</strong> – Set up CPR-type preconditioner as the linear
solver. Will try to use the best known linear
solver (either AGMG or Matlab builtin at the
moment).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>solver</strong> – NonLinearSolver instance.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>simulateScheduleAD, NonLinearSolver</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-ad_core.timesteps">
<span id="time-step-selection"></span><h2>Time-step selection<a class="headerlink" href="#module-ad_core.timesteps" title="Permalink to this headline"></a></h2>
<dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.timesteps.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.timesteps.Contents" title="Permalink to this definition"></a></dt>
<dd><p>TIMESTEPS</p>
<dl class="simple">
<dt>Files</dt><dd><p>FactorTimeStepSelector         - Time step selector that always tries to increase the time-step
IterationCountTimeStepSelector - Adjust timesteps based with target iteration count, based on history
rampupTimesteps                - Create timesteps that ramp up geometrically
SimpleTimeStepSelector         - Time step selector base class
StateChangeTimeStepSelector    - The StateChangeTimeStepSelector is a time-step selector that attempts to</p>
</dd>
</dl>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.timesteps.FactorTimeStepSelector">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">FactorTimeStepSelector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.timesteps.FactorTimeStepSelector" title="Permalink to this definition"></a></dt>
<dd><p>Time step selector that always tries to increase the time-step</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">selector</span> <span class="p">=</span> <span class="n">FactorTimeStepSelector</span><span class="p">();</span>
<span class="n">selector</span> <span class="p">=</span> <span class="n">FactorTimeStepSelector</span><span class="p">(</span><span class="s">&#39;minRelativeAdjustment&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
<span class="n">selector</span> <span class="p">=</span> <span class="n">FactorTimeStepSelector</span><span class="p">(</span><span class="s">&#39;maxRelativeAdjustment&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>A simple time step selection class that always tries to multiply
successful time-steps with a factor (default 2) and otherwise cuts
on failure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>See properties</strong></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>Selector suitable for passing to the NonLinearSolver class.</strong></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IterationCountTimeStepSelector, NonLinearSolver,
StateChangeTimeStepSelector, SimpleTimeStepSelector</p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.timesteps.FactorTimeStepSelector.computeTimestep">
<span class="sig-name descname"><span class="pre">computeTimestep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">selector</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">dt_prev</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">state_prev</span></em>, <em class="sig-param"><span class="pre">state_curr</span></em>, <em class="sig-param"><span class="pre">forces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.timesteps.FactorTimeStepSelector.computeTimestep" title="Permalink to this definition"></a></dt>
<dd><p>#ok</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.timesteps.IterationCountTimeStepSelector">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">IterationCountTimeStepSelector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.timesteps.IterationCountTimeStepSelector" title="Permalink to this definition"></a></dt>
<dd><p>Adjust timesteps based with target iteration count, based on history</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">selector</span> <span class="p">=</span> <span class="n">IterationCountTimeStepSelector</span><span class="p">();</span>
<span class="n">selector</span> <span class="p">=</span> <span class="n">IterationCountTimeStepSelector</span><span class="p">(</span><span class="s">&#39;targetIterationCount&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Routine used for dynamic timestepping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>targetIterationCount</strong> – Desired number of iterations.</p></li>
<li><p><strong>iterationOffset</strong> – Uses [actual + iterationOffset] to calculate
the parameter. Larger values makes the step
selector less aggressive for iteration targets
near zero.</p></li>
<li><p><strong>(Other options)</strong> – Inherited from SimpleTimeStepSelector.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>Time step selector.</strong></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SimpleTimeStepSelector, NonLinearSolver</p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.timesteps.IterationCountTimeStepSelector.computeTimestep">
<span class="sig-name descname"><span class="pre">computeTimestep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">selector</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">dt_prev</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">state_prev</span></em>, <em class="sig-param"><span class="pre">state_curr</span></em>, <em class="sig-param"><span class="pre">forces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.timesteps.IterationCountTimeStepSelector.computeTimestep" title="Permalink to this definition"></a></dt>
<dd><p>Dynamically compute timestep</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.IterationCountTimeStepSelector.iterationOffset">
<span class="sig-name descname"><span class="pre">iterationOffset</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.IterationCountTimeStepSelector.iterationOffset" title="Permalink to this definition"></a></dt>
<dd><p>Offset to make iteration a bit smoother as a response function.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.IterationCountTimeStepSelector.targetIterationCount">
<span class="sig-name descname"><span class="pre">targetIterationCount</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.IterationCountTimeStepSelector.targetIterationCount" title="Permalink to this definition"></a></dt>
<dd><p>Desired number of nonlinear iterations per timestep.</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">SimpleTimeStepSelector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector" title="Permalink to this definition"></a></dt>
<dd><p>Time step selector base class</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">selector</span> <span class="p">=</span> <span class="n">SimpleTimeStepSelector</span><span class="p">();</span>
<span class="n">selector</span> <span class="p">=</span> <span class="n">SimpleTimeStepSelector</span><span class="p">(</span><span class="s">&#39;maxTimestep&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">day</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>The timestep selector base class is called by the NonLinearSolver to
determine timesteps, based on hard limits such as the min/max timesteps
as well as possibly more advanced features via the computeTimestep
method that can account for iteration count, residual reduction etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>See properties</strong></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>selector suitable for passing to the NonLinearSolver class.</strong></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IterationCountTimeStepSelector, NonLinearSolver,
StateChangeTimeStepSelector</p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.computeTimestep">
<span class="sig-name descname"><span class="pre">computeTimestep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">selector</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">dt_prev</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">state_prev</span></em>, <em class="sig-param"><span class="pre">state_curr</span></em>, <em class="sig-param"><span class="pre">forces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.computeTimestep" title="Permalink to this definition"></a></dt>
<dd><p>#ok
Compute timestep dynamically - does nothing for base class</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.newControlStep">
<span class="sig-name descname"><span class="pre">newControlStep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">selector</span></em>, <em class="sig-param"><span class="pre">control</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.newControlStep" title="Permalink to this definition"></a></dt>
<dd><p>Determine if controls have changed</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.controlsChanged">
<span class="sig-name descname"><span class="pre">controlsChanged</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.controlsChanged" title="Permalink to this definition"></a></dt>
<dd><p>Flag indicating that the controls have changed</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.firstRampupStep">
<span class="sig-name descname"><span class="pre">firstRampupStep</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.firstRampupStep" title="Permalink to this definition"></a></dt>
<dd><p>The first ministep attempted after controls have changed</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.firstRampupStepRelative">
<span class="sig-name descname"><span class="pre">firstRampupStepRelative</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.firstRampupStepRelative" title="Permalink to this definition"></a></dt>
<dd><p>Relative version of firstRampupStep</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.history">
<span class="sig-name descname"><span class="pre">history</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.history" title="Permalink to this definition"></a></dt>
<dd><p>Stored history used to pick next timestep</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.isFirstStep">
<span class="sig-name descname"><span class="pre">isFirstStep</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.isFirstStep" title="Permalink to this definition"></a></dt>
<dd><p>Flag indicating that we are at the start of the simulation</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.isStartOfCtrlStep">
<span class="sig-name descname"><span class="pre">isStartOfCtrlStep</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.isStartOfCtrlStep" title="Permalink to this definition"></a></dt>
<dd><p>Flag indicating the beginning of a control step</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.maxHistoryLength">
<span class="sig-name descname"><span class="pre">maxHistoryLength</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.maxHistoryLength" title="Permalink to this definition"></a></dt>
<dd><p>The maximum number of history steps stored</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.maxRelativeAdjustment">
<span class="sig-name descname"><span class="pre">maxRelativeAdjustment</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.maxRelativeAdjustment" title="Permalink to this definition"></a></dt>
<dd><p>Ensure dt_next &lt; dt_suggested*maxRelativeAdjustment</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.maxTimestep">
<span class="sig-name descname"><span class="pre">maxTimestep</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.maxTimestep" title="Permalink to this definition"></a></dt>
<dd><p>Hard upper limit on timestep in seconds</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.minRelativeAdjustment">
<span class="sig-name descname"><span class="pre">minRelativeAdjustment</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.minRelativeAdjustment" title="Permalink to this definition"></a></dt>
<dd><p>Ensure dt_next &gt; dt_suggested*minRelativeAdjustment</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.minTimestep">
<span class="sig-name descname"><span class="pre">minTimestep</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.minTimestep" title="Permalink to this definition"></a></dt>
<dd><p>Hard lower limit on timestep in seconds</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.previousControl">
<span class="sig-name descname"><span class="pre">previousControl</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.previousControl" title="Permalink to this definition"></a></dt>
<dd><p>Previous control seen by the selector used to determine when controls change.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.resetOnControlsChanged">
<span class="sig-name descname"><span class="pre">resetOnControlsChanged</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.resetOnControlsChanged" title="Permalink to this definition"></a></dt>
<dd><p>Reset when controls change</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.stepLimitedByHardLimits">
<span class="sig-name descname"><span class="pre">stepLimitedByHardLimits</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.stepLimitedByHardLimits" title="Permalink to this definition"></a></dt>
<dd><p>Flag indicating that hard limits and not any step algorithm was the cause of the previous timestep taken</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.SimpleTimeStepSelector.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.timesteps.SimpleTimeStepSelector.verbose" title="Permalink to this definition"></a></dt>
<dd><p>Extra output</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.timesteps.StateChangeTimeStepSelector">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">StateChangeTimeStepSelector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.timesteps.StateChangeTimeStepSelector" title="Permalink to this definition"></a></dt>
<dd><p>The StateChangeTimeStepSelector is a time-step selector that attempts to
ensure that certain properties of the state change at target rates during
the simulation. This can often be a good way of controlling timesteps and
minimizing numerical error if good estimates of the error are known.</p>
<p>See the doctoral dissertation of H. Cao “Development of techniques for
general purpose simulators”, Stanford, 2002.</p>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.StateChangeTimeStepSelector.relaxFactor">
<span class="sig-name descname"><span class="pre">relaxFactor</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'1'</span></em><a class="headerlink" href="#ad_core.timesteps.StateChangeTimeStepSelector.relaxFactor" title="Permalink to this definition"></a></dt>
<dd><p>Relaxation factor. Larger values mean less severe changes in time-steps.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.StateChangeTimeStepSelector.targetChangeAbs">
<span class="sig-name descname"><span class="pre">targetChangeAbs</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'[]'</span></em><a class="headerlink" href="#ad_core.timesteps.StateChangeTimeStepSelector.targetChangeAbs" title="Permalink to this definition"></a></dt>
<dd><p>Target change (absolute units). Double array of the same length as targetProps.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.StateChangeTimeStepSelector.targetChangeRel">
<span class="sig-name descname"><span class="pre">targetChangeRel</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'[]'</span></em><a class="headerlink" href="#ad_core.timesteps.StateChangeTimeStepSelector.targetChangeRel" title="Permalink to this definition"></a></dt>
<dd><p>Target change (relative units). This is a double array of the</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.timesteps.StateChangeTimeStepSelector.targetProps">
<span class="sig-name descname"><span class="pre">targetProps</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'{}'</span></em><a class="headerlink" href="#ad_core.timesteps.StateChangeTimeStepSelector.targetProps" title="Permalink to this definition"></a></dt>
<dd><p>The target properties to time control. Cell array of N strings,</p>
</dd></dl>

</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.timesteps.rampupTimesteps">
<span class="sig-name descname"><span class="pre">rampupTimesteps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">time</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.timesteps.rampupTimesteps" title="Permalink to this definition"></a></dt>
<dd><p>Create timesteps that ramp up geometrically</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">dT</span> <span class="p">=</span> <span class="n">rampupTimesteps</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">year</span><span class="p">,</span> <span class="mi">30</span><span class="o">*</span><span class="n">day</span><span class="p">)</span>
<span class="n">dT</span> <span class="p">=</span> <span class="n">rampupTimesteps</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">year</span><span class="p">,</span> <span class="mi">30</span><span class="o">*</span><span class="n">day</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function generates a timestep sequence for a given total time
interval that increases geometrically until it reaches some target
timestep. The rest of the interval is then divided into a number of
target timesteps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> – The total simulation time so that sum(dt) = time</p></li>
<li><p><strong>dt</strong> – Target timestep after initial ramp-up</p></li>
<li><p><strong>n</strong> – (OPTIONAL) Number of rampup steps. Defaults to 8.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dt</strong> – Array of timesteps.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The final timestep may be shorter than dt in order to exactly reach T.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-ad_core.upscale">
<span id="model-upscaling"></span><h2>Model upscaling<a class="headerlink" href="#module-ad_core.upscale" title="Permalink to this headline"></a></h2>
<dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.upscale.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.upscale.Contents" title="Permalink to this definition"></a></dt>
<dd><p>UPSCALE</p>
<dl class="simple">
<dt>Files</dt><dd><p>upscaleModelTPFA - Upscale a fine model into a coarser version using a partition vector
upscaleSchedule  - Upscale a schedule to a coarser model
upscaleState     - Create a upscaled state by simple processing of values</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.upscale.upscaleModelTPFA">
<span class="sig-name descname"><span class="pre">upscaleModelTPFA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">partition</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.upscale.upscaleModelTPFA" title="Permalink to this definition"></a></dt>
<dd><p>Upscale a fine model into a coarser version using a partition vector</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">modelcoarse</span> <span class="p">=</span> <span class="n">upscaleModelTPFA</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Given a fine model and a partition vector (created using standard
coarsegrid tools such as partitionUI), this routine makes a coarser
model with upscaled properties. Using somewhat reasonable defaults,
most parts of the routine can be overriden by better values if the user
already knows for instance transmissibilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Fine scale model. Subclass of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code>.</p></li>
<li><p><strong>partition</strong> – Partition vector. Length equal to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">model.G.cells.num</span></code>, with
positive indicator values. All cells with the same
indicator will be combined into a single coarse block.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘validatePartition’</strong> – Ensure partition is connected on the grid, and
numbered from 1…N without gaps.</p></li>
<li><p><strong>‘transCoarse’</strong> – Coarse transmissibilities. Will be calculated from
upscaled permeability if not provided.</p></li>
<li><p><strong>‘transFromRock’</strong> – Compute transmissibility from rock. Default is
true. If disabled, the coarse transmissibility
will be a sum instead.</p></li>
<li><p><strong>‘permCoarse’</strong> – Coarse permeability. Will be calculated using
harmonic averaging if not provided.</p></li>
<li><p><strong>‘neighborship’</strong> – Coarse neighborship (matching transCoarse). Will
be derived from fine grid if not provided.</p></li>
<li><p><strong>‘poroCoarse’</strong> – Coarse porosities. Computed from fine model using
a simple sum if not provided.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – Coarse model.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.upscale.upscaleSchedule" title="ad_core.upscale.upscaleSchedule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaleSchedule</span></code></a>, <a class="reference internal" href="#ad_core.upscale.upscaleState" title="ad_core.upscale.upscaleState"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaleState</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">generateCoarseGrid</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.upscale.upscaleSchedule">
<span class="sig-name descname"><span class="pre">upscaleSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.upscale.upscaleSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Upscale a schedule to a coarser model</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">schedule</span> <span class="p">=</span> <span class="n">upscaleSchedule</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">schedule</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – The coarse model the schedule is to be converted to.
Assumed to be derived from the fine model used with
schedule.</p></li>
<li><p><strong>schedule</strong> – Schedule to be upscaled.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>‘wellUpscaleMethod’</strong> – Upscaling method for well indices. The default is
to recompute the well indices in the new block.
Other options are ‘sum’, ‘harmonic’ and ‘mean’.
We recommend applying a dedicated upscaling
routine and replacing these values if well-bore
flow performance is important.</p></li>
<li><p><strong>‘bcUpscaleMethod’</strong> – Interpolation strategy used for boundary
conditions. Possible options:</p>
<blockquote>
<div><ul class="simple">
<li><p>linear: Default.</p></li>
<li><p>idw:    Inverse distance weighting</p></li>
<li><p>mean:   Mean value.</p></li>
<li><p>nearest: Nearest neighbor.</p></li>
</ul>
</div></blockquote>
<p>In addition, any unknown arguments will be passed
onto the interpolation routine used. Depending on
the dimensionality and the boundary conditions,
this is either <code class="xref mat mat-func docutils literal notranslate"><span class="pre">interp1</span></code> or <code class="xref mat mat-func docutils literal notranslate"><span class="pre">scatteredInterp</span></code>.</p>
</li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>schedule</strong> – Schedule upscaled for the coarse model.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Support for boundary conditions relies on interpolation. Results should
be examined before use for complex grids.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.upscale.upscaleModelTPFA" title="ad_core.upscale.upscaleModelTPFA"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaleModelTPFA</span></code></a>, <a class="reference internal" href="#ad_core.upscale.upscaleState" title="ad_core.upscale.upscaleState"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaleState</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">generateCoarseGrid</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.upscale.upscaleState">
<span class="sig-name descname"><span class="pre">upscaleState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">coarsemodel</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.upscale.upscaleState" title="Permalink to this definition"></a></dt>
<dd><p>Create a upscaled state by simple processing of values</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state_coarse</span> <span class="p">=</span> <span class="n">upscaleState</span><span class="p">(</span><span class="n">coarsemodel</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">state_fine</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Convert a state for a fine model into a realization of the same state
for a coarse model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coarsemodel</strong> – A coarse model derived from the fine model.</p></li>
<li><p><strong>model</strong> – The fine model. Subclass of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code>.</p></li>
<li><p><strong>state</strong> – State to be converted. Should correspond to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">model</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – Coarse state suitable for the coarsemodel.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.upscale.upscaleSchedule" title="ad_core.upscale.upscaleSchedule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaleSchedule</span></code></a>, <a class="reference internal" href="#ad_core.upscale.upscaleModelTPFA" title="ad_core.upscale.upscaleModelTPFA"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaleModelTPFA</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-ad_core.plotting">
<span id="plotting"></span><h2>Plotting<a class="headerlink" href="#module-ad_core.plotting" title="Permalink to this headline"></a></h2>
<dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.plotting.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.plotting.Contents" title="Permalink to this definition"></a></dt>
<dd><p>PLOTTING</p>
<dl class="simple">
<dt>Files</dt><dd><p>getPlotAfterStep       - Get a function that allows for dynamic plotting in <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>.
inspectFluidModel      - Create a interactive plotting panel for a given model that shows
plotReportIterations   - Plot nonlinear convergence behavior for simulateScheduleAD output
plotWellSols           - Plot well solutions from AD-solvers
simpleUIbar            - Undocumented Utility Function
simulationRuntimePanel - Internal function for drawing panel during simulation. See</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.plotting.getPlotAfterStep">
<span class="sig-name descname"><span class="pre">getPlotAfterStep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.plotting.getPlotAfterStep" title="Permalink to this definition"></a></dt>
<dd><p>Get a function that allows for dynamic plotting in <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">fn</span> <span class="p">=</span> <span class="n">getPlotAfterStep</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="s">&#39;plotWell&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>The <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a> function has a optional input argument
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">afterStepFn</span></code> that allows for dynamic plotting after each step in the
simulation, for instance to show how the well curves progress during the
simulation, or to print out extra information to the command window. This
function is an implementation of one such function, that can add both a
panel showing the simulation progress, as well as interactive plots for
well and reservoir quantities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state0</strong> – Initial state for simulateScheduleAD</p></li>
<li><p><strong>model</strong> – Simulation model which will be passed to simulateScheduleAD.</p></li>
<li><p><strong>schedule</strong> – The simulation schedule containing wells, driving forces
and time-steps that will be passed to simulateScheduleAD.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘plotWell’</strong> – Launch interactive plotting for well quantities
using <a class="reference internal" href="#ad_core.plotting.plotWellSols" title="ad_core.plotting.plotWellSols"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotWellSols</span></code></a></p></li>
<li><p><strong>‘plotReservoir’</strong> – Add an interactive plotting window for reservoir
quantities during the simulation. Note that, due to
limitations in the implementation, this window will
only be truly interactive after the simulation
finishes. You can, however, set the options (field for
plotting, locked color axis and so on) before
initiating the simulation itself.</p></li>
<li><p><strong>‘view’</strong> – View angle for the reservoir plotting. See Matlab
builtin <code class="xref mat mat-func docutils literal notranslate"><span class="pre">view</span></code> for more information. Defaults to
empty for no modification to the default.</p></li>
<li><p><strong>‘wells’</strong> – Wells for the reservoir plotting (using <a class="reference internal" href="core.html#core.plotting.plotWell" title="core.plotting.plotWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotWell</span></code></a>)</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>fn</strong> – Function handle suitable for the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">afterStepFn</span></code>
input in <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">fn</span> <span class="p">=</span> <span class="n">getPlotAfterStep</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="s">&#39;plotWell&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="n">simulateScheduleAD</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="s">&#39;afterStepFn&#39;</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>, <a class="reference internal" href="#ad_core.plotting.plotWellSols" title="ad_core.plotting.plotWellSols"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotWellSols</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.plotting.inspectFluidModel">
<span class="sig-name descname"><span class="pre">inspectFluidModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.plotting.inspectFluidModel" title="Permalink to this definition"></a></dt>
<dd><p>Create a interactive plotting panel for a given model that shows
different fluids properties.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="p">=</span> <span class="n">inspectFluidModel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Launch an interactive plotting interface for the fluid model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Some <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code>-derived class with a valid fluid model.
This function has primarily been tested for black-oil and
black-oil similar fluids.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘pressureRange’</strong> – An array of the pressures values to be used for
pressure-dependent properties. Defaults to
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">max(model.minimumPressure,</span> <span class="pre">0.1*barsa)</span></code> to
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">min(model.maximumPressure,</span> <span class="pre">600*barsa)</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Figure handle to the plotting panel.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.plotting.plotReportIterations">
<span class="sig-name descname"><span class="pre">plotReportIterations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">report</span></em>, <em class="sig-param"><span class="pre">schedule</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.plotting.plotReportIterations" title="Permalink to this definition"></a></dt>
<dd><p>Plot nonlinear convergence behavior for simulateScheduleAD output</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">plotReportIterations</span><span class="p">(</span><span class="n">report</span><span class="p">,</span> <span class="n">schedule</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Creates a plot in the current figure of the nonlinear convergence
behavior of a report and schedule pair. Timesteps and ministeps are
visualized, along with green and red boxes that indicate successful
and wasted iterations respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>report</strong> – Report as returned by <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>.</p></li>
<li><p><strong>schedule</strong> – The schedule passed to <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a> to produce the
report.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Nothing.</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.plotting.plotWellSols">
<span class="sig-name descname"><span class="pre">plotWellSols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">wellsols</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.plotting.plotWellSols" title="Permalink to this definition"></a></dt>
<dd><p>Plot well solutions from AD-solvers</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">plotWellSols</span><span class="p">(</span><span class="n">wellSols</span><span class="p">,</span> <span class="nb">time</span><span class="p">);</span>
<span class="n">plotWellSols</span><span class="p">(</span><span class="n">wellSols</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Open interactive plotting interface for well solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wellSols</strong> – Cell array of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nstep</span></code> by 1, each containing a uniform struct
array of well solution structures. For example, the first
output from <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>. Can also be a cell array
of such cell arrays, for comparing multiple simulation
scenarios.</p></li>
<li><p><strong>time</strong> – (OPTIONAL) The time for each timestep. If not provided, the
plotter will use step number as the x axis intead. If
wellSols is a cell array of multiple datasets, time should
also be a cell array, provided not all datasets use the same
timesteps.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘field’</strong> – Initial field for plotting (default: ‘bhp’).</p></li>
<li><p><strong>‘linestyles’</strong> – Cell array of line styles used for different datasets.</p></li>
<li><p><strong>‘markerstyles’</strong> – Marker array of line styles used for different
datasets.</p></li>
<li><p><strong>‘datasetnames’</strong> – A cell array of dataset names used for the legend when
plotting multiple datasets.</p></li>
<li><p><strong>‘timescale’</strong> – A string for the default choice for axis time-scale. A
string which matches either choice:
‘days’, ‘minutes’, ‘seconds’, ‘hours’, ‘years’</p></li>
<li><p><strong>toggleOn</strong> – A string followed by true/false to enable/disable the
toggles in the Misc panel. The strings are: ‘grid’,
‘logx’, ‘logy’, ‘marker’, ‘legend’, ‘cumsum’, ‘abs’,
‘zoom’, ‘stairs’, and ‘ctrl’</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fh</strong> – figure handle to plotting panel</p></li>
<li><p><strong>inject</strong> – function handle used to dynamically inject new datasets into
the viewer (for example, from a running simulation). Same
syntax as the base function, but does not support additional
varargin.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.plotting.simpleUIbar">
<span class="sig-name descname"><span class="pre">simpleUIbar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">parent</span></em>, <em class="sig-param"><span class="pre">data</span></em>, <em class="sig-param"><span class="pre">start</span></em>, <em class="sig-param"><span class="pre">height</span></em>, <em class="sig-param"><span class="pre">txt</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.plotting.simpleUIbar" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.plotting.simulationRuntimePanel">
<span class="sig-name descname"><span class="pre">simulationRuntimePanel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">states</span></em>, <em class="sig-param"><span class="pre">ctrl_reports</span></em>, <em class="sig-param"><span class="pre">solver</span></em>, <em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">simtime</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.plotting.simulationRuntimePanel" title="Permalink to this definition"></a></dt>
<dd><p>Internal function for drawing panel during simulation. See
getPlotAfterStep.</p>
</dd></dl>

</div>
<div class="section" id="module-ad_core.backends">
<span id="automatic-differentation-backends"></span><h2>Automatic differentation backends<a class="headerlink" href="#module-ad_core.backends" title="Permalink to this headline"></a></h2>
<dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.backends.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.backends.Contents" title="Permalink to this definition"></a></dt>
<dd><p>BACKENDS</p>
<dl class="simple">
<dt>Files</dt><dd><p>AutoDiffBackend - Automatic differentiation backend class</p>
</dd>
</dl>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.backends.AutoDiffBackend">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">AutoDiffBackend</span></span><a class="headerlink" href="#ad_core.backends.AutoDiffBackend" title="Permalink to this definition"></a></dt>
<dd><p>Automatic differentiation backend class</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">backend</span> <span class="p">=</span> <span class="n">AutoDiffBackend</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Base class for automatic differentiation backends. A backend is an
implementation of automatic differentation and must support the
initialization of one (or more) variables as AD objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>Backend</strong> – Initialized class instance</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">DiagonalAutoDiffBackend</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SparseAutoDiffBackend</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.AutoDiffBackend.AutoDiffBackend">
<span class="sig-name descname"><span class="pre">AutoDiffBackend</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.AutoDiffBackend.AutoDiffBackend" title="Permalink to this definition"></a></dt>
<dd><p>Class constructor.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.AutoDiffBackend.convertToAD">
<span class="sig-name descname"><span class="pre">convertToAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">backend</span></em>, <em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">sample</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.AutoDiffBackend.convertToAD" title="Permalink to this definition"></a></dt>
<dd><p>Given a <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sample</span></code> AD object, convert <code class="xref mat mat-func docutils literal notranslate"><span class="pre">v</span></code> to AD.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.AutoDiffBackend.getBackendDescription">
<span class="sig-name descname"><span class="pre">getBackendDescription</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">backend</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.AutoDiffBackend.getBackendDescription" title="Permalink to this definition"></a></dt>
<dd><p>Get a text string describing the backend</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.AutoDiffBackend.initVariablesAD">
<span class="sig-name descname"><span class="pre">initVariablesAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">backend</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.AutoDiffBackend.initVariablesAD" title="Permalink to this definition"></a></dt>
<dd><p>Initialize variables as AD</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.AutoDiffBackend.updateDiscreteOperators">
<span class="sig-name descname"><span class="pre">updateDiscreteOperators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">backend</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.AutoDiffBackend.updateDiscreteOperators" title="Permalink to this definition"></a></dt>
<dd><p>Modify model/operators for use with backend</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="p">=</span> <span class="n">backend</span><span class="p">.</span><span class="n">updateDiscreteOperators</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Detailed description of function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>backend</strong> – Class instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>model</strong> – Model with updated operators</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Base class implements no modifications. This function is
automatically called as a part of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">validateModel</span></code>.</p>
</div>
</dd></dl>

</dd></dl>

<span class="target" id="module-ad_core.backends.diagonal"></span><dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.backends.diagonal.Contents" title="Permalink to this definition"></a></dt>
<dd><p>DIAGONAL</p>
<dl class="simple">
<dt>Files</dt><dd><p>ConservationLawJacobian - Very experimental class for Jacobian of a conservation law
DiagonalAutoDiffBackend - Automatic differentiation backend class (diagonal representation)
DiagonalJacobian        - Diagonal representation of a Jacobian
FixedWidthJacobian      - Structured subset of a diagonal jacobian
GenericAD               - GenericAD is the testbed for future updates to the ADI class. All</p>
</dd>
</dl>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.ConservationLawJacobian">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">ConservationLawJacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">acc</span></em>, <em class="sig-param"><span class="pre">flux</span></em>, <em class="sig-param"><span class="pre">div_options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.ConservationLawJacobian" title="Permalink to this definition"></a></dt>
<dd><p>Very experimental class for Jacobian of a conservation law</p>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalAutoDiffBackend">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">DiagonalAutoDiffBackend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalAutoDiffBackend" title="Permalink to this definition"></a></dt>
<dd><p>Automatic differentiation backend class (diagonal representation)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">backend</span> <span class="p">=</span> <span class="n">DiagonalAutoDiffBackend</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This backend uses a diagonal representation (with an optional set
of operators that produce intermediate diagonal representations).
The primary use of this class is for problems with a large number
of independent primary variables, with many cell-wise operations
(e.g. compositional or similar problems).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>Backend</strong> – Initialized class instance</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">AutoDiffBackend</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SparseAutoDiffBackend</span></code></p>
</div>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalAutoDiffBackend.modifyOperators">
<span class="sig-name descname"><span class="pre">modifyOperators</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'true'</span></em><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalAutoDiffBackend.modifyOperators" title="Permalink to this definition"></a></dt>
<dd><p>Update the operators and use custom versions that return <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FixedWidthJacobian</span></code> instances</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalJacobian">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">DiagonalJacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">d</span></em>, <em class="sig-param"><span class="pre">dim</span></em>, <em class="sig-param"><span class="pre">subset</span></em>, <em class="sig-param"><span class="pre">useMex</span></em>, <em class="sig-param"><span class="pre">useRowMajorMemory</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalJacobian" title="Permalink to this definition"></a></dt>
<dd><p>Diagonal representation of a Jacobian</p>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalJacobian.double">
<span class="sig-name descname"><span class="pre">double</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">D</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalJacobian.double" title="Permalink to this definition"></a></dt>
<dd><p>Convert to sparse</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalJacobian.full">
<span class="sig-name descname"><span class="pre">full</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">D</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalJacobian.full" title="Permalink to this definition"></a></dt>
<dd><p>Convert to full matrix - may be very expensive!</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalJacobian.rdivide">
<span class="sig-name descname"><span class="pre">rdivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalJacobian.rdivide" title="Permalink to this definition"></a></dt>
<dd><p>Right matrix divide: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h=u/v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalJacobian.sparse">
<span class="sig-name descname"><span class="pre">sparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">D</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalJacobian.sparse" title="Permalink to this definition"></a></dt>
<dd><p>Convert diagonal representation into a sparse representation</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalJacobian.subsetPlus">
<span class="sig-name descname"><span class="pre">subsetPlus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">subs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalJacobian.subsetPlus" title="Permalink to this definition"></a></dt>
<dd><p>Increment a subset of the Jacobian in place. This can be
faster than using subsasgn that may produce intermediate
class instances, for example
x(subs) = x(subs) + y(subs)
will end up as
tmp1 = x(subs);
tmp2 = y(subs);
tmp3 = tmp1 + tmp2;
x(subs) = tmp3;</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalJacobian.subsetsEqualNoZeroCheck">
<span class="sig-name descname"><span class="pre">subsetsEqualNoZeroCheck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">y</span></em>, <em class="sig-param"><span class="pre">xsubset</span></em>, <em class="sig-param"><span class="pre">ysubset</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalJacobian.subsetsEqualNoZeroCheck" title="Permalink to this definition"></a></dt>
<dd><p>Check if subsets are equal (ignoring zeros in subset as
“always fits”)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalJacobian.diagonal">
<span class="sig-name descname"><span class="pre">diagonal</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalJacobian.diagonal" title="Permalink to this definition"></a></dt>
<dd><p>Dense matrix of diagonal derivatives</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalJacobian.dim">
<span class="sig-name descname"><span class="pre">dim</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalJacobian.dim" title="Permalink to this definition"></a></dt>
<dd><p>Vector: First dimension is the number of variables in block, while the second is the number of columns</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.DiagonalJacobian.subset">
<span class="sig-name descname"><span class="pre">subset</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.backends.diagonal.DiagonalJacobian.subset" title="Permalink to this definition"></a></dt>
<dd><p>Indices corresponding to the subset (if empty, class contains the full set)</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.FixedWidthJacobian">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">FixedWidthJacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">d</span></em>, <em class="sig-param"><span class="pre">dims</span></em>, <em class="sig-param"><span class="pre">map</span></em>, <em class="sig-param"><span class="pre">subset</span></em>, <em class="sig-param"><span class="pre">parentSubset</span></em>, <em class="sig-param"><span class="pre">useMex</span></em>, <em class="sig-param"><span class="pre">useRowMajorMemory</span></em>, <em class="sig-param"><span class="pre">mapName</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.FixedWidthJacobian" title="Permalink to this definition"></a></dt>
<dd><p>Structured subset of a diagonal jacobian</p>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.FixedWidthJacobian.map">
<span class="sig-name descname"><span class="pre">map</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.backends.diagonal.FixedWidthJacobian.map" title="Permalink to this definition"></a></dt>
<dd><p>Map to the underlying DiagonalJacobian representation. Two FixedWidthJacobians of the same map can be multiplied together, etc.</p>
</dd></dl>

</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.GenericAD">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">GenericAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">val</span></em>, <em class="sig-param"><span class="pre">jac</span></em>, <em class="sig-param"><span class="pre">numVars</span></em>, <em class="sig-param"><span class="pre">offset</span></em>, <em class="sig-param"><span class="pre">useMex</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.GenericAD" title="Permalink to this definition"></a></dt>
<dd><p>GenericAD is the testbed for future updates to the ADI class. All
features herein are subject to rapid change.</p>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.GenericAD.rdivide">
<span class="sig-name descname"><span class="pre">rdivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.GenericAD.rdivide" title="Permalink to this definition"></a></dt>
<dd><p>Right element-wise division: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">u./v</span></code></p>
</dd></dl>

</dd></dl>

<span class="target" id="module-ad_core.backends.diagonal.operators"></span><dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.operators.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.backends.diagonal.operators.Contents" title="Permalink to this definition"></a></dt>
<dd><p>OPERATORS</p>
<dl class="simple">
<dt>Files</dt><dd><p>blockCSRtoSparse              - Convert a block CSR matrix to Matlab’s scalar CSC matrix (block-wise
discreteDivergenceDiagonalJac - Undocumented Utility Function
discreteDivergence            - Discrete divergence for the GenericAD library
faceAverage                   - Face average operator for the GenericAD library
singlePointUpwind             - Single-point upwind for the GenericAD library
twoPointGradient              - Discrete gradient for the GenericAD library</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.operators.blockCSRtoSparse">
<span class="sig-name descname"><span class="pre">blockCSRtoSparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">verb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.operators.blockCSRtoSparse" title="Permalink to this definition"></a></dt>
<dd><p>Convert a block CSR matrix to Matlab’s scalar CSC matrix (block-wise
ordering)</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.operators.discreteDivergence">
<span class="sig-name descname"><span class="pre">discreteDivergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">acc</span></em>, <em class="sig-param"><span class="pre">flux</span></em>, <em class="sig-param"><span class="pre">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.operators.discreteDivergence" title="Permalink to this definition"></a></dt>
<dd><p>Discrete divergence for the GenericAD library</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.operators.discreteDivergenceDiagonalJac">
<span class="sig-name descname"><span class="pre">discreteDivergenceDiagonalJac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">acc</span></em>, <em class="sig-param"><span class="pre">jac</span></em>, <em class="sig-param"><span class="pre">opt</span></em>, <em class="sig-param"><span class="pre">getConservation</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.operators.discreteDivergenceDiagonalJac" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.operators.faceAverage">
<span class="sig-name descname"><span class="pre">faceAverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">N</span></em>, <em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">useMex</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.operators.faceAverage" title="Permalink to this definition"></a></dt>
<dd><p>Face average operator for the GenericAD library</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.operators.singlePointUpwind">
<span class="sig-name descname"><span class="pre">singlePointUpwind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">flag</span></em>, <em class="sig-param"><span class="pre">N</span></em>, <em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">useMex</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.operators.singlePointUpwind" title="Permalink to this definition"></a></dt>
<dd><p>Single-point upwind for the GenericAD library</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.operators.twoPointGradient">
<span class="sig-name descname"><span class="pre">twoPointGradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">N</span></em>, <em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">M</span></em>, <em class="sig-param"><span class="pre">useMex</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.operators.twoPointGradient" title="Permalink to this definition"></a></dt>
<dd><p>Discrete gradient for the GenericAD library</p>
</dd></dl>

<span class="target" id="module-ad_core.backends.diagonal.utils"></span><dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.backends.diagonal.utils.Contents" title="Permalink to this definition"></a></dt>
<dd><p>UTILS</p>
<dl class="simple">
<dt>Files</dt><dd><p>diagMult                         - Internal function for diagonal multiplication in AD code
diagProductMult                  - Undocumented Utility Function
double2GenericAD                 - Convert a double to GenericAD variable, using a sample GenericAD variable for dimensions
getSparseArguments               - Get sparse matrix indices
getSparseBlocks                  - Get sparse blocks
incrementSubset                  - Update a subset directly
initVariablesAD_diagonal         - Diagonal AD initializer
initVariablesAD_diagonalRowMajor - Diagonal AD initializer
initVariablesAD_oneBlock         - Initialize a set of automatic differentiation variables (single block)
matrixDims                       - Overloadable version of size</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.diagMult">
<span class="sig-name descname"><span class="pre">diagMult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">M</span></em>, <em class="sig-param"><span class="pre">D</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.utils.diagMult" title="Permalink to this definition"></a></dt>
<dd><p>Internal function for diagonal multiplication in AD code</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.diagProductMult">
<span class="sig-name descname"><span class="pre">diagProductMult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">v1</span></em>, <em class="sig-param"><span class="pre">v2</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">y</span></em>, <em class="sig-param"><span class="pre">D1</span></em>, <em class="sig-param"><span class="pre">D2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.utils.diagProductMult" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.double2GenericAD">
<span class="sig-name descname"><span class="pre">double2GenericAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">sample</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.utils.double2GenericAD" title="Permalink to this definition"></a></dt>
<dd><p>Convert a double to GenericAD variable, using a sample GenericAD variable for dimensions</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="p">=</span> <span class="n">double2GenericAD</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">adivar</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> – Double to be converted to GenericAD.</p></li>
<li><p><strong>sample</strong> – Sample variable of the type GenericAD to be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>u</strong> – Variable with same type as sample and same value as u
initially had. If u is a GenericAD class instance, u will have zero
jacobians with the same number of primary variables as the
jacobians of sample.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">GenericAD</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.getSparseArguments">
<span class="sig-name descname"><span class="pre">getSparseArguments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">M</span></em>, <em class="sig-param"><span class="pre">ioffset</span></em>, <em class="sig-param"><span class="pre">joffset</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.utils.getSparseArguments" title="Permalink to this definition"></a></dt>
<dd><p>Get sparse matrix indices</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.getSparseBlocks">
<span class="sig-name descname"><span class="pre">getSparseBlocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.utils.getSparseBlocks" title="Permalink to this definition"></a></dt>
<dd><p>Get sparse blocks</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.incrementSubset">
<span class="sig-name descname"><span class="pre">incrementSubset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">subs</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.utils.incrementSubset" title="Permalink to this definition"></a></dt>
<dd><p>Update a subset directly</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.initVariablesAD_diagonal">
<span class="sig-name descname"><span class="pre">initVariablesAD_diagonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.utils.initVariablesAD_diagonal" title="Permalink to this definition"></a></dt>
<dd><p>Diagonal AD initializer</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.initVariablesAD_diagonalRowMajor">
<span class="sig-name descname"><span class="pre">initVariablesAD_diagonalRowMajor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.utils.initVariablesAD_diagonalRowMajor" title="Permalink to this definition"></a></dt>
<dd><p>Diagonal AD initializer</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.initVariablesAD_oneBlock">
<span class="sig-name descname"><span class="pre">initVariablesAD_oneBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.utils.initVariablesAD_oneBlock" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a set of automatic differentiation variables (single block)</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.backends.diagonal.utils.matrixDims">
<span class="sig-name descname"><span class="pre">matrixDims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.diagonal.utils.matrixDims" title="Permalink to this definition"></a></dt>
<dd><p>Overloadable version of size</p>
</dd></dl>

<span class="target" id="module-ad_core.backends.sparse"></span><dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.backends.sparse.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.backends.sparse.Contents" title="Permalink to this definition"></a></dt>
<dd><p>SPARSE</p>
<dl class="simple">
<dt>Files</dt><dd><p>SparseAutoDiffBackend - Automatic differentiation backend class (sparse representation)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.backends.sparse.SparseAutoDiffBackend">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">SparseAutoDiffBackend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.sparse.SparseAutoDiffBackend" title="Permalink to this definition"></a></dt>
<dd><p>Automatic differentiation backend class (sparse representation)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">backend</span> <span class="p">=</span> <span class="n">SparseAutoDiffBackend</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This version of the AD backend uses different types of sparse
blocks to represent derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>Backend</strong> – Initialized class instance</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">AutoDiffBackend</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">DiagonalAutoDiffBackend</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.backends.sparse.SparseAutoDiffBackend.updateDiscreteOperators">
<span class="sig-name descname"><span class="pre">updateDiscreteOperators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">backend</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.backends.sparse.SparseAutoDiffBackend.updateDiscreteOperators" title="Permalink to this definition"></a></dt>
<dd><p>Do nothing</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.backends.sparse.SparseAutoDiffBackend.useBlocks">
<span class="sig-name descname"><span class="pre">useBlocks</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.backends.sparse.SparseAutoDiffBackend.useBlocks" title="Permalink to this definition"></a></dt>
<dd><p>Organize Jacobian as a set of blocks, instead of one large AD matrix</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ad_core.utils">
<span id="utilities"></span><h2>Utilities<a class="headerlink" href="#module-ad_core.utils" title="Permalink to this headline"></a></h2>
<dl class="mat script">
<dt class="sig sig-object mat" id="ad_core.utils.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#ad_core.utils.Contents" title="Permalink to this definition"></a></dt>
<dd><p>UTILS</p>
<dl class="simple">
<dt>Files</dt><dd><p>addPropertyDependence                 - Document dependencies and external dependencies
addFluxesFromSourcesAndBC             - Add in fluxes imposed by sources and face boundary conditions
assignValue                           - Assign values to ADI object by way of indices, without changing jacobians
assignWellValuesFromControl           - Assign wellSol values when values are set as controls
bc2ADbc                               - INTERNAL DEPRECATED FUNCTION: Intentionally undocumented.
checkWellConvergence                  - Compute convergence for wells.
CNV_MBConvergence                     - Compute convergence based on total mass balance and maximum residual mass balance.
calculatePhaseRate                    - Undocumented Utility Function
combineEquations                      - Combine equations. For doubles, this is equivialent to a vertical
combineSchedules                      - Combine multiple schedules to form a schedule with multiple controls
compressSchedule                      - Compress schedule to take the longest possible timesteps while honoring controls
computeCpGeometry                     - Undocumented Utility Function
computeSourcesAndBoundaryConditionsAD - Compute phase-pseudocomponent source terms (compatible with AD codes)
convert2MSWell                        - Utility for Converting Standard Well Structure to Multi-Segment Type
convertDeckScheduleToMRST             - Convert deck-type schedule to MRST style schedule
convertIncompWellSols                 - Convert wellSols from incomp module to format used in ad-core/ad-blackoil
convertReportToSchedule               - Create a new schedule based on actual ministeps from a simulation report
convertReservoirFluxesToSurface       - Compute surface fluxes from reservoir fluxes
criticalPointChop                     - Perform one or two-sided stability chop for an updated value
crossFlowMixture                      - Undocumented Utility Function
crossFlowMixtureDensity               - Undocumented Utility Function
double2ADI                            - Convert a double to ADI variable, using a sample ADI variable for dimensions
estimateCompositionCFL                - Undocumented Utility Function
estimateSaturationCFL                 - Undocumented Utility Function
expandIfUniform                       - Utility which reverses “value” compaction. If given a matrix (logical
expandMatrixToCell                    - Expand a matrix into cell arrays. Typical usage: Converting state
faceUpstr                             - Perform single-point upwinding of cell values to face
fastInterpTable                       - Fast interpolation of table, using griddedInterpolant
filterSchedule                        - Filter unused controls from a schedule
getBoundaryConditionFluxesAD          - Get boundary condition fluxes for a given set of values
getCellMajorReordering                - Get equation ordering transforming variable major to cell major ordering
getConvergenceValuesCNV               - Compute convergence based on total mass balance and maximum residual mass balance.
getConvergenceValuesWells             - Undocumented Utility Function
getEquilPC                            - Undocumented Utility Function
getFractionalFlowMagnitude            - Undocumented Utility Function
getGridSYMRCMOrdering                 - Undocumented Utility Function
getMultiDimInterpolator               - Get a multidimensional interpolator (with support for ADI varibles)
getMultipliers                        - Get dynamic multiplier values for reservoir quantities
getPerforationToWellMapping           - Get map from global perforation number to global well index.
getReportMinisteps                    - Get the timesteps used for the ministeps of a report
getReportOutput                       - Get output from report after call to simulateScheduleAD
getReservoirModel                     - Get the underlying reservoir model of a WrapperModel
getSampleAD                           - Utility for getting a AD value if it exists from a list of possible
getSimulationTime                     - Get the global time for a set of states produced by simulateScheduleAD
getSourceFluxesAD                     - Short description
getWellOutput                         - Extract values from wellsols.
HandleStruct                          -
initWellSolAD                         - Set up well solution struct for a automatic differentiation model
interpolateIDW                        - Undocumented Utility Function
makeScheduleConsistent                - Ensure that a schedule is consistent in terms of well counts/perforations
mergeOrderedArrays                    - Merge two sets of cells that are similar in that they may contain
numelData                             - Alias for numel. Useful for writing code which handles either
numelValue                            - Undocumented Utility Function
padRatesAndCompi                      - Pad one/two/threephase values with zeros corresponding to missing phases.
phaseDensitiesTobfactor               - Convert densities to b-facctors, accounting for dissolution
pressureBCContrib                     - LEGACY FUNCTION: Intentionally undocumented.
pressureBCContribADI                  - LEGACY FUNCTION: Intentionally undocumented.
printConvergenceReport                - Print a neatly formatted convergence report
readSummaryLocal                      - Undocumented Utility Function
recoverVars                           - Recover previously eliminated variables x at position n using solutions sol
refineSchedule                        - Compute a finer schedule, including new time steps but preserving the time steps of the original
reorderForILU                         - Attempt to reorder a set of equations so that the diagonal is non-zero
ResultHandler                         - Class for storing and retrieving simulation results, either in memory or stored to disk
selectLinearSolverAD                  - Undocumented Utility Function
selectModelFromDeck                   - Select simulation model from a ECLIPSE/FrontSim style input deck
setupOperatorsTPFA                    - Set up helper structure for solvers based on automatic differentiation.
setMPFADiscretization                 - Set MPFA discretization on a model
setReservoirModel                     - Set the underlying reservoir model of a WrapperModel
setTimeDiscretization                 - Set the discretization choice for a model
setWellSign                           - Ensure that wells have a defined sign. Will attempt to guess based on controls.
setWENODiscretization                 - Set WENO discretization on a model
simpleSchedule                        - Make a schedule with varying timesteps and fixed wells/bc/src terms
sizeJac                               - Undocumented Utility Function
splitFaceCellValue                    - Split multi-valued function into cell and face values
splitMatrixForReduction               - Split matrix A and right-hand side into blocks
standaloneSolveAD                     - Solve a single time-step with AD solvers for given forces
structPropEvaluated                   - Undocumented Utility Function
terniaryWellPlot                      - Plot well curves (water, gas, oil and optionally BHP) for wellSols
wellSolToVector                       - Extract selected summary vectors from cell array of well solutions</p>
</dd>
</dl>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">ResultHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.ResultHandler" title="Permalink to this definition"></a></dt>
<dd><p>Class for storing and retrieving simulation results, either in memory or stored to disk</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">handler</span> <span class="p">=</span> <span class="n">ResultHandler</span><span class="p">()</span>

<span class="n">handler</span> <span class="p">=</span> <span class="n">ResultHandler</span><span class="p">(</span><span class="s">&#39;dataPrefix&#39;</span><span class="p">,</span> <span class="s">&#39;mydata&#39;</span><span class="p">,</span> <span class="s">&#39;writeToDisk&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This class can be used to store and retrieve simulation results. It
is somewhat similar to a cell array in use, although more limited.</p>
<p>Take a look at the class declaration to get more information.</p>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Setup handler</span>
<span class="n">handler</span> <span class="p">=</span> <span class="n">ResultHandler</span><span class="p">(</span><span class="s">&#39;dataprefix&#39;</span><span class="p">,</span> <span class="s">&#39;mydata&#39;</span><span class="p">,</span> <span class="s">&#39;writeToDisk&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="c">% Write result</span>
<span class="n">handler</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="p">=</span> <span class="p">{</span><span class="s">&#39;hello&#39;</span><span class="p">};</span>
<span class="c">% Read result from disk and print</span>
<span class="nb">disp</span><span class="p">(</span><span class="n">handler</span><span class="p">{</span><span class="mi">1</span><span class="p">})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>Class instance that in some limited aspects acts like a cell array</strong></p>
</dd>
</dl>
<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.getByTime">
<span class="sig-name descname"><span class="pre">getByTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">handler</span></em>, <em class="sig-param"><span class="pre">time</span></em>, <em class="sig-param"><span class="pre">tol</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.ResultHandler.getByTime" title="Permalink to this definition"></a></dt>
<dd><p>Get by time, within some tolerance</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.getClosestByTime">
<span class="sig-name descname"><span class="pre">getClosestByTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">handler</span></em>, <em class="sig-param"><span class="pre">time</span></em>, <em class="sig-param"><span class="pre">reverse</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.ResultHandler.getClosestByTime" title="Permalink to this definition"></a></dt>
<dd><p>Find closest by time (iterating through all states)</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.getFirstByFunction">
<span class="sig-name descname"><span class="pre">getFirstByFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">handler</span></em>, <em class="sig-param"><span class="pre">fn</span></em>, <em class="sig-param"><span class="pre">reverse</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.ResultHandler.getFirstByFunction" title="Permalink to this definition"></a></dt>
<dd><p>Seek in the handler data, returing the first entry that
fullfills an anonymous function. Can seek forward or
backwards.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.writeToFile">
<span class="sig-name descname"><span class="pre">writeToFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">handler</span></em>, <em class="sig-param"><span class="pre">data</span></em>, <em class="sig-param"><span class="pre">id</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.ResultHandler.writeToFile" title="Permalink to this definition"></a></dt>
<dd><p>#ok</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.cleardir">
<span class="sig-name descname"><span class="pre">cleardir</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.utils.ResultHandler.cleardir" title="Permalink to this definition"></a></dt>
<dd><p>Internal data storage</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.data">
<span class="sig-name descname"><span class="pre">data</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.utils.ResultHandler.data" title="Permalink to this definition"></a></dt>
<dd><p>Flag indicating if verbose output is on. Will output storage and</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.dataDirectory">
<span class="sig-name descname"><span class="pre">dataDirectory</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.utils.ResultHandler.dataDirectory" title="Permalink to this definition"></a></dt>
<dd><p>The folder under directory where we will store results. Will be</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.dataFolder">
<span class="sig-name descname"><span class="pre">dataFolder</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.utils.ResultHandler.dataFolder" title="Permalink to this definition"></a></dt>
<dd><p>Data will be stored in the format &lt;dataPrefix&gt;&lt;index&gt; so that</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.dataPrefix">
<span class="sig-name descname"><span class="pre">dataPrefix</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.utils.ResultHandler.dataPrefix" title="Permalink to this definition"></a></dt>
<dd><p>Extension used (default: .mat for Matlab, _oct.mat for Octave)</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.extension">
<span class="sig-name descname"><span class="pre">extension</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.utils.ResultHandler.extension" title="Permalink to this definition"></a></dt>
<dd><p>Flags passed on to MATLAB builtin ‘save’. Consider ‘-v7’ if</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.saveflags">
<span class="sig-name descname"><span class="pre">saveflags</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.utils.ResultHandler.saveflags" title="Permalink to this definition"></a></dt>
<dd><p>Clear directory on startup</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.storeInMemory">
<span class="sig-name descname"><span class="pre">storeInMemory</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.utils.ResultHandler.storeInMemory" title="Permalink to this definition"></a></dt>
<dd><p>Directory where data in general is stored.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="ad_core.utils.ResultHandler.writeToDisk">
<span class="sig-name descname"><span class="pre">writeToDisk</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#ad_core.utils.ResultHandler.writeToDisk" title="Permalink to this definition"></a></dt>
<dd><p>Boolean indicating if the class should store results in memory</p>
</dd></dl>

</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.CNV_MBConvergence">
<span class="sig-name descname"><span class="pre">CNV_MBConvergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">problem</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.CNV_MBConvergence" title="Permalink to this definition"></a></dt>
<dd><p>Compute convergence based on total mass balance and maximum residual mass balance.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">converged</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">evaluated</span><span class="p">]</span> <span class="p">=</span> <span class="n">CNV_MBConvergence</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">problem</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Compute CNV/MB type convergence similar to what is used for black
oil convergence in commercial simulators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Subclass of PhysicalModel. Strongly suggested to be
some black oil variant, as this convergence function
does <em>not</em> account for general residual convergence.</p></li>
<li><p><strong>problem</strong> – LinearizedProblem class instance we want to test for
convergence.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>convergence</strong> – Boolean indicating if the state used to produce the
LinearizedProblem has converged.</p></li>
<li><p><strong>values</strong> – 1 by 6 array containing mass balance in the first
three terms followed by cnv in the last three. The
phase ordering is assumed to be oil, water, gas.
Phases present will return a zero in their place.</p></li>
<li><p><strong>evaluated</strong> – Logical array into problem.equations indicating which
residual equations we have actually checked
convergence for.</p></li>
<li><p><strong>names</strong> – Cell array of same length as values with short names
for printing/debugging.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.addFluxesFromSourcesAndBC">
<span class="sig-name descname"><span class="pre">addFluxesFromSourcesAndBC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">eqs</span></em>, <em class="sig-param"><span class="pre">pressure</span></em>, <em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">mob</span></em>, <em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">forces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.addFluxesFromSourcesAndBC" title="Permalink to this definition"></a></dt>
<dd><p>Add in fluxes imposed by sources and face boundary conditions</p>
<p class="rubric">Description:</p>
<p>Utility function for updating residual conservation equations in the AD
framework with additional fluxes due to boundary conditions and
sources. Wells are handled separately in WellModel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Simulation model (subclass of ReservoirModel).</p></li>
<li><p><strong>eqs</strong> – <dl class="simple">
<dt>Residual conservation of mass-equations for each phase, in</dt><dd><p>the order WATER, OIL, GAS (with any inactive phases
omitted) as a cell array.</p>
</dd>
</dl>
<p>(All the following arguments are cell arrays, with length equal to the
number of the active phases, with the values for each cell in each
entry unless otherwise noted)</p>
<blockquote>
<div><p>pressure   - Phase pressures
rho        - Surface densities (one value per phase)
mob        - Phase mobilities
s          - Phase saturations</p>
<dl class="simple">
<dt>forces     - Struct containing .src and .bc fields for sources and</dt><dd><p>boundary conditions respectively.</p>
</dd>
</dl>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>eqs</strong> – Phase conservation equations with added fluxes.</p></li>
<li><p><strong>qBC</strong> – Phase fluxes due to BC at standard conditions.</p></li>
<li><p><strong>BCTocellMap</strong> – Matrix mapping qBC to cells.</p></li>
<li><p><strong>qSRC</strong> – Phase fluxes due to source terms.</p></li>
<li><p><strong>srcCells</strong> – List of cells, mapping qSRC to cells.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>getBoundaryConditionFluxesAD, getSourceFluxesAD, addSource, addBC</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.addPropertyDependence">
<span class="sig-name descname"><span class="pre">addPropertyDependence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">prop</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">grouping</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.addPropertyDependence" title="Permalink to this definition"></a></dt>
<dd><p>Document dependencies and external dependencies</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.assignValue">
<span class="sig-name descname"><span class="pre">assignValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">inx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.assignValue" title="Permalink to this definition"></a></dt>
<dd><p>Assign values to ADI object by way of indices, without changing jacobians</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="p">=</span> <span class="n">assignValue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">inx</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Replace the numerical values of a ADI or double, without changing the
Jacobians. This can lead to inconsistent Jacobians and variables so it
should only be used if you really know what you are doing!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – ADI or double where values are to be replaced.</p></li>
<li><p><strong>v</strong> – Values that will replace some subset of x.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>inx - The indices into x that v will replace. That is, after the call,</dt><dd><p>double(x(ix)) == v</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>x</strong> – Modified version of input with same class.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ADI</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.assignWellValuesFromControl">
<span class="sig-name descname"><span class="pre">assignWellValuesFromControl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">wellSol</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">wi</span></em>, <em class="sig-param"><span class="pre">oi</span></em>, <em class="sig-param"><span class="pre">gi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.assignWellValuesFromControl" title="Permalink to this definition"></a></dt>
<dd><p>Assign wellSol values when values are set as controls</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wellSol</span> <span class="p">=</span> <span class="n">assignWellValuesFromControl</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">wellSol</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">oi</span><span class="p">,</span> <span class="n">gi</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Well rates and pressures can be both controls and solution variables,
depending on the problem. For a subset of possible well controls, this
function explicitly assigns the values to the wellSol.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – ReservoirModel-derived subclass.</p></li>
<li><p><strong>wellSol</strong> – wellSol to be updated.</p></li>
<li><p><strong>W</strong> – Well struct used to create wellSol.</p></li>
<li><p><strong>wi</strong> – Indices for water, oil and gas respectively in the .compi
field of the well.</p></li>
<li><p><strong>oi</strong> – Indices for water, oil and gas respectively in the .compi
field of the well.</p></li>
<li><p><strong>gi</strong> – Indices for water, oil and gas respectively in the .compi
field of the well.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wellSol</strong> – Updated wellSol where fields corresponding to assigned
controls have been modified.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>WellModel</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.bc2ADbc">
<span class="sig-name descname"><span class="pre">bc2ADbc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">bc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.bc2ADbc" title="Permalink to this definition"></a></dt>
<dd><p>INTERNAL DEPRECATED FUNCTION: Intentionally undocumented.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.calculatePhaseRate">
<span class="sig-name descname"><span class="pre">calculatePhaseRate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Tdp</span></em>, <em class="sig-param"><span class="pre">mobw</span></em>, <em class="sig-param"><span class="pre">map</span></em>, <em class="sig-param"><span class="pre">allowCrossFlow</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.calculatePhaseRate" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.checkWellConvergence">
<span class="sig-name descname"><span class="pre">checkWellConvergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">problem</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.checkWellConvergence" title="Permalink to this definition"></a></dt>
<dd><p>Compute convergence for wells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">converged</span><span class="p">,</span> <span class="n">values</span><span class="p">]</span> <span class="p">=</span> <span class="n">CNV_MBConvergence</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">problem</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<dl class="simple">
<dt>Compute convergence for well equations. Uses the properties</dt><dd><p>model.toleranceWellRate
moedl.toleranceWellBHP</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Subclass of PhysicalModel that contain equations that
are of type well and perforations.</p></li>
<li><p><strong>problem</strong> – LinearizedProblem class instance we want to test for
convergence.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>convergence</strong> – Boolean indicating if the state used to produce the
LinearizedProblem has converged.</p></li>
<li><p><strong>values</strong> – Residual inf of wells.</p></li>
<li><p><strong>evaluated</strong> – Logical array into problem.equations indicating which
residual equations we have actually checked
convergence for.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.combineEquations">
<span class="sig-name descname"><span class="pre">combineEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.combineEquations" title="Permalink to this definition"></a></dt>
<dd><p>Combine equations. For doubles, this is equivialent to a vertical
concatenation. Please note that the full implementation used is found as
a part of the ADI class. This is the fallback for doubles.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.combineSchedules">
<span class="sig-name descname"><span class="pre">combineSchedules</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.combineSchedules" title="Permalink to this definition"></a></dt>
<dd><p>Combine multiple schedules to form a schedule with multiple controls</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.compressSchedule">
<span class="sig-name descname"><span class="pre">compressSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">schedule</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.compressSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Compress schedule to take the longest possible timesteps while honoring controls</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">schedule</span> <span class="p">=</span> <span class="n">compressSchedule</span><span class="p">(</span><span class="n">schedule</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Take a already defined schedule and combine all successive timesteps
with the same controls. This is useful to make a schedule suitable for
dynamic timestepping, as the control steps correspond only to the hard
limits set by changing well/bc controls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scheduleDeck</strong> – A deck struct, typically from convertDeckScheduleToMRST
or manually created.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>scheduleCompressed</strong> – Schedule ready for simulation in ‘simulateScheduleAD’.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.computeCpGeometry">
<span class="sig-name descname"><span class="pre">computeCpGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.computeCpGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.computeSourcesAndBoundaryConditionsAD">
<span class="sig-name descname"><span class="pre">computeSourcesAndBoundaryConditionsAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">pressure</span></em>, <em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">mob</span></em>, <em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">dissolved</span></em>, <em class="sig-param"><span class="pre">forces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.computeSourcesAndBoundaryConditionsAD" title="Permalink to this definition"></a></dt>
<dd><p>Compute phase-pseudocomponent source terms (compatible with AD codes)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="n">bc</span><span class="p">]</span> <span class="p">=</span> <span class="n">computeSourcesAndBoundaryConditionsAD</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">mob</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">dissolved</span><span class="p">,</span> <span class="n">forces</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Subclass of ReservoirModel for which the source terms are
to be computed.</p></li>
<li><p><strong>pressure</strong> – Reservoir pressures (cell array, one pressure per phase)</p></li>
<li><p><strong>s</strong> – Phase saturations (cell array, one saturation per phase)</p></li>
<li><p><strong>mob</strong> – Phase mobilities (cell array, one mobilit per phase)</p></li>
<li><p><strong>rho</strong> – Phase densities (including contributions from dissolved
phases. For a black-oil style model, this is
rhoO = bO.*(rs*rhoGS + rhoOS), and not the pseudocomponent
density in the phase bO.*rhoOS!</p></li>
<li><p><strong>dissolved</strong> – Dissolution matrix for the properties. See
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDissolutionMatrix</span></code> in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ThreePhaseBlackOilModel</span></code>.</p></li>
<li><p><strong>forces</strong> – Struct containing standard MRST driving forces.
Specifically, this routine uses the src and bc fields. All
other fields are ignored. For well source terms, see the
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">FacilityModel</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>src,bc</strong> – Structs for sources and boundary conditions respectively.
Each struct uses the same format with the following fields:</p>
<blockquote>
<div><p>‘phaseMass’    - Cell array of mass source terms per
phase pseudocomponent, accounting for dissolved fractions.
‘phaseVolume’  - Cell array of volumetric source terms
per phase at reservoir conditions.
‘components’   - Empty cell array for inserting component
source terms. Components are not the responsibility of
this function, but we add the field to ensure that the
structure is normalized.
‘mapping’      - Either empty or a matrix used to map the
source terms into aggregate per-cell values. This matrix
is required when multiple source terms are defined in the
same block (e.g. two faces for a cell) since Matlab
overwrites repeat indices instead of summing them.
‘sourceCells’  - List of cells the source terms should be
added to.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The practical implementation of boundary conditions is normally done
through the gateway ReservoirModel&gt;addBoundaryConditionsAndSources
routine, which uses this routine directly.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="ad-blackoil.html#ad_blackoil.utils.equationsOilWater" title="ad_blackoil.utils.equationsOilWater"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">equationsOilWater</span></code></a>, <a class="reference internal" href="ad-blackoil.html#ad_blackoil.utils.equationsBlackOil" title="ad_blackoil.utils.equationsBlackOil"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">equationsBlackOil</span></code></a>,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel&gt;addBoundaryConditionsAndSources</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.convert2MSWell">
<span class="sig-name descname"><span class="pre">convert2MSWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.convert2MSWell" title="Permalink to this definition"></a></dt>
<dd><p>Utility for Converting Standard Well Structure to Multi-Segment Type</p>
<p>Derives and includes Well Nodes and Well Segments in the well structure.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="p">=</span> <span class="n">convert2MSWell</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.convertDeckScheduleToMRST">
<span class="sig-name descname"><span class="pre">convertDeckScheduleToMRST</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">scheduleDeck</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.convertDeckScheduleToMRST" title="Permalink to this definition"></a></dt>
<dd><p>Convert deck-type schedule to MRST style schedule</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">schedule</span> <span class="p">=</span> <span class="n">convertDeckScheduleToMRST</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">deck</span><span class="p">.</span><span class="n">SCHEDULE</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Take a schedule in deck-style (from for example the output of
readEclipseDeck), parse all wells and create a new schedule suitable
for ‘simulateScheduleAD’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Valid grid (likely from initEclipseGrid). Must be the same
grid as the wells in the schedule are defined for.</p></li>
<li><p><strong>rock</strong> – Valid rock used to compute the well indices. Typically from
initEclipseRock.</p></li>
<li><p><strong>scheduleDeck</strong> – Either a deck struct from readEclipseDeck or the
schedule (typically deck.SCHEDULE).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘StepLimit’</strong> – Only parse the first n control steps.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>scheduleMRST</strong> – Schedule ready for simulation in ‘simulateScheduleAD’.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.convertIncompWellSols">
<span class="sig-name descname"><span class="pre">convertIncompWellSols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">states</span></em>, <em class="sig-param"><span class="pre">incompFluid</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.convertIncompWellSols" title="Permalink to this definition"></a></dt>
<dd><p>Convert wellSols from incomp module to format used in ad-core/ad-blackoil</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wellSols</span> <span class="p">=</span> <span class="n">convertIncompWellSols</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">fluid</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>The solvers in the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">incomp</span></code> module uses a different wellSol format than
the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code> style wellSols. This function converts a set of states
into wellSols suitable for routines that were designed to work with the
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code> style wellSols. Specifically, this enables the use of
getWellOutput and plotWellSols with solutions from the incompressible
solvers not based on AD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> – Wells used for simulation</p></li>
<li><p><strong>states</strong> – Nstep long struct array of all simulation states.</p></li>
<li><p><strong>incompFluid</strong> – Fluid model used to compute the simulation states.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wellSols</strong> – Nstep long cell array of the same format as output by
e.g. <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.plotting.plotWellSols" title="ad_core.plotting.plotWellSols"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotWellSols</span></code></a>, <a class="reference internal" href="#ad_core.utils.getWellOutput" title="ad_core.utils.getWellOutput"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getWellOutput</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.convertReportToSchedule">
<span class="sig-name descname"><span class="pre">convertReportToSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">report</span></em>, <em class="sig-param"><span class="pre">schedule</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.convertReportToSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Create a new schedule based on actual ministeps from a simulation report</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">schedule</span> <span class="p">=</span> <span class="n">convertReportToSchedule</span><span class="p">(</span><span class="n">report</span><span class="p">,</span> <span class="n">schedule</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Running a simulation schedule with a given set of control steps may
lead to several extra timesteps due to time step cutting/adjustments
done by the nonlinear solver. This utility converts the report output
from ‘simulateScheduleAD’ along with the schedule used into a new
schedule that accounts for ministeps actually taken.</p>
<p>Note that ‘simulateScheduleAD’ MUST be called with the option
‘OutputMinisteps’ set to true for this to do anything, otherwise it
will just output the report steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>report</strong> – Report from ‘simulateScheduleAD’ with ‘OutputMinisteps’ set
to true.</p></li>
<li><p><strong>schedule</strong> – The schedule used to produce the report.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>schedule</strong> – New schedule modified so that the ministeps are accounted
for.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>simulateScheduleAD</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.convertReservoirFluxesToSurface">
<span class="sig-name descname"><span class="pre">convertReservoirFluxesToSurface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">states</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.convertReservoirFluxesToSurface" title="Permalink to this definition"></a></dt>
<dd><p>Compute surface fluxes from reservoir fluxes</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">states</span> <span class="p">=</span> <span class="n">convertReservoirFluxesToSurface</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function, given states with .bfactors and .flux, will compute the
surface/standard condition fluxes and place them under the field
surfaceFlux. To ensure bfactors and fluxes are added to states during a
simulation, enable the flag “model.extraStateOutput” before simulating.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – ReservoirModel subclass used to produce the states.</p></li>
<li><p><strong>states</strong> – States with valid fields .flux and .bfactors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>states</strong> – States with additional field surfaceFlux.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.criticalPointChop">
<span class="sig-name descname"><span class="pre">criticalPointChop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x0</span></em>, <em class="sig-param"><span class="pre">x_final</span></em>, <em class="sig-param"><span class="pre">xc</span></em>, <em class="sig-param"><span class="pre">e</span></em>, <em class="sig-param"><span class="pre">type</span></em>, <em class="sig-param"><span class="pre">dir</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.criticalPointChop" title="Permalink to this definition"></a></dt>
<dd><p>Perform one or two-sided stability chop for an updated value</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="p">=</span> <span class="n">criticalPointChop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="nb">e</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> – Quantity before update.</p></li>
<li><p><strong>x</strong> – Quantity after update</p></li>
<li><p><strong>xc</strong> – Critical point</p></li>
<li><p><strong>e</strong> – Epsilon used for stability</p></li>
<li><p><strong>type</strong> – If provided, indicates the type of chop: Above will chop so
that the passed value is on the other side of the critical
point, below the opposite and both will chop in both
directions. Default: Both</p></li>
<li><p><strong>dir</strong> – Direction that will be chopped. Either any, increasing or
decreasing. Default: Any, chop both increasing and decreasing
quantities.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x_final</strong> – Chopped value.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.crossFlowMixture">
<span class="sig-name descname"><span class="pre">crossFlowMixture</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">flux</span></em>, <em class="sig-param"><span class="pre">compi</span></em>, <em class="sig-param"><span class="pre">map</span></em>, <em class="sig-param"><span class="pre">conserveMass</span></em>, <em class="sig-param"><span class="pre">is_zero</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.crossFlowMixture" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.crossFlowMixtureDensity">
<span class="sig-name descname"><span class="pre">crossFlowMixtureDensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">massFlux</span></em>, <em class="sig-param"><span class="pre">volumeTotalFlux</span></em>, <em class="sig-param"><span class="pre">massFluxFromSurface</span></em>, <em class="sig-param"><span class="pre">map</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.crossFlowMixtureDensity" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.double2ADI">
<span class="sig-name descname"><span class="pre">double2ADI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">sample</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.double2ADI" title="Permalink to this definition"></a></dt>
<dd><p>Convert a double to ADI variable, using a sample ADI variable for dimensions</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="p">=</span> <span class="n">double2ADI</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">adivar</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> – Double to be converted to ADI.</p></li>
<li><p><strong>sample</strong> – Sample variable of the type ADI to be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>u</strong> – Variable with same type as sample and same value as u
initially had. If u is a ADI class instance, u will have zero
jacobians with the same number of primary variables as the
jacobians of sample.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ADI, initVariablesADI</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.estimateCompositionCFL">
<span class="sig-name descname"><span class="pre">estimateCompositionCFL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.estimateCompositionCFL" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.estimateSaturationCFL">
<span class="sig-name descname"><span class="pre">estimateSaturationCFL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.estimateSaturationCFL" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.expandIfUniform">
<span class="sig-name descname"><span class="pre">expandIfUniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.expandIfUniform" title="Permalink to this definition"></a></dt>
<dd><p>Utility which reverses “value” compaction. If given a matrix (logical
or numerical) as input, it will expand it to a cell array of vectors
such that value(expandIfUniform(x)) is equal to x.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.expandMatrixToCell">
<span class="sig-name descname"><span class="pre">expandMatrixToCell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">matrix</span></em>, <em class="sig-param"><span class="pre">subset</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.expandMatrixToCell" title="Permalink to this definition"></a></dt>
<dd><p>Expand a matrix into cell arrays. Typical usage: Converting state
representation of composition (as matrix) into AD-values (as cell array
of columns vectors).</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.faceUpstr">
<span class="sig-name descname"><span class="pre">faceUpstr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">flag</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">N</span></em>, <em class="sig-param"><span class="pre">sz</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.faceUpstr" title="Permalink to this definition"></a></dt>
<dd><p>Perform single-point upwinding of cell values to face</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">xu</span><span class="p">,</span> <span class="n">xc</span><span class="p">]</span> <span class="p">=</span> <span class="n">faceUpstr</span><span class="p">(</span><span class="nb">flag</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Perform single-point upwind. A robust discretization for
transported/hyperbolic variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flag</strong> – Boolean for each face indicating if the face should take the
value from the first cell (if true), or the second cell (if
false).</p></li>
<li><p><strong>x</strong> – Vector of values to be upwinded. One value per cell in the
domain. See <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sz</span></code> input.</p></li>
<li><p><strong>N</strong> – Neighborship. A number of faces by 2 array. Each row corresponds
to the cells connected to the face with that number.</p></li>
<li><p><strong>sz</strong> – Vector of length 2. First entry corresponds to the number
of faces and the second is the total number of cells.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.fastInterpTable">
<span class="sig-name descname"><span class="pre">fastInterpTable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">X</span></em>, <em class="sig-param"><span class="pre">Y</span></em>, <em class="sig-param"><span class="pre">xi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.fastInterpTable" title="Permalink to this definition"></a></dt>
<dd><p>Fast interpolation of table, using griddedInterpolant</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">yi</span> <span class="p">=</span> <span class="n">fastInterpTable</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>A simple wrapper for griddedInterpolant for fast interpolation of
simple data in the AD-framework. Always defaults to linear
interpolation with linear extrapolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Sample X-coordinates</p></li>
<li><p><strong>y</strong> – Sample function values</p></li>
<li><p><strong>xi</strong> – The X-coordinates at which the linear interpolant is to be
evaluated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>yi</strong> – Linear function interpolating (x, y) evaluated at xi.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.filterSchedule">
<span class="sig-name descname"><span class="pre">filterSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.filterSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Filter unused controls from a schedule</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getBoundaryConditionFluxesAD">
<span class="sig-name descname"><span class="pre">getBoundaryConditionFluxesAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">pressure</span></em>, <em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">mob</span></em>, <em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">bc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getBoundaryConditionFluxesAD" title="Permalink to this definition"></a></dt>
<dd><p>Get boundary condition fluxes for a given set of values</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">qSurf</span><span class="p">,</span> <span class="n">BCTocellMap</span><span class="p">,</span> <span class="n">BCcells</span><span class="p">]</span> <span class="p">=</span> <span class="n">getBoundaryConditionFluxesAD</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">mob</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Given a set of boundary conditions, this function computes the fluxes
induced for a given set of reservoir parameters (density, mobility,
saturations etc).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Subclass of ReservoirModel implementing the current
simulation model.</p></li>
<li><p><strong>pressure</strong> – Cell values of pressure. Should be a nph long cell array,
containing the phase pressures.</p></li>
<li><p><strong>rho</strong> – Surface densities of each phase, as a nph long cell array.</p></li>
<li><p><strong>s</strong> – Phase saturations per cell, as a nph long array.</p></li>
<li><p><strong>b</strong> – Inverse formation volume factors.</p></li>
<li><p><strong>bc</strong> – Boundary condition struct, with valid .sat field with
length nph. Typically made using addBC, pside or fluxside.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>qSurf</strong> – Cell array of phase fluxes at surface conditions.</p></li>
<li><p><strong>BCTocellMap</strong> – Matrix used to add in bc fluxes to cells. Implemented as
a matrix to efficiently account for cells with multiple
faces with boundary conditions.</p></li>
<li><p><strong>BCcells</strong> – The cells affected by boundary conditions.</p></li>
<li><p><strong>qRes</strong> – Cell array of phase fluxes at reservoir conditions.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>addBC, pside, fluxside</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getCellMajorReordering">
<span class="sig-name descname"><span class="pre">getCellMajorReordering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ncell</span></em>, <em class="sig-param"><span class="pre">block_size</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getCellMajorReordering" title="Permalink to this definition"></a></dt>
<dd><p>Get equation ordering transforming variable major to cell major ordering</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">ordering</span> <span class="p">=</span> <span class="n">getCellMajorReordering</span><span class="p">(</span><span class="n">ncell</span><span class="p">,</span> <span class="n">block_size</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get a permutation vector which transforms a system on the standard
variable major (e.g., a two-phase system p_1, …, p_n, s_1, …, s_n)
into a cell major (e.g. p_1, s_1, …, p_n, s_n) where p and s are two
primary variables and the subscript refers to a specific cell.</p>
<p>If Ax=b is some system to be re-ordered of size ncell*block_size, then
ordering = getCellMajorReordering(ncell, block_size);
A = A(ordering, ordering);
b = b(ordering);
will re-order the system. Solving the system x = solve(A, b) where
solve is some linaer solver will then give a permuted solution to the
system. The final solution is then x(ordering) = x.</p>
<p>The primary utility of this function is to a) Allow the user to call
external linear solvers which require this type of ordering and b)
change the system ordering for e.g. ILU(0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ncell</strong> – Number of cells in grid to be used.</p></li>
<li><p><strong>block_size</strong> – Size of each block (e.g. number of components present)</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ndof</strong> – Total number of degrees of freedom. Any additional
degrees of freedom beyond the ncell*block_size
first variables will have a identity remapping,
retaining the position in the final system.</p></li>
<li><p><strong>equation_ordering</strong> – An optional ordering of the equations. Should be a
block_size length vector.</p></li>
<li><p><strong>cell_ordering</strong> – An optional ordering of the cells themselves.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>ordering</strong> – Ordering vector so that A = A(ordering, ordering)
is the permuted system</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">LinearSolverAD</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">AMGCL_CPRSolverAD</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getConvergenceValuesCNV">
<span class="sig-name descname"><span class="pre">getConvergenceValuesCNV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">problem</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getConvergenceValuesCNV" title="Permalink to this definition"></a></dt>
<dd><p>Compute convergence based on total mass balance and maximum residual mass balance.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">converged</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">evaluated</span><span class="p">]</span> <span class="p">=</span> <span class="n">CNV_MBConvergence</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">problem</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Compute CNV/MB type convergence similar to what is used for black
oil convergence in commercial simulators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Subclass of PhysicalModel. Strongly suggested to be
some black oil variant, as this convergence function
does <em>not</em> account for general residual convergence.</p></li>
<li><p><strong>problem</strong> – LinearizedProblem class instance we want to test for
convergence.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>convergence</strong> – Boolean indicating if the state used to produce the
LinearizedProblem has converged.</p></li>
<li><p><strong>values</strong> – 1 by 6 array containing mass balance in the first
three terms followed by cnv in the last three. The
phase ordering is assumed to be oil, water, gas.
Phases present will return a zero in their place.</p></li>
<li><p><strong>evaluated</strong> – Logical array into problem.equations indicating which
residual equations we have actually checked
convergence for.</p></li>
<li><p><strong>names</strong> – Cell array of same length as values with short names
for printing/debugging.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getConvergenceValuesWells">
<span class="sig-name descname"><span class="pre">getConvergenceValuesWells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">problem</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getConvergenceValuesWells" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getEquilPC">
<span class="sig-name descname"><span class="pre">getEquilPC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">satnum</span></em>, <em class="sig-param"><span class="pre">cells</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getEquilPC" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getFractionalFlowMagnitude">
<span class="sig-name descname"><span class="pre">getFractionalFlowMagnitude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getFractionalFlowMagnitude" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getGridSYMRCMOrdering">
<span class="sig-name descname"><span class="pre">getGridSYMRCMOrdering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getGridSYMRCMOrdering" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getMultiDimInterpolator">
<span class="sig-name descname"><span class="pre">getMultiDimInterpolator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">Fx</span></em>, <em class="sig-param"><span class="pre">extrap</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getMultiDimInterpolator" title="Permalink to this definition"></a></dt>
<dd><p>Get a multidimensional interpolator (with support for ADI varibles)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">fn</span> <span class="p">=</span> <span class="n">getMultiDimInterpolator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Cell array containing the vectors for the points of the
function. Must have equal length to the number of dimensions
in Y.</p></li>
<li><p><strong>Y</strong> – A matrix of dimension equal to x, representing a structured
dataset for multdimensional interpolation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>fn</strong> – A function for interpolation with variable arguments equal to
the length of x.</p></li>
<li><p><strong>F</strong> – griddedInterpolant class instace</p></li>
<li><p><strong>epsilons</strong> – Epsilon values for each input argument representing one half
of the minimum distance between elements. Useful for
computing numerical derivatives of the interpolant since
Matlab does not expose the slopes.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.utils.interpTable" title="core.utils.interpTable"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">interpTable</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getMultipliers">
<span class="sig-name descname"><span class="pre">getMultipliers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">p0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getMultipliers" title="Permalink to this definition"></a></dt>
<dd><p>Get dynamic multiplier values for reservoir quantities</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">pvMult</span><span class="p">,</span> <span class="n">transMult</span><span class="p">,</span> <span class="n">mobMult</span><span class="p">]</span> <span class="p">=</span> <span class="n">getMultipliers</span><span class="p">(</span><span class="n">fluid</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fluid</strong> – Fluid model, typically from initDeckADIFluid or some other
constructor.</p></li>
<li><p><strong>p</strong> – Pressure per cell.</p></li>
<li><p><strong>p0</strong> – Pressure per cell (previous timestep).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pvMult</strong> – Pore volume multiplier per cell. Multiplicative modifier for</dt><dd><p>the pore volume based on a simplified model for how the
pores grow when fluid pressure is increasing.</p>
</dd>
<dt>transMult - Transmissibility multiplier, modelling pressure dependent</dt><dd><p>permeability. One value per interface.</p>
</dd>
</dl>
<p>mobMult   - Mobility multiplier per cell.</p>
<p>pvMult0, transMult0, mobMult0 - Multipliers for previous timestep.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getPerforationToWellMapping">
<span class="sig-name descname"><span class="pre">getPerforationToWellMapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getPerforationToWellMapping" title="Permalink to this definition"></a></dt>
<dd><p>Get map from global perforation number to global well index.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">perf2well</span> <span class="p">=</span> <span class="n">getPerforationToWellMapping</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>w</strong> – Well structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>perf2well</strong> – perf2well(ix) will give the well number of global
perforation number ix.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>WellModel</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getReportMinisteps">
<span class="sig-name descname"><span class="pre">getReportMinisteps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">report</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getReportMinisteps" title="Permalink to this definition"></a></dt>
<dd><p>Get the timesteps used for the ministeps of a report</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">timesteps</span> <span class="p">=</span> <span class="n">getReportMinisteps</span><span class="p">(</span><span class="n">report</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get the actual ministeps used by simulateScheduleAD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>report</strong> – Report from simulateScheduleAD.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>timesteps</strong> – The timesteps used to solve the problem. These differ from
the control steps (schedule.step.val) in that they are the
actual timesteps taken by the solver (due to timestep
cutting, adaptive timestepping and so on)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SimulateScheduleAD</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getReportOutput">
<span class="sig-name descname"><span class="pre">getReportOutput</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reports</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getReportOutput" title="Permalink to this definition"></a></dt>
<dd><p>Get output from report after call to simulateScheduleAD</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getReservoirModel">
<span class="sig-name descname"><span class="pre">getReservoirModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getReservoirModel" title="Permalink to this definition"></a></dt>
<dd><p>Get the underlying reservoir model of a WrapperModel</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">rmodel</span> <span class="p">=</span> <span class="n">getReservoirModel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> – Instance of WrapperModel class.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>rmodel</strong> – ReservoirModel contained in wrapper model instance. If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">model</span></code>
is an instance of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SequentialPressureTransportModel</span></code> the
function returns the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code> of the contained
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">PressureModel</span></code>.</p>
<p>Otherwise, this is the top-most <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code> - the one
that does not have a <code class="xref mat mat-func docutils literal notranslate"><span class="pre">parentModel</span></code>.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">tmodel</span> <span class="p">=</span> <span class="n">TransportModel</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>     <span class="c">% Make transport model</span>
<span class="n">rmodel</span> <span class="p">=</span> <span class="n">getReservoirModel</span><span class="p">(</span><span class="n">tmodel</span><span class="p">);</span> <span class="c">% rmodel = model</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">WrapperModel</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code>, <a class="reference internal" href="#ad_core.utils.setReservoirModel" title="ad_core.utils.setReservoirModel"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">setReservoirModel</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getSampleAD">
<span class="sig-name descname"><span class="pre">getSampleAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getSampleAD" title="Permalink to this definition"></a></dt>
<dd><p>Utility for getting a AD value if it exists from a list of possible
AD-values</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getSimulationTime">
<span class="sig-name descname"><span class="pre">getSimulationTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">states</span></em>, <em class="sig-param"><span class="pre">report</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getSimulationTime" title="Permalink to this definition"></a></dt>
<dd><p>Get the global time for a set of states produced by simulateScheduleAD</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="nb">times</span> <span class="p">=</span> <span class="n">getSimulationTime</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">report</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get the time for each state output by simulateScheduleAD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>states</strong> – Cell array of states as given by simulateScheduleAD. Can
be either per control step or per ministep.</p></li>
<li><p><strong>report</strong> – Report given by simulateScheduleAD.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>times</strong> – Array with same dimensions as states, giving the values of
the time in the simulation model for each step. The
initial state passed to simulateScheduleAD is assumed to
be at time zero.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>simulateScheduleAD</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getSourceFluxesAD">
<span class="sig-name descname"><span class="pre">getSourceFluxesAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">mob</span></em>, <em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">src</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getSourceFluxesAD" title="Permalink to this definition"></a></dt>
<dd><p>Short description</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">qSurf</span><span class="p">,</span> <span class="n">BCTocellMap</span><span class="p">,</span> <span class="n">cells</span><span class="p">]</span> <span class="p">=</span> <span class="n">getSourceFluxesAD</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mob</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
</pre></div>
</div>
<p>DESCRIPTION:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Subclass of ReservoirModel indicating which phases are
active.</p></li>
<li><p><strong>mob</strong> – A cell array of cell mobility values for all active
phases.</p></li>
<li><p><strong>s</strong> – A cell array of saturations per cell for all active
phases.</p></li>
<li><p><strong>src</strong> – Source struct as defined by addSource</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>qSurf</strong> – Source terms at standard conditions. Cell array of
same dimensions as the number of active phases.</p></li>
<li><p><strong>cells</strong> – A list of cells for which the entries of qRes should
be added.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.getWellOutput">
<span class="sig-name descname"><span class="pre">getWellOutput</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">wellsols</span></em>, <em class="sig-param"><span class="pre">fldnames</span></em>, <em class="sig-param"><span class="pre">wells</span></em>, <em class="sig-param"><span class="pre">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.getWellOutput" title="Permalink to this definition"></a></dt>
<dd><p>Extract values from wellsols.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">wd</span><span class="p">,</span> <span class="n">wn</span><span class="p">,</span> <span class="n">flds</span><span class="p">]=</span> <span class="n">getWellOutput</span><span class="p">(</span><span class="n">wellSols</span><span class="p">,</span> <span class="s">&#39;bhp&#39;</span><span class="p">)</span>
<span class="p">[</span><span class="n">wd</span><span class="p">,</span> <span class="n">wn</span><span class="p">,</span> <span class="n">flds</span><span class="p">]=</span> <span class="n">getWellOutput</span><span class="p">(</span><span class="n">wellSols</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;bhp&#39;</span><span class="p">,</span> <span class="s">&#39;qWs&#39;</span><span class="p">},</span> <span class="s">&#39;W1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Given a cell array of well solution structures representing multiple
timesteps, this routine extracts requested values in matrix form ready
for plotting / inspection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wellSols</strong> – Cell array of NSTEP length, each containing a struct with
NWELL entries. All wells must exist at all timesteps.</p></li>
<li><p><strong>fldnames</strong> – (OPTIONAL) Either a single string, or a cell array of
desired fields for output. Bottom hole pressures, rates, …
Defaults to all fields.</p></li>
<li><p><strong>wells</strong> – (OPTIONAL) Either a single string, or a cell array of well
names for which output is desired. Defaults to all wells.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>welldata</strong> – A NSTEP by NWELL by NFIELDS matrix. For instance, for</p></li>
<li><p><strong>calling</strong></p></li>
<li><p><strong>D = getWellOutput</strong> (<em>wellsols, {‘bhp’, ‘qWs’}, {‘Injector’, ‘Producer’}</em>)</p></li>
<li><p><strong>will give bottom hole pressures for the producer in D(</strong> – , 1, 2);</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>plotWellSols</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.initWellSolAD">
<span class="sig-name descname"><span class="pre">initWellSolAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">wellSolInit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.initWellSolAD" title="Permalink to this definition"></a></dt>
<dd><p>Set up well solution struct for a automatic differentiation model</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wellSol</span> <span class="p">=</span> <span class="n">initWellSolAD</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">state0</span><span class="p">);</span>
<span class="n">wellSol</span> <span class="p">=</span> <span class="n">initWellSolAD</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">state0</span><span class="p">,</span> <span class="n">ws</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Create or extract the wellSol, and ensure that it contains the correct
fields for advanced solvers with well limits and variable perforation
counts. This function will first look for a explicitly passed wellSol
to modify, then it will consider any wellSol residing in state0. If
neither is found, it will attempt to construct one based on W.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> – Control well for which we are going to create a well
solution structure.</p></li>
<li><p><strong>model</strong> – Subclass of ReservoirModel. Used to determine how many
and which phases are present.</p></li>
<li><p><strong>state0</strong> – State, possibly with a wellSol given already (see
initResSol/initState).</p></li>
<li><p><strong>wellSolInit</strong> – Initial wellSol.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wellSol</strong> – Well solution struct with additional fields ready for
simulation.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.interpolateIDW">
<span class="sig-name descname"><span class="pre">interpolateIDW</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">xq</span></em>, <em class="sig-param"><span class="pre">order</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.interpolateIDW" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.makeScheduleConsistent">
<span class="sig-name descname"><span class="pre">makeScheduleConsistent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">schedule</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.makeScheduleConsistent" title="Permalink to this definition"></a></dt>
<dd><p>Ensure that a schedule is consistent in terms of well counts/perforations</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">schedule</span> <span class="p">=</span> <span class="n">makeScheduleConsistent</span><span class="p">(</span><span class="n">schedule</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>For a given schedule with varying amount of wells and perforated cells
per well, this schedule makes the schedule internally consistent so
that all wells are defined at each control step. Some wells will be
disabled at different points, but they are always present and thus the
simulator output will be normalized and easier to work with.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>schedule</strong> – Schedule with possibly inconsistent numbers of wells and
perforations.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>schedule</strong> – Equivialent schedule that is consistent in the well and cell
numberings.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>convertDeckScheduleToMRST</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.mergeOrderedArrays">
<span class="sig-name descname"><span class="pre">mergeOrderedArrays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">old</span></em>, <em class="sig-param"><span class="pre">new</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.mergeOrderedArrays" title="Permalink to this definition"></a></dt>
<dd><p>Merge two sets of cells that are similar in that they may contain
elements from the same superset in the same order, but each set may
be missing one or more elements that the other has.</p>
<p>This is done by having two simple pointers that are incremented as we
go along trying to merge the two sets.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.numelData">
<span class="sig-name descname"><span class="pre">numelData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.numelData" title="Permalink to this definition"></a></dt>
<dd><p>Alias for numel. Useful for writing code which handles either
ResultHandler or cell arrays.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.numelValue">
<span class="sig-name descname"><span class="pre">numelValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.numelValue" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.padRatesAndCompi">
<span class="sig-name descname"><span class="pre">padRatesAndCompi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">q_s</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.padRatesAndCompi" title="Permalink to this definition"></a></dt>
<dd><p>Pad one/two/threephase values with zeros corresponding to missing phases.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">W</span><span class="p">]</span> <span class="p">=</span> <span class="n">padRatesAndCompi</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function adds padding zeros to convert rates and wells for a
one/two phase model to make it appear as a three phase model with zero
rates for the missing phases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q_s</strong> – Cell array of fluxes corresponding to the number of
active phases in the model.</p></li>
<li><p><strong>W</strong> – Wells compatible with the current model.</p></li>
<li><p><strong>model</strong> – Model with one or more active phases, consistent with
q_s and W.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>q_s</strong> – 1 by 3 cell array with zero values added for missing
phases.</p></li>
<li><p><strong>W</strong> – Three phase wells (.compi contains three fields, again
with zeros where phases are missing in the original
model).</p></li>
<li><p><strong>isActive</strong> – Indicators for which phases are present.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>PhysicalModel, WellModel</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.phaseDensitiesTobfactor">
<span class="sig-name descname"><span class="pre">phaseDensitiesTobfactor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">rho</span></em>, <em class="sig-param"><span class="pre">rhoS</span></em>, <em class="sig-param"><span class="pre">dissolved</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.phaseDensitiesTobfactor" title="Permalink to this definition"></a></dt>
<dd><p>Convert densities to b-facctors, accounting for dissolution</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.pressureBCContrib">
<span class="sig-name descname"><span class="pre">pressureBCContrib</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">pX</span></em>, <em class="sig-param"><span class="pre">rhoX</span></em>, <em class="sig-param"><span class="pre">mobX</span></em>, <em class="sig-param"><span class="pre">bX</span></em>, <em class="sig-param"><span class="pre">bc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.pressureBCContrib" title="Permalink to this definition"></a></dt>
<dd><p>LEGACY FUNCTION: Intentionally undocumented.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.pressureBCContribADI">
<span class="sig-name descname"><span class="pre">pressureBCContribADI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">pX</span></em>, <em class="sig-param"><span class="pre">rhoX</span></em>, <em class="sig-param"><span class="pre">mobX</span></em>, <em class="sig-param"><span class="pre">bX</span></em>, <em class="sig-param"><span class="pre">bc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.pressureBCContribADI" title="Permalink to this definition"></a></dt>
<dd><p>LEGACY FUNCTION: Intentionally undocumented.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.printConvergenceReport">
<span class="sig-name descname"><span class="pre">printConvergenceReport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">names</span></em>, <em class="sig-param"><span class="pre">values</span></em>, <em class="sig-param"><span class="pre">converged</span></em>, <em class="sig-param"><span class="pre">iteration</span></em>, <em class="sig-param"><span class="pre">endOfBlock</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.printConvergenceReport" title="Permalink to this definition"></a></dt>
<dd><p>Print a neatly formatted convergence report</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">printConvergenceReport</span><span class="p">({</span><span class="s">&#39;myEquation&#39;</span><span class="p">,</span> <span class="s">&#39;yourEquation&#39;</span><span class="p">},</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">25</span><span class="p">],</span> <span class="p">[</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">],</span> <span class="n">it</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Print convergence report to the Command Window. Two lines are plotted
for the first iteration, and one line for succeeding iterations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>names</strong> – Names of the different convergence measures. Cell array of
length N where N is the number of different measures (for
instance, residual norms for different equations)</p></li>
<li><p><strong>values</strong> – Double array of length N, where each entry corresponds to
the current value of the different named measures.</p></li>
<li><p><strong>converged</strong> – Boolean for each value indicating if convergence has been
achieved for that value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Nothing.</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.readSummaryLocal">
<span class="sig-name descname"><span class="pre">readSummaryLocal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">prefix</span></em>, <em class="sig-param"><span class="pre">keyWords</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.readSummaryLocal" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.recoverVars">
<span class="sig-name descname"><span class="pre">recoverVars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">eq</span></em>, <em class="sig-param"><span class="pre">n</span></em>, <em class="sig-param"><span class="pre">sol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.recoverVars" title="Permalink to this definition"></a></dt>
<dd><p>Recover previously eliminated variables x at position n using solutions sol</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.refineSchedule">
<span class="sig-name descname"><span class="pre">refineSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">init_time_for_new_time_steps</span></em>, <em class="sig-param"><span class="pre">new_time_steps</span></em>, <em class="sig-param"><span class="pre">schedule</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.refineSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Compute a finer schedule, including new time steps but preserving the time steps of the original
schedule</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">new_schedule</span> <span class="p">=</span> <span class="n">refineSchedule</span><span class="p">(</span><span class="n">init_time_for_new_time_steps</span><span class="p">,</span> <span class="n">new_time_steps</span><span class="p">,</span> <span class="n">schedule</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>init_time_for_new_time_steps</strong> – Time where the sequence of new time steps will be added.</p></li>
<li><p><strong>new_time_steps</strong> – Sequence of time steps to be added.</p></li>
<li><p><strong>schedule</strong> – Input schedule which will be refined</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.reorderForILU">
<span class="sig-name descname"><span class="pre">reorderForILU</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">nc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.reorderForILU" title="Permalink to this definition"></a></dt>
<dd><p>Attempt to reorder a set of equations so that the diagonal is non-zero</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="p">=</span> <span class="n">reorderForILU</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">nc</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Reorder a set of equations to ensure non-zero diagonal. This is useful
when building ILU-based solvers. Notably, this utility is useful
whenever well equations are added, that may not have derivatives with
respect to all well controls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> – Linear system to be reordered.</p></li>
<li><p><strong>b</strong> – Right hand side of the system</p></li>
<li><p><strong>nc</strong> – (OPTIONAL) The routine will only look at equations from nc+1 and
onwards to numel(b).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>A</strong> – Reordered linear system</p></li>
<li><p><strong>b</strong> – Reordered right hand side</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.selectLinearSolverAD">
<span class="sig-name descname"><span class="pre">selectLinearSolverAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.selectLinearSolverAD" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.selectModelFromDeck">
<span class="sig-name descname"><span class="pre">selectModelFromDeck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">deck</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.selectModelFromDeck" title="Permalink to this definition"></a></dt>
<dd><p>Select simulation model from a ECLIPSE/FrontSim style input deck</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="p">=</span> <span class="n">selectModelFromDeck</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="n">deck</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Determine the type of PhysicalModel subclass (if any) most suitable for
simulating a given input deck.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Simulation grid, typically from initEclipseGrid</p></li>
<li><p><strong>rock</strong> – Corresponding rock structure, typically from
initEclipseRock.</p></li>
<li><p><strong>fluid</strong> – Fluid model, typically from initDeckADIFluid.</p></li>
<li><p><strong>deck</strong> – Parsed input deck, typically from readEclipseDeck.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>useLegacyModels</strong> – Whether or not to construct the original, monolithic
physical models.  Stop-gap solution until all
examples have been ported to the Generic* framework
and only supported for three-phase black-oil
w/polymer (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ThreePhaseBlackOilPolymerModel</span></code>).</p></li>
<li><p><strong>Any</strong> – All other key/value pair arguments are passed directly on to the
model constructor.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>model</strong> – Subclass of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code> approprioate for passing along
to <a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">GenericBlackOilModel</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ThreePhaseBlackOilModel</span></code>,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">TwoPhaseOilWaterModel</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">OilWaterPolymerModel</span></code>,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ThreePhaseBlackOilPolymerModel</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.setMPFADiscretization">
<span class="sig-name descname"><span class="pre">setMPFADiscretization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.setMPFADiscretization" title="Permalink to this definition"></a></dt>
<dd><p>Set MPFA discretization on a model</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.setReservoirModel">
<span class="sig-name descname"><span class="pre">setReservoirModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">rmodel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.setReservoirModel" title="Permalink to this definition"></a></dt>
<dd><p>Set the underlying reservoir model of a WrapperModel</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="p">=</span> <span class="n">setReservoirModel</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">rmodel</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Instance of WrapperModel class.</p></li>
<li><p><strong>rmodel</strong> – Instance of ReservoirModel class to replace the current
underlying reservoir model of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">model</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>model</strong> – WrapperModel with updated Reservoir model. If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">model</span></code>
is an instance of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SequentialPressureTransportModel</span></code> the
function replaces the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code> of the contained
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">PressureModel</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">TransportModel</span></code></p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">tmodel</span> <span class="p">=</span> <span class="n">TransportModel</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>             <span class="c">% Make transport model</span>
<span class="n">rmodel</span> <span class="p">=</span> <span class="n">getReservoirModel</span><span class="p">(</span><span class="n">tmodel</span><span class="p">);</span>         <span class="c">% rmodel = model</span>
<span class="n">rmodel</span><span class="p">.</span><span class="n">rock</span><span class="p">.</span><span class="n">perm</span> <span class="p">=</span> <span class="n">rmodel</span><span class="p">.</span><span class="n">rock</span><span class="p">.</span><span class="n">perm</span><span class="o">*</span><span class="mf">1e3</span><span class="p">;</span>    <span class="c">% Multiply permeability</span>
<span class="n">rmodel</span> <span class="p">=</span> <span class="n">rmodel</span><span class="p">.</span><span class="n">setupOperators</span><span class="p">();</span>           <span class="c">% Update model operators</span>
<span class="n">tmodel</span> <span class="p">=</span> <span class="n">setReservoirModel</span><span class="p">(</span><span class="n">tmodel</span><span class="p">,</span> <span class="n">rmodel</span><span class="p">);</span> <span class="c">% Update tmodel</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">WrapperModel</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ReservoirModel</span></code>, <a class="reference internal" href="#ad_core.utils.getReservoirModel" title="ad_core.utils.getReservoirModel"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getReservoirModel</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.setTimeDiscretization">
<span class="sig-name descname"><span class="pre">setTimeDiscretization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">type</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.setTimeDiscretization" title="Permalink to this definition"></a></dt>
<dd><p>Set the discretization choice for a model</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.setWENODiscretization">
<span class="sig-name descname"><span class="pre">setWENODiscretization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.setWENODiscretization" title="Permalink to this definition"></a></dt>
<dd><p>Set WENO discretization on a model</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.setWellSign">
<span class="sig-name descname"><span class="pre">setWellSign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.setWellSign" title="Permalink to this definition"></a></dt>
<dd><p>Ensure that wells have a defined sign. Will attempt to guess based on controls.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="p">=</span> <span class="n">setWellSign</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>The AD based solvers assume a W.sign is defined. This routine attempts
to ensure that wells do have a sign. A positive sign is used to
indicate an injector and a negative sign for a producer. If the wells
have rate controls, they will be given signs based on the signs of the
rates. If they are pressure controlled wells, they will get sign 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>W</strong> – Well struct, from e.g. addWell.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>W</strong> – Well struct where numel(W(i).sign) is guaranteed to be 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.setupOperatorsTPFA">
<span class="sig-name descname"><span class="pre">setupOperatorsTPFA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.setupOperatorsTPFA" title="Permalink to this definition"></a></dt>
<dd><p>Set up helper structure for solvers based on automatic differentiation.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="p">=</span> <span class="n">setupOperatorsTPFA</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>The automatic differentiation solvers rely on discrete operators for
divergence and gradient on the grid as well as a variety of derived
reservoir quantities such as transmissibility and pore volume. The
purpose of this function is to assemble all such quantities using a
standard two-point finite volume approxiation (TPFA).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – MRST grid given as a struct. See grid_structure.m for more
details.</p></li>
<li><p><strong>rock</strong> – Rock structure containing fields .perm and .poro with
approprioate dimensions for the grid. See makeRock for more
details.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘trans’</strong> – transmissibility for internal faces (if neighbors given)
or for all faces (if neighbors are not given)</p></li>
<li><p><strong>‘neighbors’</strong> – neighbors for each internal face</p></li>
<li><p><strong>‘porv’</strong> – pore volumes for all cells</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>op</strong> – Operators struct, with discrete operators and derived quantities:</p>
<p>T_all - Transmissibilities for all interfaces, <em>including</em> (half)
transmissibilities for faces on the boundary. One value per
interface.</p>
<p>T - Transmissibilities for all internal interfaces. Internal
interfaces have a cell on both sides.</p>
<p>pv - Pore volumes. See function <a class="reference internal" href="core.html#core.params.rock.poreVolume" title="core.params.rock.poreVolume"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">poreVolume</span></code></a>. One value per cell.</p>
<p>faceAvg - (Function) For each interface, computes the average value
of a quantity defined in the cells. If a face is connecting two
cells, the faceAvg function will compute the arithmetic average of
the values in both cells.</p>
<p>M - Matrix used to compute face average</p>
<p>internalConn - flag for internal connections (size G.faces.num)</p>
<p>Grad - (Function) Discrete gradient as function handle. Computes the
gradient on each interface via a first order finite difference
approximation using the values of the cells connected to the
face. Note that this discrete gradient does <em>not</em> divide by the
distance between the points.</p>
<p>C - Transfer matrix between cells and faces. Used to derive discrete
gradient and divergence operators.</p>
<p>Div - (Function) Discrete divergence. Integrates / sums up values on
the interfaces for all cells to give the (integrated) divergence per
cell.</p>
<p>AccDiv - (Function) adds accumulation term and discrete divergence term</p>
<p>faceUpstr - (Function) Perform upstream weighting of values. Given a
set of cell wise values and a upstream flag for each interface, this
function will pick the values corresponding to the position in the
neighborship. I.e. if the flag is true for a given interface, it will
select the value in the FIRST cell connected to the interface
x(N(faceNo, 1)).  Otherwise, it will select the SECOND x(N(faceNo,
2)).  Typical usage is for upstream weighting of transported
quantities.</p>
<p>N - Neighborship structure. Will be number of interfaces by 2 in size
where N(ix, :) contains the cells connected to face number ix.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core.html#core.solvers.computeTrans" title="core.solvers.computeTrans"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeTrans</span></code></a>, <a class="reference internal" href="core.html#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.simpleSchedule">
<span class="sig-name descname"><span class="pre">simpleSchedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.simpleSchedule" title="Permalink to this definition"></a></dt>
<dd><p>Make a schedule with varying timesteps and fixed wells/bc/src terms</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">schedule</span> <span class="p">=</span> <span class="n">simpleSchedule</span><span class="p">(</span><span class="n">timesteps</span><span class="p">);</span>
<span class="n">schedule</span> <span class="p">=</span> <span class="n">simpleSchedule</span><span class="p">(</span><span class="n">timesteps</span><span class="p">,</span> <span class="s">&#39;W&#39;</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="s">&#39;src&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="s">&#39;bc&#39;</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dt</strong> – Vector (column/row) of desired timesteps.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>W</strong> – Wells to be used in the schedule. The wells will be active in
all timesteps.</p></li>
<li><p><strong>BC</strong> – Boundary conditions to be used in the schedule. The boundary
conditions will be active in all timesteps.</p></li>
<li><p><strong>src</strong> – Source terms to be used in the schedule. The sourceterms will be
active in all timesteps.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>schedule</strong> – struct suitable for further modification, or for input to
<a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.sizeJac">
<span class="sig-name descname"><span class="pre">sizeJac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">jac</span></em>, <em class="sig-param"><span class="pre">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.sizeJac" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.splitFaceCellValue">
<span class="sig-name descname"><span class="pre">splitFaceCellValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">operators</span></em>, <em class="sig-param"><span class="pre">flag</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">sz</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.splitFaceCellValue" title="Permalink to this definition"></a></dt>
<dd><p>Split multi-valued function into cell and face values</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">fx</span><span class="p">,</span> <span class="n">cx</span><span class="p">]</span> <span class="p">=</span> <span class="n">splitFaceCellValue</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="nb">flag</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Taking a set of values, this function returns cell and face-upwinded
values based on specified flag and dimensions. Normally, this is simply
applying a pre-existing upwind operator to get the upstream weighted
values for transported quantities. For special functions that arise in
some workflows, it can take e.g. a set of (half)face values plus cell
values and divide them up in a reasonable manner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operators</strong> – Operators struct. See <a class="reference internal" href="#ad_core.utils.setupOperatorsTPFA" title="ad_core.utils.setupOperatorsTPFA"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">setupOperatorsTPFA</span></code></a>.</p></li>
<li><p><strong>flag</strong> – Upstream flag to be used to upwind values. See <a class="reference internal" href="#ad_core.utils.faceUpstr" title="ad_core.utils.faceUpstr"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">faceUpstr</span></code></a>.</p></li>
<li><p><strong>x</strong> – Vector of values to be treated. Can be either one value per
cell in the domain, one value per face followed by one
value per cell, or one value per half-face, followed by the
cell values.</p></li>
<li><p><strong>sz</strong> – Vector of length 2. First entry corresponds to the number
of faces and the second is the total number of cells.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.utils.faceUpstr" title="ad_core.utils.faceUpstr"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">faceUpstr</span></code></a>, <a class="reference internal" href="#ad_core.utils.setupOperatorsTPFA" title="ad_core.utils.setupOperatorsTPFA"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">setupOperatorsTPFA</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.splitMatrixForReduction">
<span class="sig-name descname"><span class="pre">splitMatrixForReduction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">n</span></em>, <em class="sig-param"><span class="pre">strategy</span></em>, <em class="sig-param"><span class="pre">doFactor</span></em>, <em class="sig-param"><span class="pre">fullFactor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.splitMatrixForReduction" title="Permalink to this definition"></a></dt>
<dd><p>Split matrix A and right-hand side into blocks
A = [B, C] b = [f]</p>
<blockquote>
<div><p>[D, E]     [h]</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.standaloneSolveAD">
<span class="sig-name descname"><span class="pre">standaloneSolveAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">state0</span></em>, <em class="sig-param"><span class="pre">model</span></em>, <em class="sig-param"><span class="pre">dt</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.standaloneSolveAD" title="Permalink to this definition"></a></dt>
<dd><p>Solve a single time-step with AD solvers for given forces</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">state</span><span class="p">,</span> <span class="n">report</span><span class="p">]</span> <span class="p">=</span> <span class="n">standaloneSolveAD</span><span class="p">(</span><span class="n">state0</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="s">&#39;W&#39;</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="s">&#39;maxIterations&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Stand-alone solver for AD. Useful for simple problems where a full
schedule is not required. Calls simulateScheduleAD internally.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state0</strong> – Initial state.</p></li>
<li><p><strong>model</strong> – PhysicalModel instance for simulation.</p></li>
<li><p><strong>dt</strong> – Timestep length.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘Various’</strong> – Additional inputs are given to the following
functions in order of priority: First, as possible
driving forces, then as inputs to
simulateScheduleAD.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> – Updated state.</p></li>
<li><p><strong>report</strong> – Reports for simulator.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.structPropEvaluated">
<span class="sig-name descname"><span class="pre">structPropEvaluated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.structPropEvaluated" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.terniaryWellPlot">
<span class="sig-name descname"><span class="pre">terniaryWellPlot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">wellSols</span></em>, <em class="sig-param"><span class="pre">T</span></em>, <em class="sig-param"><span class="pre">ix</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.terniaryWellPlot" title="Permalink to this definition"></a></dt>
<dd><p>Plot well curves (water, gas, oil and optionally BHP) for wellSols</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Plot well #3, with timesteps on xaxis</span>
<span class="n">terniaryWellPlot</span><span class="p">(</span><span class="n">wellSols</span><span class="p">,</span> <span class="nb">time</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="c">% Plot all wells</span>
<span class="n">terniaryWellPlot</span><span class="p">(</span><span class="n">wellSols</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function is tailored towards three-phase simulation and is capable
of producing plots that include production rates for each well for each
phase (water, oil gas) and optionally also bottom hole pressures as a
separate axis. One figure is produced per well requested.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wellSols</strong> – Cell array of NSTEP by 1, each containing a uniform struct
array of well solution structures. For example, the first
output from simulateScheduleAD. Can also be a cell array of
such cell arrays, for comparing multiple simulation
scenarios.</p></li>
<li><p><strong>time</strong> – (OPTIONAL) The time for each timestep. If not provided, the
plotter will use step number as the x axis intead. If
wellSols is a cell array of multiple datasets, time should
also be a cell array, provided not all datasets use the
same timesteps.</p></li>
<li><p><strong>ix</strong> – (OPTIONAL) A list of indices to plot, or a single string
corresponding to the name of a specific well. The default is
all wells.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘plotBHP’</strong> – Boolean indicating if BHP is to be plotted. Defaults to
enabled.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>fh</strong> – Figure handles to all figures that were created.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ad_core.simulators.simulateScheduleAD" title="ad_core.simulators.simulateScheduleAD"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simulateScheduleAD</span></code></a>, <a class="reference internal" href="#ad_core.plotting.plotWellSols" title="ad_core.plotting.plotWellSols"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotWellSols</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="ad_core.utils.wellSolToVector">
<span class="sig-name descname"><span class="pre">wellSolToVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">wellsols</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ad_core.utils.wellSolToVector" title="Permalink to this definition"></a></dt>
<dd><p>Extract selected summary vectors from cell array of well solutions</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">WaterRate</span><span class="p">,</span> <span class="n">OilRate</span><span class="p">,</span> <span class="n">GasRate</span><span class="p">,</span> <span class="n">BHP</span><span class="p">]</span> <span class="p">=</span> <span class="n">wellSolToVector</span><span class="p">(</span><span class="n">wellSols</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wellSols</strong> – Cell array of well solution structures as produced by
runScheduleADI or simulateScheduleADI.  Each solution
structure must define the fields ‘qWs’, ‘qOs’, ‘qGs’, and
‘bhp’.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Function wellSolToVector does not support variable number of wells.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>In the following ‘nw’ refers to the number of wells</strong></p></li>
<li><p><strong>(NUMEL</strong> (<em>wellSols{1})</em>)</p></li>
<li><p><strong>steps</strong> (<em>NUMEL(wellSols)</em>)</p></li>
<li><p><strong>WaterRate</strong> – Numeric array of size nt-by-nw of water rate at surface
conditions (unit m^3/s).</p></li>
<li><p><strong>OilRate</strong> – Numeric array of size nt-by-nw of oil rate at surface
conditions (unit m^3/s).</p></li>
<li><p><strong>GasRate</strong> – Numeric array of size nt-by-nw of gas rate at surface
conditions (unit m^3/s).</p></li>
<li><p><strong>BHP</strong> – Numeric array of size nt-by-nw of well bottom-hole pressure
values (unit Pascal).</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>simulateScheduleADI, runScheduleADI.</p>
</div>
</dd></dl>

</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h2>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="core.html" class="btn btn-neutral float-left" title="Core functionality" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ad-props.html" class="btn btn-neutral float-right" title="ad-props: PVT, fluid models and other properties for the AD-solvers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, SINTEF Digital.
      <span class="lastupdated">Last updated on Sep 23, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>