<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Core functionality &mdash; The Matlab Reservoir Simulation Toolbox 2019b documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ad-core: Automatic Differentiation Core" href="ad-core.html" />
    <link rel="prev" title="Welcome to the MRST quick documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> The Matlab Reservoir Simulation Toolbox
            <img src="_static/mrstlogo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2019b
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Core functionality</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#plotting-routines">Plotting routines</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grid-generation-processing-and-manipulation">Grid generation, processing and manipulation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-core.gridprocessing.testgrids">Test grids</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#parameters-states-and-forces">Parameters, states and forces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-core.solvers">Input to solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-core.params.rock">Petrophysical properties</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wells-boundary-conditions-and-source-terms">Wells, boundary conditions and source terms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#various-utilities">Various utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-explorer">Module explorer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dataset-manager">Dataset manager</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#units">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ad-core.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code>: Automatic Differentiation Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-props.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-props</span></code>: PVT, fluid models and other properties for the AD-solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-blackoil.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-blackoil</span></code>: Black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-eor.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-eor</span></code>: Enhanced oil recovery solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-mechanics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-mechanics</span></code>: Coupled flow and mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="adjoint.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">adjoint</span></code>: Two-phase, incompressible adjoint solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="agglom.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">agglom</span></code>: Flow and property-based coarse-grid generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="blackoil-sequential.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">blackoil-sequential</span></code>: Sequential implicit black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="book.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">book</span></code>: Book examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="coarsegrid.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">coarsegrid</span></code>: Generation of coarse grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="compositional.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">compositional</span></code>: Equation-of-state compositional solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="co2lab.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">co2lab</span></code>: Numerical CO<sub>2</sub> laboratory</a></li>
<li class="toctree-l1"><a class="reference internal" href="deckformat.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">deckformat</span></code>: Reading and conversion of input decks</a></li>
<li class="toctree-l1"><a class="reference internal" href="dfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dfm</span></code>: Discrete fracture matrix implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="dg.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dg</span></code>: Discontinous Galerkin discretizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">diagnostics</span></code>: Flow diagnostics functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="dual_porosity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dual-porosity</span></code>: Dual porosity/permeability model for fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="fvbiot.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fvbiot</span></code>: Consistent finite-volume discretizations for poroelasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="geochemistry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">geochemistry</span></code>: Surface geochemistry</a></li>
<li class="toctree-l1"><a class="reference internal" href="heterogeneity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">heterogeneity</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="hfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hfm</span></code>: Hierarchical and embedded fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="incomp.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">incomp</span></code>: Solvers for incompressible flow and transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="libgeometry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">libgeometry</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="linearsolvers.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">linearsolvers</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="matlab_bgl.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">matlab_bgl</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="mimetic.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mimetic</span></code>: Mimetic solvers for pressure problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mpfa</span></code>: Multi-point flux approximation solvers for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst_api.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst_api</span></code>: API for writing C/C++ for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst-gui.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst-gui</span></code>: Graphical user-interfaces for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="msfvm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msfvm</span></code>: Multiscale Finite-Volume method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msmfem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msmfem</span></code>: Multiscale Mixed Finite-Element method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msrsb.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msrsb</span></code>: Multiscale Restriction-Smoothed Basis method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="nwm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nwm</span></code>: Near Wellbore Modelling</a></li>
<li class="toctree-l1"><a class="reference internal" href="opm_gridprocessing.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">opm_gridprocessing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">optimization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="re-mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">re-mpfa</span></code>: Richards’ equation with multi-point flux</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvent.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solvent</span></code>: Solvent solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="spe10.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">spe10</span></code>: Access to the SPE10 benchmark case</a></li>
<li class="toctree-l1"><a class="reference internal" href="steady-state.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">steady-state</span></code> Steady-state upscaling of functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamlines.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">streamlines</span></code>: Compute streamlines</a></li>
<li class="toctree-l1"><a class="reference internal" href="triangle.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">triangle</span></code>: Triangular grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="upscaling.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaling</span></code>: Upscaling of reservoir problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="vem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vem</span></code>: Virtual element method on general grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="vemmech.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vemmech</span></code>: Mechanics for general grids using the virtual element method</a></li>
<li class="toctree-l1"><a class="reference internal" href="wellpaths.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">wellpaths</span></code>: Generation of wells using general curves</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Matlab Reservoir Simulation Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Core functionality</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/core.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="core-functionality">
<h1>Core functionality<a class="headerlink" href="#core-functionality" title="Permalink to this headline"></a></h1>
<dl class="simple">
<dt>The core module offers data structures and routines for creating and manipulating:</dt><dd><ul class="simple">
<li><p>geological description: structured and unstructured grids</p></li>
<li><p>petrophysical properties (porosity, permeability, net to gross, etc)</p></li>
<li><p>drive mechanisms (wells, boundary conditions)</p></li>
<li><p>reservoir state (pressures, saturations, fluxes, etc.)</p></li>
</ul>
</dd>
</dl>
<p>This includes, in particular, a large number of grid-factory routines and a routine for computing transmissibilities.</p>
<p>In addition, the core module provides:</p>
<blockquote>
<div><ul class="simple">
<li><p>a library for automatic differentiation geared towards sparse matrices and coupled PDEs</p></li>
<li><p>plotting of cell and face data defined over MRST grids</p></li>
<li><p>physical units (length, time, mass, pressures, etc) and conversion routines</p></li>
<li><p>basic reading, parsing, and writing ECLIPSE input data</p></li>
<li><p>various utility routines and functionality</p></li>
</ul>
</div></blockquote>
<p>To get started we suggest you look at some examples. To list all the examples in mrst core at the matlab command prompt type:</p>
<p>&gt;&gt; mrstExamples</p>
<p>Each module also has its own examples which can also be listed, e.g. to list examples for the ad-core module you could type:</p>
<p>&gt;&gt; mrstExamples ad-core</p>
<div class="section" id="plotting-routines">
<h2>Plotting routines<a class="headerlink" href="#plotting-routines" title="Permalink to this headline"></a></h2>
<p>A number of plotting routines are found as a part of MRST core. Different
routines allow for plotting of general unstructured grids, as well as data
located in cells, on faces or on nodes. For more interactive tools that build
upon this functionality, see the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst-gui</span></code> module.</p>
<span class="target" id="module-core.plotting"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.plotting.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.plotting.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>PLOTTING</dt><dd><p>Routines for visual inspection of grid geometry and field properties.</p>
</dd>
<dt>Files</dt><dd><p>boundaryFaces         - Extract boundary faces from set of grid cells.
colorbarHist          - Make colorbar with histogram on top
mrstColorbar          - Append a colorbar with an accompanying histogram to the current axis
outlineCoarseGrid     - Impose outline of coarse grid on existing grid plot.
plotBlockAndNeighbors - Plot a coarse block and its neighbours to current axes (reversed Z axis).
plotCellData          - Plot exterior grid faces, coloured by given data, to current axes.
plotContours          - Plot contours of cell data.
plotFaceData          - Plot face data on exterior grid faces to current axes (reversed Z axis).
plotFaces             - Plot selection of coloured grid faces to current axes (reversed Z axis).
plotFaults            - Plot faults in model
plotGrid              - Plot exterior faces of grid to current axes.
plotGridVolumes       - Plot partially transparent isosurfaces for a set of values
plotNodeData          - Plot data defined on nodes of grid
plotSlice             - Plot Cartesian slices of cell data on faces
plotWell              - Plot well trajectories into current axes.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.boundaryFaces">
<span class="sig-name descname"><span class="pre">boundaryFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.boundaryFaces" title="Permalink to this definition"></a></dt>
<dd><p>Extract boundary faces from set of grid cells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">f</span>     <span class="p">=</span> <span class="n">boundaryFaces</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="n">f</span>     <span class="p">=</span> <span class="n">boundaryFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>

<span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="p">=</span> <span class="n">boundaryFaces</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>cells</strong> – Non-empty subset of cells from which to extract boundary faces.
OPTIONAL.  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">G.cells.num</span></code>, meaning
all external faces for all grid cells will be extracted. This
amounts to extracting the entire boundary of ‘G’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>f</strong> – List of faces bounding the sub domain given by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span></code>.</p></li>
<li><p><strong>c</strong> – List of specific grid cells connected to the individual faces in
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">f</span></code>.  This may be useful for plotting cell data (e.g., the cell
pressure) on the sub domain faces by means of function <a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span>    <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
<span class="n">rock</span> <span class="p">=</span> <span class="o">&lt;</span><span class="n">some</span> <span class="n">rock</span> <span class="n">data</span> <span class="n">structure</span> <span class="k">for</span> <span class="n">G</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c">% 1) Plot (external) geometry of &#39;G&#39;.</span>
<span class="n">f</span>  <span class="p">=</span> <span class="n">boundaryFaces</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
<span class="n">hg</span> <span class="p">=</span> <span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

<span class="c">% 2) Plot horizontal permeability along diagonal of reservoir</span>
<span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="p">=</span> <span class="n">boundaryFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">);</span>
<span class="n">hd</span>     <span class="p">=</span> <span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">log10</span><span class="p">(</span><span class="n">rock</span><span class="p">.</span><span class="n">perm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.colorbarHist">
<span class="sig-name descname"><span class="pre">colorbarHist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">q</span></em>, <em class="sig-param"><span class="pre">lim</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.colorbarHist" title="Permalink to this definition"></a></dt>
<dd><p>Make colorbar with histogram on top</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">colorbarHist</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">lim</span><span class="p">)</span>
<span class="p">[</span><span class="n">hc</span><span class="p">,</span><span class="n">hh</span><span class="p">]</span> <span class="p">=</span> <span class="n">colorbarHist</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">lim</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
<span class="p">[</span><span class="n">hc</span><span class="p">,</span><span class="n">hh</span><span class="p">]</span> <span class="p">=</span> <span class="n">colorbarHist</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">lim</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="p">[</span><span class="n">hc</span><span class="p">,</span><span class="n">hh</span><span class="p">]</span> <span class="p">=</span> <span class="n">colorbarHist</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">lim</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">islog</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> – vector for which histogram is to be defined</p></li>
<li><p><strong>lim</strong> – defines the range of values used to set limits of colorbar and
axis of histogram for q</p></li>
<li><p><strong>loc</strong> – location of colorbar: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">East</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">West</span></code>, or <code class="xref mat mat-func docutils literal notranslate"><span class="pre">South</span></code> (default)</p></li>
<li><p><strong>n</strong> – number of bins in histogram (default: 50). See the documentation
of hist for the interpretation of this parameter.</p></li>
<li><p><strong>islog</strong> – flag indicating that we should visualize q on a logarithmic scale</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>hc</strong> – graphics handle to colorbar</p></li>
<li><p><strong>hh</strong> – graphics handle to histogram</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hist</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.mrstColorbar">
<span class="sig-name descname"><span class="pre">mrstColorbar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.mrstColorbar" title="Permalink to this definition"></a></dt>
<dd><p>Append a colorbar with an accompanying histogram to the current axis</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mrstColorbar</span>
<span class="n">mrstColorbar</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
<span class="n">mrstColorbar</span><span class="p">(..,</span><span class="n">values</span><span class="p">)</span>
<span class="p">[</span><span class="n">hc</span><span class="p">,</span><span class="n">hh</span><span class="p">]</span> <span class="p">=</span> <span class="n">mrstColorbar</span><span class="p">(..,</span><span class="n">location</span><span class="p">)</span>
<span class="p">[</span><span class="n">hc</span><span class="p">,</span><span class="n">hh</span><span class="p">]</span> <span class="p">=</span> <span class="n">mrstColorbar</span><span class="p">(..,</span><span class="n">location</span><span class="p">,</span> <span class="n">logscale</span><span class="p">)</span>
<span class="p">[</span><span class="n">hc</span><span class="p">,</span><span class="n">hh</span><span class="p">]</span> <span class="p">=</span> <span class="n">mrstColorbar</span><span class="p">(..,</span><span class="n">location</span><span class="p">,</span> <span class="n">logscale</span><span class="p">,</span> <span class="n">limits</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ax</strong> – add colorbar to axes AX instead of current axis</p></li>
<li><p><strong>values</strong> – create the accompanying histogram using the VALUES vector.
If not specified, the routine will pick values from CData
of the current axes. Notice that many 3D plots in MRST only
show the outer surface of a grid and hence the histogram
will not represent the full 3D dataset unless this is
explicitly specified.</p></li>
<li><p><strong>location</strong> – location of colorbar, same as for MATLAB’s colorbar except
that the colorbar is always placed outside of the plot</p></li>
<li><p><strong>logscale</strong> – flag indicating that the data displayed are shown on a
logarithmic scale. This will manipulate the the tick marks
on the colorbar so that they are given in scientific
notation</p></li>
<li><p><strong>limits</strong> – lower and upper limits for the histogram bins. NB! Setting
this parameter will also reset the caxis accordingly.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>hc</strong> – graphics handle to colorbar</p></li>
<li><p><strong>hh</strong> – graphics handle to histogram</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hist</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.outlineCoarseGrid">
<span class="sig-name descname"><span class="pre">outlineCoarseGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.outlineCoarseGrid" title="Permalink to this definition"></a></dt>
<dd><p>Impose outline of coarse grid on existing grid plot.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">outlineCoarseGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
 <span class="n">outlineCoarseGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
 <span class="n">outlineCoarseGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="s">&#39;pv1&#39;</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">outlineCoarseGrid</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>p</strong> – Coarse grid partition vector as defined by (e.g) partitionUI
and processPartition.</p></li>
<li><p><strong>c</strong> – color, works only if G.griddim==2</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘Any’</strong> – Additional keyword arguments will be passed directly on to
function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> meaning all properties supported by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>
are valid.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to polygonal patch structure as defined by function
plotFaces. Only returned if requested.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span>  <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">p</span>  <span class="p">=</span> <span class="n">partitionUI</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
<span class="c">% plot fine grid:</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;faceColor&#39;</span><span class="p">,</span> <span class="s">&#39;none&#39;</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="c">% outline coarse grid on fine grid:</span>
<span class="n">outlineCoarseGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>, <a class="reference internal" href="#core.plotting.plotGrid" title="core.plotting.plotGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGrid</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotBlockAndNeighbors">
<span class="sig-name descname"><span class="pre">plotBlockAndNeighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">CG</span></em>, <em class="sig-param"><span class="pre">block</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotBlockAndNeighbors" title="Permalink to this definition"></a></dt>
<dd><p>Plot a coarse block and its neighbours to current axes (reversed Z axis).</p>
<p>Different colours and levels of transparency are used to distinguish the
blocks.  The block itself is plotted in blue colour and the neighbours
using colours from a brightened COLORCUBE colour map.  Faults are plotted
using gray patches (RGB = REPMAT(0.7, [1, 3])) with red edge colours.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotBlockAndNeighbors</span><span class="p">(</span><span class="n">CG</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
 <span class="n">plotBlockAndNeighbors</span><span class="p">(</span><span class="n">CG</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="s">&#39;pv1&#39;</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotBlockAndNeighbors</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>CG</strong> – Coarse grid data structure.</p></li>
<li><p><strong>block</strong> – The coarse block to be plotted.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>PlotFaults</strong> – Two-element <code class="xref mat mat-func docutils literal notranslate"><span class="pre">logical</span></code> vector, the entries of which specify
whether or not fault faces should be added to the
graphical output of the ‘block’ and its neighbours,
respectively.</p>
<p>DEFAULT: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PlotFaults</span> <span class="pre">=</span> <span class="pre">TRUE([1,2])</span></code> (attach fault faces
to both the ‘block’ and all of its neighbours).</p>
</li>
<li><p><strong>Alpha</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">(2</span> <span class="pre">+</span> <span class="pre">max(find(PlotFaults)))</span></code>-element numeric vector,
values in [0,1], specifying scalar transparency
(<code class="xref mat mat-func docutils literal notranslate"><span class="pre">AlphaData</span></code>) values for the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">block</span></code>, its neighbours, and
the fault faces of the ‘block’ and its neighbours,
respectively.</p>
<p>DEFAULT: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Alpha</span> <span class="pre">=</span> <span class="pre">ONES([1,4])</span></code> (no transparency in any of
the final objects–all objects drawn opaquely).</p>
</li>
<li><p><strong>‘Any’</strong> – Additional keyword arguments will be passed directly on to
function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> meaning all properties supported by
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> are valid.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to resulting patch objects.  The patch objects are added
directly to the current <code class="xref mat mat-func docutils literal notranslate"><span class="pre">axes</span></code> object (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">gca</span></code>).
OPTIONAL.  Only returned if specifically requested.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Plot a block and its neighbours from a coarse partitioning of the</span>
<span class="c">% &quot;model 3&quot; synthetic geometry</span>
<span class="n">require</span> <span class="n">coarsegrid</span>  <span class="c">%  Make &quot;coarse block&quot; concept meaningful</span>

<span class="c">% Generate geometry</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">makeModel3</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">15</span><span class="p">]));</span>

<span class="c">% Partition geometry</span>
<span class="n">p</span> <span class="p">=</span> <span class="n">partitionUI</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span> <span class="p">]);</span>
<span class="n">p</span> <span class="p">=</span> <span class="n">compressPartition</span><span class="p">(</span><span class="n">processPartition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>

<span class="c">% Generate coarse grid</span>
<span class="n">CG</span> <span class="p">=</span> <span class="n">generateCoarseGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

<span class="c">% Plot selected block (# 37) and its neighbours</span>
<span class="n">plotBlockAndNeighbors</span><span class="p">(</span><span class="n">CG</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="s">&#39;Alpha&#39;</span><span class="p">,</span> <span class="nb">repmat</span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="nb">view</span><span class="p">(</span><span class="o">-</span><span class="mi">145</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Function <a class="reference internal" href="#core.plotting.plotBlockAndNeighbors" title="core.plotting.plotBlockAndNeighbors"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotBlockAndNeighbors</span></code></a> is implemented in terms of plotting
function <a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a> which in turn uses the built-in function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>.
If a separate axes is needed for the graphical output, callers should
employ function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code> prior to calling <a class="reference internal" href="#core.plotting.plotBlockAndNeighbors" title="core.plotting.plotBlockAndNeighbors"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotBlockAndNeighbors</span></code></a>.  This
function relies on a specific set of values for the properties
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">FaceColor</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FaceAlpha</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotCellData">
<span class="sig-name descname"><span class="pre">plotCellData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">data</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotCellData" title="Permalink to this definition"></a></dt>
<dd><p>Plot exterior grid faces, coloured by given data, to current axes.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
 <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
 <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>
 <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotCellData</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>data</strong> – Scalar cell data with which to colour the grid.  One scalar,
indexed colour value for each cell in the grid or one
TrueColor value for each cell.  If a cell subset is specified
in terms of the ‘cells’ parameter, ‘data’ must either contain
one scalar value for each cell in the model or one scalar
value for each cell in this subset.</p></li>
<li><p><strong>cells</strong> – <p>Vector of cell indices defining sub grid.  The graphical
output of function ‘plotCellData’ will be restricted to the
subset of cells from ‘G’ represented by ‘cells’.</p>
<p>If unspecified, function ‘plotCellData’ will behave as if the
user defined</p>
<blockquote>
<div><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">G.cells.num</span></code></p>
</div></blockquote>
<p>meaning graphical output will be produced for all cells in
the grid model <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code>.  If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span></code> is empty (i.e., if
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(cells))</span></code>, then no graphical output will be produced.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘Any’</strong> – Additional keyword arguments will be passed directly on to
function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> meaning all properties supported by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>
are valid.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to resulting patch object.  The patch object is added
directly to the current <code class="xref mat mat-func docutils literal notranslate"><span class="pre">axes</span></code> object (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">gca</span></code>).
OPTIONAL.  Only returned if specifically requested.  If
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(cells)</span></code>, then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h==-1</span></code>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Function <a class="reference internal" href="#core.plotting.plotCellData" title="core.plotting.plotCellData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotCellData</span></code></a> is implemented directly in terms of the
low-level function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>.  If a separate axes is needed for the
graphical output, callers should employ function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code> prior to
calling <a class="reference internal" href="#core.plotting.plotCellData" title="core.plotting.plotCellData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotCellData</span></code></a>.</p>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Given a grid &#39;G&#39; and a reservoir solution structure &#39;resSol&#39; returned</span>
<span class="c">% from, e.g., function &#39;solveIncompFlow&#39;, plot the cell pressure in bar:</span>

   <span class="nb">figure</span><span class="p">,</span> <span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">convertTo</span><span class="p">(</span><span class="n">resSol</span><span class="p">.</span><span class="n">pressure</span><span class="p">,</span> <span class="n">barsa</span><span class="p">()));</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>, <a class="reference internal" href="#core.plotting.boundaryFaces" title="core.plotting.boundaryFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">boundaryFaces</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotContours">
<span class="sig-name descname"><span class="pre">plotContours</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em>, <em class="sig-param"><span class="pre">value</span></em>, <em class="sig-param"><span class="pre">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotContours" title="Permalink to this definition"></a></dt>
<dd><p>Plot contours of cell data.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">plotContours</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Function ‘plotContours’ is a poor-man’s implementation of the
contour-level drawing function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">contourf</span></code> designed to work with MRST’s
grid structure and cell-based values rather than the pure Cartesian
(tensor product) nodal values of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">contourf</span></code>.  The contour lines follow
the grid lines and are, typically, not smooth.</p>
<p>The MRST function <a class="reference internal" href="#core.plotting.plotGridVolumes" title="core.plotting.plotGridVolumes"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGridVolumes</span></code></a>, which interpolates the data field
onto a structured grid, is an alternative option for visualising levels
and iso-surfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure.</p></li>
<li><p><strong>field</strong> – Scalar field (e.g., cell pressures).  Used as value data for
determining the contour locations.  One scalar value for each
cell in ‘G’.</p></li>
<li><p><strong>n</strong> – Number of (equidistant) contour lines/levels for <code class="xref mat mat-func docutils literal notranslate"><span class="pre">field</span></code>.
Positive integer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Nothing.</strong></p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Visualise the iso-levels of the pressure field of a quarter five-spot</span>
<span class="c">% configuration.  Note that the actual pressure values in this case are</span>
<span class="c">% artificial due to (very) high permeabilities (approximately 1e+12 D).</span>
<span class="c">%</span>
<span class="n">G</span>     <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">1</span><span class="p">]));</span>
<span class="n">rock</span>  <span class="p">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s">&#39;perm&#39;</span><span class="p">,</span> <span class="nb">ones</span><span class="p">([</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">]));</span>
<span class="n">T</span>     <span class="p">=</span> <span class="n">computeTrans</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">);</span>
<span class="n">fluid</span> <span class="p">=</span> <span class="n">initSingleFluid</span><span class="p">(</span><span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;rho&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">src</span>   <span class="p">=</span> <span class="n">addSource</span><span class="p">([],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">x</span>     <span class="p">=</span> <span class="n">initState</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">x</span>     <span class="p">=</span> <span class="n">incompTPFA</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="s">&#39;src&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>

<span class="n">plotContours</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">pressure</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="nb">axis</span> <span class="n">equal</span> <span class="n">tight</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Function <a class="reference internal" href="#core.plotting.plotContours" title="core.plotting.plotContours"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotContours</span></code></a> is only supported in three space dimensions
i.e., if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.griddim</span> <span class="pre">==</span> <span class="pre">3</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotGridVolumes" title="core.plotting.plotGridVolumes"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGridVolumes</span></code></a>, <a class="reference internal" href="#core.plotting.plotCellData" title="core.plotting.plotCellData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotCellData</span></code></a>, <a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">contourf</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotFaceData">
<span class="sig-name descname"><span class="pre">plotFaceData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotFaceData" title="Permalink to this definition"></a></dt>
<dd><p>Plot face data on exterior grid faces to current axes (reversed Z axis).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotFaceData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
 <span class="n">plotFaceData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
 <span class="n">plotFaceData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
 <span class="n">plotFaceData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotFaceData</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>data</strong> – Vector of values for each face in G.</p></li>
<li><p><strong>cells</strong> – <p>Vector of cell indices defining sub grid.</p>
<p>If unspecified, function <a class="reference internal" href="#core.plotting.plotFaceData" title="core.plotting.plotFaceData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaceData</span></code></a> will behave as if the
caller defined</p>
<blockquote>
<div><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">G.cells.num</span></code></p>
</div></blockquote>
<p>meaning graphical output will be produced for all cells in
the grid model <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code>.  If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span></code> is empty (i.e., if
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(cells)</span></code>), then no graphical output will be produced.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘Any’</strong> – Additional keyword arguments will be passed directly on to
function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> meaning all properties supported by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>
are valid.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to resulting patch object.  The patch object is added
directly to the current <code class="xref mat mat-func docutils literal notranslate"><span class="pre">axes</span></code> object (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">gca</span></code>).
OPTIONAL.  Only returned if specifically requested.  If
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(cells)</span></code>, then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h==-1</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotCellData" title="core.plotting.plotCellData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotCellData</span></code></a>, <a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotFaces">
<span class="sig-name descname"><span class="pre">plotFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotFaces" title="Permalink to this definition"></a></dt>
<dd><p>Plot selection of coloured grid faces to current axes (reversed Z axis).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">)</span>
 <span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
 <span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">colour</span><span class="p">)</span>
 <span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">colour</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotFaces</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>faces</strong> – Vector of face indices or a logical vector of length
G.faces.num.  The graphical output of <a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>
will be restricted to the subset of grid faces from <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code>
represented by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces</span></code>.</p></li>
<li><p><strong>colour</strong> – <p>Colour data specification.  Either a MATLAB <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ColorSpec</span></code>
(i.e., an RGB triplet (1-by-3 row vector) or a short or long
colour name such as ‘r’ or ‘cyan’), or a <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">FaceVertexCData</span></code> table suitable for either indexed or
‘true-colour’ face colouring.  This data <em>MUST</em> be an m-by-1
column vector or an m-by-3 matrix.  We assume the following
conventions for the size of the colour data:</p>
<blockquote>
<div><ul>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">any(size(colour,1)</span> <span class="pre">==</span> <span class="pre">[1,</span> <span class="pre">numel(faces)])</span></code>
One (constant) indexed colour for each face in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces</span></code>.
This option supports <code class="xref mat mat-func docutils literal notranslate"><span class="pre">flat</span></code> face shading only.  If
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">size(colour,1)</span> <span class="pre">==</span> <span class="pre">1</span></code>, then the same colour is used for
all faces in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces</span></code>.</p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">size(colour,1)</span> <span class="pre">==</span> <span class="pre">G.nodes.num</span></code>
One (constant) indexed colour for each node in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces</span></code>.
This option must be chosen in order to support
interpolated face shading.</p></li>
</ul>
</div></blockquote>
<p>OPTIONAL.  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">colour</span> <span class="pre">=</span> <span class="pre">'y'</span></code> (shading flat).</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘Any ‘</strong> – Additional keyword arguments will be passed directly on to
function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> meaning all properties supported by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>
are valid.</p></li>
<li><p><strong>‘Outline’</strong> – Boolean option. When enabled, <a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a> draws the outline
edge of the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces</span></code> input argument.  The outline is defined
as those edges that appear exactly once in the edge list
implied by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces</span></code>.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to resulting <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> object.  The patch object is added to the
current <code class="xref mat mat-func docutils literal notranslate"><span class="pre">axes</span></code> object.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Function <a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a> is implemented directly in terms of the low-level
function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>.  If a separate axes is needed for the graphical output,
callers should employ function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code> prior to calling <a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>.</p>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Plot grid with boundary faces on left side in red colour:</span>
<span class="n">G</span>     <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">faces</span> <span class="p">=</span> <span class="n">boundaryFaceIndices</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;LEFT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">[]);</span>
<span class="n">plotGrid</span> <span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;faceColor&#39;</span><span class="p">,</span> <span class="s">&#39;none&#39;</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotCellData" title="core.plotting.plotCellData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotCellData</span></code></a>, <a class="reference internal" href="#core.plotting.plotGrid" title="core.plotting.plotGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGrid</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">shading</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotFaults">
<span class="sig-name descname"><span class="pre">plotFaults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">faults</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotFaults" title="Permalink to this definition"></a></dt>
<dd><p>Plot faults in model</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">plotFaults</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faults</span><span class="p">)</span>
<span class="n">h</span> <span class="p">=</span> <span class="n">plotFaults</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faults</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Valid grid structure.</p></li>
<li><p><strong>faults</strong> – Valid fault structure as defined by function <a class="reference internal" href="#core.gridprocessing.processFaults" title="core.gridprocessing.processFaults"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processFaults</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> – Two-element cell array of handles suitable for passing to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">get</span></code> or
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">set</span></code>.  Specifically, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h{1}</span></code> is a <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> handle to the set of
graphics containing the fault faces while <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h{2}</span></code> is a set of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">text</span></code>
handles to the corresponding fault names.</p>
<p>OPTIONAL.  Only returned if specifically requested.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">text</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotGrid">
<span class="sig-name descname"><span class="pre">plotGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotGrid" title="Permalink to this definition"></a></dt>
<dd><p>Plot exterior faces of grid to current axes.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
 <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>
 <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotGrid</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>cells</strong> – <p>Vector of cell indices defining sub grid.  The graphical
output of function <a class="reference internal" href="#core.plotting.plotGrid" title="core.plotting.plotGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGrid</span></code></a> will be restricted to the
subset of cells from <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> represented by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span></code>.</p>
<p>If unspecified, function <a class="reference internal" href="#core.plotting.plotGrid" title="core.plotting.plotGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGrid</span></code></a> will behave as if the
caller defined</p>
<blockquote>
<div><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">G.cells.num</span></code></p>
</div></blockquote>
<p>meaning graphical output will be produced for all cells in
the grid model <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code>.  If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span></code> is empty (i.e., if
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(cells)</span></code>), then no graphical output will be produced.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘Any’</strong> – Additional keyword arguments will be passed directly on to
function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> meaning all properties supported by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>
are valid.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to resulting patch object.  The patch object is added
directly to the current <code class="xref mat mat-func docutils literal notranslate"><span class="pre">axes</span></code> object (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">gca</span></code>).
OPTIONAL.  Only returned if specifically requested.  If
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(cells)</span></code>, then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h==-1</span></code>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Function <a class="reference internal" href="#core.plotting.plotGrid" title="core.plotting.plotGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGrid</span></code></a> is implemented directly in terms of the low-level
function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>.  If a separate axes is needed for the graphical output,
callers should employ function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code> prior to calling <a class="reference internal" href="#core.plotting.plotGrid" title="core.plotting.plotGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGrid</span></code></a>.</p>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>

<span class="c">% 1) Plot grid with yellow colour on faces (default):</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;EdgeAlpha&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c">% 2) Plot grid with no colour on faces (transparent faces):</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;FaceColor&#39;</span><span class="p">,</span> <span class="s">&#39;none&#39;</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotCellData" title="core.plotting.plotCellData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotCellData</span></code></a>, <a class="reference internal" href="#core.plotting.plotFaces" title="core.plotting.plotFaces"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotFaces</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotGridVolumes">
<span class="sig-name descname"><span class="pre">plotGridVolumes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">values</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotGridVolumes" title="Permalink to this definition"></a></dt>
<dd><p>Plot partially transparent isosurfaces for a set of values</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">plotGridVolumes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">plotGridVolumes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">,...)</span>
<span class="n">interpolant</span> <span class="p">=</span> <span class="n">plotGridVolumes</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure</p></li>
<li><p><strong>values</strong> – A list of values to be plotted</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘N’</strong> – The number of bins used to create the isosurfaces.</p></li>
<li><p><strong>‘min’</strong> – Minimum value to plot. This is useful to create plots where
high values are visible.</p></li>
<li><p><strong>‘max’</strong> – Maximum value to plot.</p></li>
<li><p><strong>‘mesh’</strong> – The mesh size used to sample the interpolant. Should be a row
vector of length 3. Defaults to G.cartDims.</p></li>
<li><p><strong>‘cmap’</strong> – Function handle to colormap function. Using different
colormaps for different datasets makes it possible to create
fairly complex visualizations.</p></li>
<li><p><strong>‘basealpha’</strong> – Set to a value lower than 1 to increase transparency, set
it to a larger value to decrease transparency.</p></li>
<li><p><strong>‘binc’</strong> – Do not call hist on dataset. Instead, use provided bins. To
get good results, do <em>not</em> call binc option with unique(data):
Ideally, binc’s values should be between the unique values.</p></li>
<li><p><strong>‘patchn’</strong> – Maximum number of patch faces in total for one call of
plotGridVolumes. If this number is large, the process may be
computationally intensive.</p></li>
<li><p><strong>‘interpolant’</strong> – If you are plotting the same dataset many times, the
interpolant can be returned and stored.</p></li>
<li><p><strong>‘extrudefaces’</strong> – Let the cell values be extrapolated to the edges of the
domain. Turn this off if you get strange results.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>interpolant</strong> – See keyword argument of same name.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotCellData" title="core.plotting.plotCellData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotCellData</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotNodeData">
<span class="sig-name descname"><span class="pre">plotNodeData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">node_data</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotNodeData" title="Permalink to this definition"></a></dt>
<dd><p>Plot data defined on nodes of grid</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">plotNodeData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>node_data</strong> – Data at nodes to be plotted.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘Any’</strong> – Additional keyword arguments will be passed directly on to
function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> meaning all properties supported by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>
are valid.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to resulting PATCH object.  The patch object is added to the
current AXES object.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]);</span>
<span class="n">plotNodeData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">));</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotCellData" title="core.plotting.plotCellData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotCellData</span></code></a>, <a class="reference internal" href="#core.plotting.plotGrid" title="core.plotting.plotGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGrid</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">newplot</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">shading</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotSlice">
<span class="sig-name descname"><span class="pre">plotSlice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">data_in</span></em>, <em class="sig-param"><span class="pre">slice_ind</span></em>, <em class="sig-param"><span class="pre">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotSlice" title="Permalink to this definition"></a></dt>
<dd><p>Plot Cartesian slices of cell data on faces</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="p">=</span> <span class="n">plotSlice</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data_inn</span><span class="p">,</span> <span class="n">slice_ind</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>data_in</strong> – Cell data to be plotted</p></li>
<li><p><strong>slice_ind</strong> – Index of slice</p></li>
<li><p><strong>dim</strong> – Dimension of slice</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> – Handle to resulting <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code> object.  The patch object is added to
the current <code class="xref mat mat-func docutils literal notranslate"><span class="pre">axes</span></code> object.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.plotting.plotWell">
<span class="sig-name descname"><span class="pre">plotWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.plotting.plotWell" title="Permalink to this definition"></a></dt>
<dd><p>Plot well trajectories into current axes.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">htop</span><span class="p">,</span> <span class="n">htext</span><span class="p">,</span> <span class="n">hs</span><span class="p">,</span> <span class="n">hline</span><span class="p">]</span> <span class="p">=</span> <span class="n">plotWell</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
<span class="p">[</span><span class="n">htop</span><span class="p">,</span> <span class="n">htext</span><span class="p">,</span> <span class="n">hs</span><span class="p">,</span> <span class="n">hline</span><span class="p">]</span> <span class="p">=</span> <span class="n">plotWell</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure</p></li>
<li><p><strong>W</strong> – Well data structure</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘radius’</strong> – Scaling factor for the width of the well path.
Default value: 1.0</p></li>
<li><p><strong>‘height’</strong> – Height above top reservoir contact at which the well should
stop and symbol be drawn.
Default value: height = 5</p></li>
<li><p><strong>‘color’</strong> – Colour with which the well path should be drawn.  Possible
values described in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">plot</span></code>.
Default value: color = ‘r’</p></li>
<li><p><strong>‘color2’</strong> – Second color. Will be used for producer wells. If not
specified, all wells will have the same color and the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">color</span></code>
argument will be used.</p></li>
<li><p><strong>‘cylpts’</strong> – Number of segments to use about the well bore. A higher value
produces more smoothly looking well trajectories at the
expense of more costly plotting.
Default value: cylpts = 10</p></li>
<li><p><strong>‘fontsize’</strong> – The size of the font used for the label texts.
Default value: fontsize = 16</p></li>
<li><p><strong>‘ambstr’</strong> – The ambient strength of the well cylinder.
Default value: ambstr = 0.8</p></li>
<li><p><strong>‘linewidth’</strong> – The width of the line above the well.
Default value: linewidth = 2</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>htop</strong> – Graphics handles to all well heads and heels.</p></li>
<li><p><strong>htext</strong> – Graphics handles to all rendered well names.</p></li>
<li><p><strong>hs</strong> – Graphics handles to all well paths.</p></li>
<li><p><strong>hline</strong> – Graphics handles to all lines between well head and names</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]));</span>
<span class="n">rock</span> <span class="p">=</span> <span class="n">makeRock</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">W</span> <span class="p">=</span> <span class="n">addWell</span><span class="p">([],</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plotWell</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="s">&#39;color&#39;</span><span class="p">,</span> <span class="s">&#39;k&#39;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, this function only supports three-dimensional grids.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">delete</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">patch</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">incompTutorialWells</span></code>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="grid-generation-processing-and-manipulation">
<h2>Grid generation, processing and manipulation<a class="headerlink" href="#grid-generation-processing-and-manipulation" title="Permalink to this headline"></a></h2>
<span class="target" id="module-core.gridprocessing"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.gridprocessing.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.gridprocessing.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>GRIDPROCESSING</dt><dd><p>Construct and manipulate the MRST grid datastructures.</p>
</dd>
<dt>Files</dt><dd><p>buildCornerPtNodes      - Construct physical nodal coordinates for CP grid.
buildCornerPtPillars    - Construct physical nodal coordinates for CP grid.
cart2active             - Compute active cell numbers from linear Cartesian index.
cartGrid                - Construct 2d or 3d Cartesian grid in physical space.
cellNodes               - Extract local-to-global vertex numbering for grid cells.
checkAndRepairZCORN     - Detect and repair artifacts that may occur in corner-point specification.
computeGeometry         - Add geometry information (centroids, volumes, areas) to a grid
extended_grid_structure - Extended grid structure
extractSubgrid          - Construct valid grid definition from subset of existing grid cells.
glue2DGrid              - Connect two 2D grids along common edges
grid_structure          - Grid structure used in the MATLAB Reservoir Simulation Toolbox.
grdeclXYZ               - Get corner-point pillars and coordinates in alternate format
hexahedralGrid          - Construct valid grid definition from points and list of hexahedra
makeInternalBoundary    - Make internal boundary in grid along specified faces.
makeLayeredGrid         - Extrude 2D Grid to layered 3D grid with specified layering structure
pebi                    - Compute dual grid of triangular grid G.
processFaults           - Construct fault structure from input specification (keyword <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FAULTS</span></code>)
processGRDECL           - Compute grid topology and geometry from pillar grid description.
processNNC              - Establish explicit non-neighbouring connections from NNC keyword
processPINCH            - Establish vertical non-neighbouring across pinched-out layers
refineDeck              - Refine the grid resolution of a deck, and update other information
refineGrdecl            - Refine an Eclipse grid (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">GRDECL</span> <span class="pre">file</span></code>) with a specified factor in each of
removeCells             - Remove cells from grid and renumber cells, faces and nodes.
removeFaultBdryFaces    - Remove fault faces on boundary
removeInternalBoundary  - Remove internal boundary in grid by merging faces in face list N
removeIntGrid           - Cast any grid fields that are presently int32 to double
removePinch             - Uniquify nodes, remove pinched faces and cells.
removeShortEdges        - Replace short edges in grid G by a single node.
splitDisconnectedGrid   - Split grid into disconnected components
tensorGrid              - Construct Cartesian grid with variable physical cell sizes.
tessellationGrid        - Construct valid grid definition from points and tessellation list
tetrahedralGrid         - Construct valid grid definition from points and tetrahedron list
triangleGrid            - Construct valid grid definition from points and triangle list
triangulateFaces        - Split face f in grid G into subfaces.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.buildCornerPtNodes">
<span class="sig-name descname"><span class="pre">buildCornerPtNodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.buildCornerPtNodes" title="Permalink to this definition"></a></dt>
<dd><p>Construct physical nodal coordinates for CP grid.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">lineIx</span><span class="p">]</span> <span class="p">=</span> <span class="n">buildCornerPtNodes</span><span class="p">(</span><span class="n">grdecl</span><span class="p">)</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">lineIx</span><span class="p">]</span> <span class="p">=</span> <span class="n">buildCornerPtNodes</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – Eclipse file output structure as defined by <a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>.
Must contain at least the fields <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartDims</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">COORD</span></code> and
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ZCORN</span></code>.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘Verbose’</strong> – Whether or not to emit informational messages.
Default value: Verbose = mrstVerbose.</p></li>
<li><p><strong>‘CoincidenceTolerance’</strong> – Absolute tolerance used to detect collapsed
pillars where the top pillar point coincides
with the bottom pillar point.  Such pillars are
treated as is they were vertical.
Default value: CoincidenceTolerance = <code class="xref mat mat-func docutils literal notranslate"><span class="pre">100*eps</span></code>.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X, Y, Z</strong> – Size <code class="xref mat mat-func docutils literal notranslate"><span class="pre">2*grdecl.cartDims</span></code> arrays of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">y</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">z</span></code> physical
nodal coordinates, respectively.</p></li>
<li><p><strong>lineIx</strong> – Index of pillar line. There are (nx+1)x(ny+1) pillar lines
along which node coordinates are defined by their <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ZCORN</span></code>
value.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">gridfile</span>  <span class="p">=</span> <span class="p">[</span><span class="n">DATADIR</span><span class="p">,</span> <span class="nb">filesep</span><span class="p">,</span> <span class="s">&#39;case.grdecl&#39;</span><span class="p">];</span>
<span class="n">grdecl</span>    <span class="p">=</span> <span class="n">readGRDECL</span><span class="p">(</span><span class="n">gridfile</span><span class="p">);</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">]</span> <span class="p">=</span> <span class="n">buildCornerPtNodes</span><span class="p">(</span><span class="n">grdecl</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.buildCornerPtPillars">
<span class="sig-name descname"><span class="pre">buildCornerPtPillars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.buildCornerPtPillars" title="Permalink to this definition"></a></dt>
<dd><p>Construct physical nodal coordinates for CP grid.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">]</span> <span class="p">=</span> <span class="n">buildCornerPtPillars</span><span class="p">(</span><span class="n">grdecl</span><span class="p">)</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">]</span> <span class="p">=</span> <span class="n">buildCornerPtPillars</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – Eclipse file output structure as defined by readGRDECL.
Must contain at least the fields ‘cartDims’, ‘COORD’ and
‘ZCORN’.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘Verbose’</strong> – Whether or not to emit informational messages.
Default value: Verbose = mrstVerbose.</p></li>
<li><p><strong>‘CoincidenceTolerance’</strong> – Absolute tolerance used to detect collapsed
pillars where the top pillar point coincides
with the bottom pillar point.  Such pillars are
treated as is they were vertical.
Default value: CoincidenceTolerance = <code class="xref mat mat-func docutils literal notranslate"><span class="pre">100*eps</span></code>.</p></li>
<li><p><strong>‘Scale’</strong> – Scale the pillars so that the extend from the
top to the bottom of the model.
Default: FALSE</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X, Y, Z</strong> – Matrices with (nx+1)*(ny+1) rows with the start and end point
of the pillars in ‘x’, ‘y’, and ‘z’ direction.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">gridfile</span>  <span class="p">=</span> <span class="p">[</span><span class="n">DATADIR</span><span class="p">,</span> <span class="nb">filesep</span><span class="p">,</span> <span class="s">&#39;case.grdecl&#39;</span><span class="p">];</span>
<span class="n">grdecl</span>    <span class="p">=</span> <span class="n">readGRDECL</span><span class="p">(</span><span class="n">gridfile</span><span class="p">);</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">]</span> <span class="p">=</span> <span class="n">buildCornerPtPillars</span><span class="p">(</span><span class="n">grdecl</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.cart2active">
<span class="sig-name descname"><span class="pre">cart2active</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">cartCells</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.cart2active" title="Permalink to this definition"></a></dt>
<dd><p>Compute active cell numbers from linear Cartesian index.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">activeCells</span> <span class="p">=</span> <span class="n">cart2active</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure as described by <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p></li>
<li><p><strong>c</strong> – List of linear Cartesian cell indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>activeCells</strong> – Active cell numbers corresponding to the individual
Cartesian cell numbers in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function provides the inverse mapping of the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.indexMap</span></code>
field in the grid data structure.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <a class="reference internal" href="#core.utils.gridtools.gridLogicalIndices" title="core.utils.gridtools.gridLogicalIndices"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">gridLogicalIndices</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.cartGrid">
<span class="sig-name descname"><span class="pre">cartGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">celldim</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.cartGrid" title="Permalink to this definition"></a></dt>
<dd><p>Construct 2d or 3d Cartesian grid in physical space.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">(</span><span class="n">celldim</span><span class="p">);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">(</span><span class="n">celldim</span><span class="p">,</span> <span class="n">physdim</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>celldim</strong> – Vector, length 2 or 3, specifying number of
cells in each coordinate direction.</p></li>
<li><p><strong>physdim</strong> – Vector, length numel(celldim), of physical size in units of
meters of the computational domain.
OPTIONAL.  Default value == celldim
(i.e., each cell has physical dimension 1-by-1-by-1 m).</p></li>
<li><p><strong>cellnodes</strong> – OPTIONAL.
Default value FALSE.  If TRUE, the corner points of each
cell is added as field G.cellNodes.  The field has one row
per cell, the sequence of nodes on each is (imin,
jmin,kmin), (imax,jmin,kmin), (imin,jmax,kmin), …</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid structure with a subset of the fields <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.
Specifically, the geometry fields are missing:</p>
<blockquote>
<div><ul class="simple">
<li><p>G.cells.volumes</p></li>
<li><p>G.cells.centroids</p></li>
<li><p>G.faces.areas</p></li>
<li><p>G.faces.normals</p></li>
<li><p>G.faces.centroids</p></li>
</ul>
</div></blockquote>
<p>These fields may be computed using the function <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>.</p>
<p>There is, however, an additional field not described in
<a href="#id1"><span class="problematic" id="id2">`</span></a>grid_structure:</p>
<blockquote>
<div><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartDims</span></code> is a length 2 or 3 vector giving number of cells in
each coordinate direction.  In other words</p>
<blockquote>
<div><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">all(G.cartDims</span> <span class="pre">==</span> <span class="pre">celldim)</span></code>.</p>
</div></blockquote>
</div></blockquote>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.faces(:,2)</span></code> contains integers 1-6 corresponding to
directions W, E, S, N, T, B respectively.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Make a 10-by-5-by-2 grid on the unit cube.</span>
   <span class="n">nx</span> <span class="p">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">ny</span> <span class="p">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">nz</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>

<span class="c">% Plot the grid in 3D-view.</span>
   <span class="n">f</span> <span class="p">=</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <a class="reference internal" href="#core.gridprocessing.tensorGrid" title="core.gridprocessing.tensorGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tensorGrid</span></code></a>, <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.cellNodes">
<span class="sig-name descname"><span class="pre">cellNodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">g</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.cellNodes" title="Permalink to this definition"></a></dt>
<dd><p>Extract local-to-global vertex numbering for grid cells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">cn</span> <span class="p">=</span> <span class="n">cellNodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid data structure geometrically discretising a reservoir model.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cn</strong> – An m-by-3 array mapping cell numbers to vertex numbers.
Specifically, if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cn(i,1)==j</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cn(i,3)==k</span></code>, then global vertex
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">k</span></code> is one of the corners of cell <code class="xref mat mat-func docutils literal notranslate"><span class="pre">j</span></code>.  The local vertex number of
global node <code class="xref mat mat-func docutils literal notranslate"><span class="pre">k</span></code> within cell <code class="xref mat mat-func docutils literal notranslate"><span class="pre">j</span></code> may be computed using the
following statements:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">n_vert</span> <span class="p">=</span> <span class="nb">accumarray</span><span class="p">(</span><span class="n">cn</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
<span class="n">offset</span> <span class="p">=</span> <span class="n">rldecode</span><span class="p">(</span><span class="n">cumsum</span><span class="p">([</span><span class="mi">0</span><span class="p">;</span> <span class="n">n_vert</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)]),</span> <span class="n">n_vert</span><span class="p">);</span>
<span class="n">loc_no</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span> <span class="p">:</span> <span class="nb">size</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span><span class="mi">1</span><span class="p">)).</span><span class="o">&#39;</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
</pre></div>
</div>
<p>This calculation is only for illustration purposes.  It is assumed
that the local vertex number will be implicitly available in most
applications (e.g., finite element methods).</p>
<p>Alternatively, the local vertex number is found in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cn(i,2).</span> <span class="pre">;)</span></code>.
In a corner-point grid, local vertex number of zero indicates that
the vertex is not part of the original 8 vertices.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.checkAndRepairZCORN">
<span class="sig-name descname"><span class="pre">checkAndRepairZCORN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">zcorn</span></em>, <em class="sig-param"><span class="pre">cartDims</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.checkAndRepairZCORN" title="Permalink to this definition"></a></dt>
<dd><p>Detect and repair artifacts that may occur in corner-point specification.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">zcorn</span> <span class="p">=</span> <span class="n">checkAndRepairZCORN</span><span class="p">(</span><span class="n">zcorn</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
<span class="n">zcorn</span> <span class="p">=</span> <span class="n">checkAndRepairZCORN</span><span class="p">(</span><span class="n">zcorn</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Function <a class="reference internal" href="#core.gridprocessing.checkAndRepairZCORN" title="core.gridprocessing.checkAndRepairZCORN"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">checkAndRepairZCORN</span></code></a> detects and repairs the following, rare,
conditions</p>
<blockquote>
<div><ul class="simple">
<li><p>Upper corners of a cell below lower corners of that same cell</p></li>
<li><p>Lower corners of a cell below that cell’s lower neighbour’s upper
corners.</p></li>
</ul>
</div></blockquote>
<p>These will typically arise as a result of finite precision output from
a corner-point grid generator.</p>
<p>The repair strategy, if applicable, is as follows,</p>
<blockquote>
<div><ul class="simple">
<li><p>If an upper corner is below the corresponding lower corner on the
same pillar, then the upper corner depth is assigned to be equal to
the lower corner depth.</p></li>
<li><p>If a cell’s lower corner is below that cell’s lower neighbour’s
upper corner on the same pillar, then the lower neighbour’s upper
corner is assigned the corner depth of the upper cell’s lower
corner.</p></li>
</ul>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zcorn</strong> – Corner-point depth specification of a corner-point grid.
This value typically corresponds to the ‘ZCORN’ field of a
data structure created by function ‘readGRDECL’.</p></li>
<li><p><strong>dims</strong> – Cartesian dimensions of the corner-point geometry.  Assumed
to be a three-element vector of (positive) extents.
Typically corresponds to the field ‘cartDims’ of a ‘grdecl’
structure created by function ‘readGRDECL’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>Active</strong> – A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">prod(dims)</span></code>-element vector of active cell mappings.
Zero/false signifies inactive cells while non-zero/true
signifies active cells. Typically corresponds to the field
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ACTNUM</span></code> of a ‘grdecl’ structure.</p>
<blockquote>
<div><p>Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Active=[]</span></code> (-&gt; All cells active).</p>
</div></blockquote>
</li>
<li><p><strong>Verbose</strong> – Whether or not to emit informational messages during the
computational process.
Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Verbose</span> <span class="pre">=</span> <span class="pre">mrstVerbose</span></code>.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>zcorn</strong> – Corner-point depth specification for which identified
problems have been corrected.  If there are no problems, then
this is the same as input array ‘zcorn’.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is used to implement option <code class="xref mat mat-func docutils literal notranslate"><span class="pre">RepairZCORN</span></code> of the
corner-point processor, <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <a class="reference internal" href="#core.utils.mrstVerbose" title="core.utils.mrstVerbose"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstVerbose</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.computeGeometry">
<span class="sig-name descname"><span class="pre">computeGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.computeGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Add geometry information (centroids, volumes, areas) to a grid</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure as described by grid_structure.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>‘verbose’</strong> – Whether or not to display informational messages
during the computational process.
Logical.  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Verbose</span> <span class="pre">=</span> <span class="pre">mrstVerbose</span></code></p></li>
<li><p><strong>‘hingenodes’</strong> – Structure with fields ‘faces’ and ‘nodes’.  A hinge
node is an extra center node for a face, that is used
to triangulate the face geometry.  For each face
number F in ‘faces’ there is a row in ‘nodes’ which
holds the node coordinate for the hinge node belonging
to face F.</p>
<p>Default value: hingenodes = [] (no additional center
nodes).</p>
</li>
<li><p><strong>‘MaxBlockSize’</strong> – Maximum number of grid cells to process in a single
pass.  Increasing this number may reduce overall
computational time, but will increase total memory
use. If empty (i.e., if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(MaxBlockSize)</span></code> is
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">true</span></code>) or negative, process all grid cells in a
single pass.</p>
<p>Numeric scalar.  Default value: MaxBlockSize = 20e3.</p>
</li>
<li><p><strong>‘CpGeometry’</strong> – Whether or not to additionally derive fundamental
geometric information (cell/face centres and physical
extent of individual cells) exclusively from the
cells’ initial corner vertices.  Only supported for 3D
grids in three space dimensions and if the input grid
additionally provides an explicit mapping from cells
to corner vertices (structure field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.cpnodes</span></code>).</p>
<p>Logical.  Default value: CpGeometry = FALSE (do not
additionally calculate corner-point geometric
primitives).</p>
</li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>G</strong> –</p>
<p>Grid structure with added fields:</p>
<blockquote>
<div><ul>
<li><p>cells</p>
<blockquote>
<div><ul class="simple">
<li><p>volumes :  A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">1</span></code> array of cell volumes.</p></li>
<li><p>centroids: A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">size(G.nodes.coords,</span> <span class="pre">2)</span></code>
array of (approximate) cell centroids.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>faces</p>
<blockquote>
<div><ul class="simple">
<li><p>areas:     A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">1</span></code> array of face areas.</p></li>
<li><p>normals:   A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.griddim</span></code> array of normals.</p></li>
<li><p>centroids: A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">size(G.nodes.coords,</span> <span class="pre">2)</span></code>
array of (approximate) face centroids.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>Moreover, if the caller requests <code class="xref mat mat-func docutils literal notranslate"><span class="pre">CpGeometry</span></code> and the input grid
supports calculating that information then the output grid will in
addition also have the following corner-point geometry fields:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>cells.cpgeometry</dt><dd><ul>
<li><p>centroids: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">size(G.nodes.coords,2)</span></code> array
of approximate cell centre coordinates.</p></li>
<li><p>extent: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.griddim</span></code> array of approximate
cell extents.  Derived from Euclidian distances between
face centre points on opposing sides.</p></li>
<li><p>facecentroids: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">size(G.cells.faces,1)</span></code> by
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">size(G.nodes.coords,2)</span></code> array of approximate face centre
coordinates, relative to the cells.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Individual face normals have length (i.e., Euclidian norm) equal to
the corresponding face areas.  In other words, subject to numerical
round-off, the identity</p>
<blockquote>
<div><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">norm(G.faces.normals(i,:),</span> <span class="pre">2)</span> <span class="pre">==</span> <span class="pre">G.faces.areas(i)</span></code></p>
</div></blockquote>
<p>holds for all faces <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i=1:G.faces.num</span></code>.</p>
<p>In three space dimensions, i.e., when <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.griddim</span> <span class="pre">==</span> <span class="pre">3</span></code>,
function ‘computeGeometry’ assumes that the nodes on a given face, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">f</span></code>,
are ordered such that the face normal on <code class="xref mat mat-func docutils literal notranslate"><span class="pre">f</span></code> is directed from cell
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.neighbors(f,1)</span></code> to cell <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.neighbors(f,2)</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.extended_grid_structure">
<span class="sig-name descname"><span class="pre">extended_grid_structure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.extended_grid_structure" title="Permalink to this definition"></a></dt>
<dd><p>Extended grid structure</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Description</span> <span class="n">of</span> <span class="n">the</span> <span class="nb">grid</span> <span class="n">structure</span> <span class="n">with</span> <span class="n">augmented</span> <span class="n">mappings</span> <span class="nb">and</span>
<span class="n">structures</span><span class="p">.</span> <span class="n">In</span> <span class="n">particular</span><span class="p">,</span> <span class="n">topological</span> <span class="n">description</span> <span class="nb">and</span> <span class="n">geometrical</span>
<span class="k">properties</span> <span class="n">of</span> <span class="n">the</span> <span class="n">edges</span> <span class="n">are</span> <span class="n">included</span><span class="p">.</span>  <span class="n">Such</span> <span class="n">information</span> <span class="n">is</span> <span class="n">used</span> <span class="n">in</span> <span class="n">the</span> <span class="n">VEM</span>
<span class="n">assembly</span><span class="p">.</span> <span class="n">Here</span><span class="p">,</span> <span class="n">we</span> <span class="n">describe</span> <span class="n">the</span> <span class="nb">full</span> <span class="n">structure</span><span class="p">.</span> <span class="n">The</span> <span class="n">structure</span> <span class="n">that</span> <span class="n">are</span> <span class="n">added</span>
<span class="n">with</span> <span class="n">respect</span> <span class="n">to</span> <span class="n">grid_structure</span> <span class="n">are</span> <span class="n">marked</span> <span class="n">as</span> <span class="s">&quot;(added structure)&quot;</span> <span class="nb">or</span> <span class="s">&quot;(added</span>
<span class="s">mapping)&quot;</span><span class="p">.</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul>
<li><p><strong>G</strong> – representation of grids on an unstructured format.  A master</p></li>
<li><p><strong>structure having the following fields</strong> –</p>
<ul class="simple">
<li><dl class="simple">
<dt>cells –</dt><dd><p>A structure specifying properties for each individual cell in the
grid.  See CELLS below for details.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>faces –</dt><dd><p>A structure specifying properties for each individual face in the
grid.  See FACES below for details.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>edges – (added structure)</dt><dd><p>A structure specifying properties for each individual edge
in the grid.  See EDGES below for details.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>nodes –</dt><dd><p>A structure specifying properties for each individual node
(vertex) in the grid.  See NODES below for details.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>type –</dt><dd><p>A cell array of strings describing the history of grid constructor
and modifier functions through which a particular grid structure
has been defined.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>griddim –</dt><dd><p>The dimension of the grid which in most cases will equal
size(G.nodes.coords,2).</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><strong>CELLS</strong> – Cell structure G.cells:
- num –</p>
<blockquote>
<div><p>Number of cells in the global grid.</p>
</div></blockquote>
<ul>
<li><dl>
<dt>facePos –</dt><dd><p>Indirection map of size [num+1,1] into the ‘cells.faces’ array.
Specifically, the face information of cell ‘i’ is found in the
submatrix</p>
<blockquote>
<div><p>G.cells.faces(facePos(i) : facePos(i+1)-1, :)</p>
</div></blockquote>
<p>The number of faces of each cell may be computed using the
statement DIFF(facePos).</p>
</dd>
</dl>
</li>
<li><dl>
<dt>faces –</dt><dd><p>A (G.cells.facePos(end)-1)-by-2 array of global faces connected to
a given cell.  Specifically, if ‘cells.faces(i,1)==j’, then global
face ‘cells.faces(i,2)’ is connected to global cell <a href="#id3"><span class="problematic" id="id4">`</span></a>j’.</p>
<p>To conserve memory, only the second column is actually stored in
the grid structure.  The first column may be re-constructed using
the statement</p>
<blockquote>
<div><dl class="simple">
<dt>rldecode(1<span class="classifier">G.cells.num, …</span></dt><dd><p>diff(G.cells.facePos), 2) .’</p>
</dd>
</dl>
</div></blockquote>
<p>A grid constructor may, optionally, append a third column to this
array.  In this case ‘cells.faces(i,3)’ often contains a tag by
which the cardinal direction of face ‘cells.faces(i,2)’ within
cell ‘cells.faces(i,1)’ may be distinguished.  Some ancillary
utilities within the toolbox depend on this specific semantics of
‘cells.faces(i,3)’, e.g., to easily specify boundary conditions
(functions ‘pside’ and ‘fluxside’).</p>
</dd>
</dl>
</li>
<li><dl>
<dt>nodePos – (added mapping)</dt><dd><p>Indirection map of size [num+1,1] into the ‘cells.nodes’ array.
Specifically, the face information of cell ‘i’ is found in the
submatrix</p>
<blockquote>
<div><p>G.cells.nodes(nodePos(i) : nodePos(i+1)-1, :)</p>
</div></blockquote>
<p>The number of nodes of each cell may be computed using the
statement DIFF(nodePos).</p>
</dd>
</dl>
</li>
<li><dl>
<dt>nodes – (added mapping)</dt><dd><p>A (G.cells.nodePos(end)-1)-by-2 array of global nodes belonging to
a given cell.  Specifically, if ‘cells.nodes(i,1)==j’, then global
node ‘cells.nodes(i,2)’ is connected to global cell <a href="#id5"><span class="problematic" id="id6">`</span></a>j’.</p>
<p>To conserve memory, only the second column is actually stored in
the grid structure.  The first column may be re-constructed using
the statement</p>
<blockquote>
<div><dl class="simple">
<dt>rldecode(1<span class="classifier">G.cells.num, …</span></dt><dd><p>diff(G.cells.nodePos), 2) .’</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl>
<dt>indexMap –</dt><dd><p>Maps internal to external grid cells (i.e., active cell numbers to
global cell numbers).  In the case of Cartesian grids, indexMap ==
(1 : G.cells.num)’ .</p>
<p>For grids with a logically Cartesian topology of dimension ‘dims’
(a curvilinear grid, a corner-point grid, etc), a map of cell
numbers to logical indices may be constructed using the following
statement in 2D</p>
<blockquote>
<div><p>[ij{1:2}] = ind2sub(dims, G.cells.indexMap(:));
ij        = [ij{:}];</p>
</div></blockquote>
<p>and likewise in 3D</p>
<blockquote>
<div><p>[ijk{1:3}] = ind2sub(dims, G.cells.indexMap(:));
ijk        = [ijk{:}];</p>
</div></blockquote>
<p>In the latter case, ijk(i,:) is global (I,J,K) index of cell ‘i’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>volumes –</dt><dd><p>A G.cells.num-by-1 array of cell volumes.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>centroids –</dt><dd><p>A G.cells.num-by-d array of cell centroids in R^d.</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><strong>FACES</strong> – Face structure G.faces:
- num –</p>
<blockquote>
<div><p>Number of global faces in grid.</p>
</div></blockquote>
<ul>
<li><dl>
<dt>edgePos – (added mapping)</dt><dd><p>Indirection map of size [num+1,1] into the ‘face.edges’ array.
Specifically, the edge information of face ‘i’ is found in the
submatrix</p>
<blockquote>
<div><p>G.faces.edges(edgePos(i) : edgePos(i+1)-1, :)</p>
</div></blockquote>
<p>The number of edges of each face may be computed using the
statement DIFF(edgePos).</p>
</dd>
</dl>
</li>
<li><dl>
<dt>edges – (added mapping)</dt><dd><p>A (G.faces.edgePos(end)-1)-by-2 array of vertices in the grid.
Specifically, if ‘faces.edges(i,1)==j’, then global edge
‘faces.edges(i,2)’ is part of the global face number <a href="#id7"><span class="problematic" id="id8">`</span></a>j’. To conserve
memory, only the last column is stored.  The first column can be
constructed using the statement</p>
<blockquote>
<div><p>rldecode(1:G.faces.num, diff(G.faces.edgePos), 2) .’</p>
</div></blockquote>
<p>Normally, for a given face, the edges are ordered counter-clockwise
as we go through the boundary of the face, see the function sortEdges.m</p>
</dd>
</dl>
</li>
<li><dl>
<dt>edgeSign – (added mapping)</dt><dd><p>For a given face, the edges should be oriented counter-clockwise. It
means that the orientation of an edge cannot be an intrinsic property
of an edge, as two faces that share a common edge can impose two
different orientations for this edge. Hence, we have to keep track of
the orientation of the edges on a face-wise basis.</p>
<p>A (G.faces.edgePos(end)-1, 1) array of sign for the edges of a given
cell.  Specifically, if ‘faces.edges(i,1)==j’, then the global edge
‘faces.edges(i,2)’ should be oriented correspondingly to the sign
‘faces.edgeSign(i)’ when the edge is considered from the point of view
of the face <a href="#id9"><span class="problematic" id="id10">`</span></a>j’.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>nodePos –</dt><dd><p>Indirection map of size [num+1,1] into the ‘face.nodes’ array.
Specifically, the node information of face ‘i’ is found in the
submatrix</p>
<blockquote>
<div><p>G.faces.nodes(nodePos(i) : nodePos(i+1)-1, :)</p>
</div></blockquote>
<p>The number of nodes of each face may be computed using the
statement DIFF(nodePos).</p>
</dd>
</dl>
</li>
<li><dl>
<dt>nodes –</dt><dd><p>A (G.faces.nodePos(end)-1)-by-2 array of vertices in the grid connected
to a given face.  Specifically, if ‘faces.nodes(i,1)==j’, then global
vertex ‘faces.nodes(i,2)’ is part of the global face number <a href="#id11"><span class="problematic" id="id12">`</span></a>j’. To
conserve memory, only the last column is stored.  The first column can
be constructed using the statement</p>
<blockquote>
<div><p>rldecode(1:G.faces.num, diff(G.faces.nodePos), 2) .’</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>neighbors –</dt><dd><p>A G.faces.num-by-2 array of neighboring information. Global face
number <a href="#id13"><span class="problematic" id="id14">`</span></a>i’ is shared by global cells ‘neighbors(i,1)’ and
‘neighbors(i,2)’. One of ‘neighbors(i,1)’ or ‘neighbors(i,2)’, but
not both, may be zero, meaning that face <a href="#id15"><span class="problematic" id="id16">`</span></a>i’ is an external face
shared only by a single cell (the nonzero one).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>tag –</dt><dd><p>A G.faces.num-by-1 array of face tags.  A tag is a scalar.  The
exact semantics of this field is currently undecided and subject
to change in future releases of MRST.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>areas –</dt><dd><p>A G.faces.num-by-1 array of face areas.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>normals –</dt><dd><p>A G.faces.num-by-d array of <em>AREA WEIGHTED</em>, directed face normals
in R^d.  The normal on face <a href="#id17"><span class="problematic" id="id18">`</span></a>i’ points from cell
‘G.faces.neighbors(i,1)’ to cell ‘G.faces.neighbors(i,2)’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>centroids –</dt><dd><p>A G.faces.num-by-d array of face centroids in R^d.</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><strong>EDGES</strong> (<em>added structure</em>) – Edge structure G.edges:
- num –</p>
<blockquote>
<div><p>Number of global edges in grid.</p>
</div></blockquote>
<ul>
<li><dl>
<dt>nodePos – (added mapping)</dt><dd><p>Indirection map of size [num+1,1] into the ‘edges.nodes’ array.
Specifically, the node information of edge ‘i’ is found in the
submatrix</p>
<blockquote>
<div><p>G.edges.nodes(nodePos(i) : nodePos(i+1)-1, :)</p>
</div></blockquote>
<p>The number of nodes of each edge may be computed using the
statement DIFF(nodePos).</p>
</dd>
</dl>
</li>
<li><dl>
<dt>nodes – (added mapping)</dt><dd><p>A (G.edges.nodePos(end)-1)-by-2 array of vertices in the grid.
Specifically, if ‘edges.nodes(i,1)==j’, then the global node
‘edges.nodes(i,2)’ is part of the global edge number <a href="#id19"><span class="problematic" id="id20">`</span></a>j’. To conserve
memory, only the last column is stored.  The first column can be
constructed using the statement</p>
<blockquote>
<div><p>rldecode(1:G.edges.num, diff(G.edges.nodePos), 2) .’</p>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><strong>NODES</strong> – Node (vertex) structure G.nodes:
- num –</p>
<blockquote>
<div><p>Number of global nodes (vertices) in grid.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>coords –</dt><dd><p>A G.nodes.num-by-d array of physical nodal coordinates in R^d.
Global node <a href="#id21"><span class="problematic" id="id22">`</span></a>i’ is at physical coordinate [coords(i,:)]</p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>REMARKS:</dt><dd><p>The grid is constructed according to a right-handed coordinate system
where the Z coordinate is interpreted as depth.  Consequently, plotting
routines such as plotGrid display the grid with a reversed Z axis.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>In case the description scrolled off screen too quickly, you may access
the information at your own pace using the command</p>
<blockquote>
<div><p>more on, help grid_structure, more off</p>
</div></blockquote>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.extractSubgrid">
<span class="sig-name descname"><span class="pre">extractSubgrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">c</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.extractSubgrid" title="Permalink to this definition"></a></dt>
<dd><p>Construct valid grid definition from subset of existing grid cells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">subG</span>              <span class="p">=</span> <span class="n">extractSubgrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>

<span class="p">[</span><span class="n">subG</span><span class="p">,</span> <span class="n">gc</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">gn</span><span class="p">]</span> <span class="p">=</span> <span class="n">extractSubgrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Valid grid definition.</p></li>
<li><p><strong>cells</strong> – Subset of existing grid cells for which the subgrid data
structure should be constructed.  Must be an array of numeric
cell indices or a logical mask into the range 1:G.cells.num.
Moreover, the cell indices must be unique within the subset.
Repeated indices are not supported.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul>
<li><p><strong>subG</strong> – Resulting subgrid.  The cells of ‘subG’ are ordered according
to increasing numeric index in ‘cells’.</p></li>
<li><p><strong>gc, gf, gn</strong> –</p>
<ul>
<li><p>Global cells, faces, and nodes referenced by sub-grid ‘subG’.
Specifically:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">gc</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="o">==</span> <span class="k">global</span> <span class="n">cell</span> <span class="n">index</span> <span class="p">(</span><span class="n">from</span> <span class="s">&#39;G&#39;</span><span class="p">)</span> <span class="n">of</span> <span class="n">subG</span> <span class="n">cell</span> <span class="s">&#39;i&#39;</span><span class="p">.</span>
<span class="n">gf</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="o">==</span> <span class="k">global</span> <span class="n">face</span> <span class="n">index</span> <span class="p">(</span><span class="n">from</span> <span class="s">&#39;G&#39;</span><span class="p">)</span> <span class="n">of</span> <span class="n">subG</span> <span class="n">face</span> <span class="s">&#39;i&#39;</span><span class="p">.</span>
<span class="n">gn</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="o">==</span> <span class="k">global</span> <span class="n">node</span> <span class="n">index</span> <span class="p">(</span><span class="n">from</span> <span class="s">&#39;G&#39;</span><span class="p">)</span> <span class="n">of</span> <span class="n">subG</span> <span class="n">node</span> <span class="s">&#39;i&#39;</span><span class="p">.</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The return value <code class="xref mat mat-func docutils literal notranslate"><span class="pre">gcells</span></code> is equal to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">unique(cells(:))</span></code>.  Repeated
values in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span></code> are silently ignored.</p>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span>    <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]);</span>     <span class="p">[</span><span class="no">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">K</span><span class="p">]</span> <span class="p">=</span> <span class="nb">ndgrid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">);</span>
<span class="n">subG</span> <span class="p">=</span> <span class="n">extractSubgrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">sub2ind</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">,</span> <span class="no">I</span><span class="p">(:),</span> <span class="n">J</span><span class="p">(:),</span> <span class="n">K</span><span class="p">(:)));</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">subG</span><span class="p">,</span> <span class="s">&#39;EdgeAlpha&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="nb">view</span><span class="p">(</span><span class="o">-</span><span class="mi">35</span><span class="p">,</span><span class="mi">20</span><span class="p">),</span> <span class="n">camlight</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.findMatchingFaces">
<span class="sig-name descname"><span class="pre">findMatchingFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.findMatchingFaces" title="Permalink to this definition"></a></dt>
<dd><p>Find indices of faces sharing the same set of nodes in a grid</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="p">=</span> <span class="n">findMatchingFaces</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure as described by grid_structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>N</strong> – An n x 2 array of face numbers. Each row represents a pair of
faces in G that share the same set of nodes.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.makeInternalBoundary" title="core.gridprocessing.makeInternalBoundary"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeInternalBoundary</span></code></a>, <a class="reference internal" href="#core.gridprocessing.removeInternalBoundary" title="core.gridprocessing.removeInternalBoundary"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">removeInternalBoundary</span></code></a></p>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Make internal boundary, find matching faces, remove boundary again</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">makeInternalBoundary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
<span class="n">N</span> <span class="p">=</span> <span class="n">findMatchingFaces</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">removeInternalBoundary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.get2DGridFromFaces">
<span class="sig-name descname"><span class="pre">get2DGridFromFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.get2DGridFromFaces" title="Permalink to this definition"></a></dt>
<dd><p>Make a surface grid from a subset of grid faces. Since we may have
crossing faces (&gt;2 faces for an edge), add a sign indicator for
g.cells.faces. Keep same node-orientation of (2D grid) cells as the
original (3D grid) faces</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.glue2DGrid">
<span class="sig-name descname"><span class="pre">glue2DGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G1</span></em>, <em class="sig-param"><span class="pre">G2</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.glue2DGrid" title="Permalink to this definition"></a></dt>
<dd><p>Connect two 2D grids along common edges</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">glue2DGrid</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">G2</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">glue2DGrid</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">G2</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G1</strong> – First grid to be combined.</p></li>
<li><p><strong>G2</strong> – Second grid to be combined.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>tol</strong> – Define geometric tolerance (Euclidian distance, metres) to
determine coincidence between nodes, and between nodes and edges,
between the two grids.  Default is 1e-3.</p>
</dd>
</dl>
<dl>
<dt>LIMITATIONS:</dt><dd><p>Grids must follow definition from ‘grid_structure’.  Both input grids
must be strictly two-dimensional both in terms of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">griddim</span></code> and in
terms of size(nodes.coords, 2).</p>
<p>If the two grids do not share any common edges, the resulting combined
grid will represent a topologically disconnected grid.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>G</strong> – Resultant combined grid from <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G1</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G2</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The result grid (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code>) does not provide derived geometric primitives
(e.g., cell volumes).  Such information must be explicitly computed
through a subsequent call to function <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.grdeclXYZ">
<span class="sig-name descname"><span class="pre">grdeclXYZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.grdeclXYZ" title="Permalink to this definition"></a></dt>
<dd><p>Get corner-point pillars and coordinates in alternate format</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">xyz</span><span class="p">,</span> <span class="n">zcorn</span><span class="p">]</span> <span class="p">=</span> <span class="n">grdeclXYZ</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – Grid in Eclipse format</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘lefthanded_numbering’</strong> – If set to true, the numbering of cells in the
y-direction starts with the largest values.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x,y,z</strong> – The pillar coordinates such that xyz(1:3,i,j) and xyz(4:6,i,j)
corresponds to the top and bottom coordinates of the pilar i,j,
respectively.</p></li>
<li><p><strong>zcorn</strong> – Vertical cordinates (z-value) for each corner for each cell, ordered in
increasing Cartesian coordinates (x -&gt; y -&gt; z).</p></li>
</ul>
</dd>
</dl>
<p>SEE ALSO:</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.grid_structure">
<span class="sig-name descname"><span class="pre">grid_structure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.grid_structure" title="Permalink to this definition"></a></dt>
<dd><p>Grid structure used in the MATLAB Reservoir Simulation Toolbox.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">)</span> <span class="n">Construct</span> <span class="n">Cartesian</span> <span class="nb">grid</span><span class="p">.</span>
     <span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">(...);</span>
     <span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>

<span class="mi">2</span><span class="p">)</span> <span class="n">Read</span> <span class="n">corner</span> <span class="n">point</span> <span class="nb">grid</span> <span class="n">specification</span> <span class="n">from</span> <span class="n">file</span><span class="p">.</span>
     <span class="n">grdecl</span> <span class="p">=</span> <span class="n">readGRDECL</span><span class="p">(...);</span>
     <span class="n">G</span>      <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">);</span>
     <span class="n">G</span>      <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>G</strong> – representation of grids on an unstructured format.</p>
</dd>
</dl>
<p class="rubric">Description:</p>
<p>All grids in MRST are represented in a common unstructured format,
regardless of their origin. The grid structure has the following
fields:</p>
<ul class="simple">
<li><p>cells: A structure specifying properties for each individual cell
in the grid. See <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells</span></code> below for details.</p></li>
<li><p>faces: A structure specifying properties for each individual
face in the grid. See <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces</span></code> below for details.</p></li>
<li><p>nodes: A structure specifying properties for each individual node
(vertex) in the grid.  See <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nodes</span></code> below for details.</p></li>
<li><p>type: A cell array of strings describing the history of grid
constructor and modifier functions through which a particular grid
structure has been defined.</p></li>
<li><p>griddim: The dimension of the grid which in most cases will equal
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">size(G.nodes.coords,2)</span></code>.</p></li>
</ul>
<p>CELLS - Sub-struct G.cells contains description of each cell:</p>
<ul>
<li><p>num: Number of cells in the global grid.</p></li>
<li><p>facePos: Indirection map of size [num+1,1] into the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells.faces</span></code>
array. Specifically, the face information of cell <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> is found in
the submatrix:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">faces</span><span class="p">(</span><span class="n">facePos</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">facePos</span><span class="p">(</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:)</span>
</pre></div>
</div>
<p>The number of faces of each cell may be computed using the
statement <code class="xref mat mat-func docutils literal notranslate"><span class="pre">diff(facePos)</span></code>.</p>
</li>
<li><p>faces: A (G.cells.facePos(end)-1)-by-1 array of global faces
connected to a given cell. A common construction derived from this
structure is the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cellNo</span></code> mapping from global face to cells,:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">cellNo</span> <span class="p">=</span> <span class="n">rldecode</span><span class="p">(</span><span class="mi">1</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="n">diff</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">facePos</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="p">.</span><span class="o">&#39;</span>
</pre></div>
</div>
<p>Specifically, if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cellNo(i)</span> <span class="pre">==</span> <span class="pre">j</span></code>, then global face
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells.faces(i,1)</span></code> is connected to global cell <code class="xref mat mat-func docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>A grid constructor may, optionally, append a second column to this
array.  In this case <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells.faces(i,2)</span></code> often contains a tag by
which the cardinal direction of face <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells.faces(i,1)</span></code> within cell
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">cellNo(i)</span></code> may be distinguished.  Some ancillary utilities within
the toolbox depend on this specific semantics of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cells.faces(i,2)</span></code>,
e.g., to easily specify boundary conditions (functions <a class="reference internal" href="#core.params.wells_and_bc.pside" title="core.params.wells_and_bc.pside"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pside</span></code></a> and
<a class="reference internal" href="#core.params.wells_and_bc.fluxside" title="core.params.wells_and_bc.fluxside"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fluxside</span></code></a>).</p>
</li>
<li><p>indexMap: Maps internal to external grid cells (i.e., active cell
numbers to global cell numbers).  In the case of Cartesian grids,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">indexMap</span> <span class="pre">==</span> <span class="pre">(1</span> <span class="pre">:</span> <span class="pre">G.cells.num)'</span></code>.</p>
<p>For grids with a logically Cartesian topology of dimension <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dims</span></code> (a
curvilinear grid, a corner-point grid, etc), a map of cell numbers
to logical indices may be constructed using the following statement
in 2D:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">ij</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">}]</span> <span class="p">=</span> <span class="nb">ind2sub</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">indexMap</span><span class="p">(:));</span>
<span class="n">ij</span>        <span class="p">=</span> <span class="p">[</span><span class="n">ij</span><span class="p">{:}];</span>
</pre></div>
</div>
<p>and likewise in 3D:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">ijk</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">}]</span> <span class="p">=</span> <span class="nb">ind2sub</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">indexMap</span><span class="p">(:));</span>
<span class="n">ijk</span>        <span class="p">=</span> <span class="p">[</span><span class="n">ijk</span><span class="p">{:}];</span>
</pre></div>
</div>
<p>In the latter case, ijk(i,:) is global (I,J,K) index of cell <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code>.
The utility function <a class="reference internal" href="#core.utils.gridtools.gridLogicalIndices" title="core.utils.gridtools.gridLogicalIndices"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">gridLogicalIndices</span></code></a> implements these features.</p>
</li>
<li><p>volumes: A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">1</span></code> array of cell volumes.</p></li>
<li><p>centroids: A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">d</span></code> array of cell centroids in R^d.</p></li>
</ul>
<p>FACES - Face structure G.faces contains:</p>
<ul>
<li><p>num: Number of global faces in grid.</p></li>
<li><p>nodePos: Indirection map of size [num+1,1] into the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces.nodes</span></code>
array. Specifically, the node information of face <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> is found in
the submatrix:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="p">.</span><span class="n">faces</span><span class="p">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">nodePos</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">nodePos</span><span class="p">(</span><span class="nb">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:)</span>
</pre></div>
</div>
<p>The number of nodes of each face may be computed using the statement
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">diff(nodePos)</span></code>.</p>
</li>
<li><p>nodes: A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">(G.faces.nodePos(end)-1)</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">1</span></code> array of vertices in the
grid connected to a given face. The most common derived quantity is
the faceNo array constructed as:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">faceNo</span> <span class="p">=</span> <span class="n">rldecode</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">G</span><span class="p">.</span><span class="n">faces</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="n">diff</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">faces</span><span class="p">.</span><span class="n">nodePos</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="p">.</span><span class="o">&#39;</span>
</pre></div>
</div>
<p>If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faceNo(i)==j</span></code>, then global vertex <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces.nodes(i,1)</span></code> is part of
the global face number <code class="xref mat mat-func docutils literal notranslate"><span class="pre">j</span></code>.</p>
</li>
<li><p>neighbors: A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">2</span></code> array of neighboring information.
Global face number <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> is shared by global cells <code class="xref mat mat-func docutils literal notranslate"><span class="pre">neighbors(i,1)</span></code>
and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">neighbors(i,2)</span></code>. One of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">neighbors(i,1)</span></code> or <code class="xref mat mat-func docutils literal notranslate"><span class="pre">neighbors(i,2)</span></code>,
but not both, may be zero, meaning that face <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> is an external face
shared only by a single cell (the nonzero one).</p></li>
<li><p>tag: A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">1</span></code> array of face tags.  The exact semantics
of this field is currently undecided and subject to change in future
releases of MRST.</p></li>
<li><p>areas: A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">1</span></code> array of face areas.</p></li>
<li><p>normals: A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">d</span></code> array of <em>AREA WEIGHTED</em>, directed
face normals in R^d.  The normal on face <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> points from cell
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.neighbors(i,1)</span></code> to cell <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.neighbors(i,2)</span></code>.</p></li>
<li><p>centroids: A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">d</span></code> array of face centroids in R^d.</p></li>
</ul>
<p>NODES - Node (vertex) structure G.nodes:</p>
<ul class="simple">
<li><p>num: Number of global nodes (vertices) in grid.</p></li>
<li><p>coords:  A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.nodes.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">d</span></code> array of physical nodal coordinates
in R^d. Global node <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> is at physical coordinate <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[coords(i,:)]</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The grid is constructed according to a right-handed coordinate system
where the Z coordinate is interpreted as depth.  Consequently, plotting
routines such as plotGrid display the grid with a reversed Z axis.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>In case the description scrolled off screen too quickly, you may access
the information at your own pace using the command:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">more</span> <span class="n">on</span><span class="p">,</span> <span class="n">help</span> <span class="n">grid_structure</span><span class="p">,</span> <span class="n">more</span> <span class="n">off</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.hexahedralGrid">
<span class="sig-name descname"><span class="pre">hexahedralGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">P</span></em>, <em class="sig-param"><span class="pre">H</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.hexahedralGrid" title="Permalink to this definition"></a></dt>
<dd><p>Construct valid grid definition from points and list of hexahedra</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">hexahedralGrid</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>P</strong> – Node coordinates.  Must be an m-by-3 matrix, one row for each
node/point.</p></li>
<li><p><strong>T</strong> – <p>List of hexahedral corner nodes: an n-by-8 matrix where each
row holds node numbers for a hexahedron, with the following
sequence of nodes:</p>
<blockquote>
<div><p>(imax, jmin, kmin)
(imax, jmax, kmin)
(imax, jmax, kmax)
(imax, jmin, kmax)
(imin, jmin, kmin)
(imin, jmax, kmin)
(imin, jmax, kmax)
(imin, jmin, kmax)</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Valid grid definition.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span>  <span class="n">H</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>  <span class="mi">7</span>  <span class="mi">8</span><span class="p">;</span> <span class="p">...</span>
       <span class="mi">2</span>  <span class="mi">9</span> <span class="mi">10</span>  <span class="mi">3</span>  <span class="mi">6</span> <span class="mi">11</span> <span class="mi">12</span>  <span class="mi">7</span><span class="p">;</span> <span class="p">...</span>
       <span class="mi">9</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">12</span><span class="p">;</span> <span class="p">...</span>
      <span class="mi">13</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">19</span> <span class="mi">20</span> <span class="mi">16</span><span class="p">;</span> <span class="p">...</span>
      <span class="mi">17</span> <span class="mi">21</span> <span class="mi">22</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">23</span> <span class="mi">24</span> <span class="mi">20</span><span class="p">];</span>

  <span class="n">P</span> <span class="p">=</span> <span class="p">[</span><span class="mf">1.2000</span>       <span class="mi">0</span>  <span class="mf">0.1860</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>  <span class="mf">0.0200</span>  <span class="mf">0.1852</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>  <span class="mf">0.0200</span>  <span class="mf">0.1926</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>       <span class="mi">0</span>  <span class="mf">0.1930</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1846</span>       <span class="mi">0</span>  <span class="mf">0.1854</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1844</span>  <span class="mf">0.0200</span>  <span class="mf">0.1846</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1848</span>  <span class="mf">0.0200</span>  <span class="mf">0.1923</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1849</span>       <span class="mi">0</span>  <span class="mf">0.1926</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>  <span class="mf">0.0400</span>  <span class="mf">0.1844</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>  <span class="mf">0.0400</span>  <span class="mf">0.1922</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1843</span>  <span class="mf">0.0400</span>  <span class="mf">0.1837</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1847</span>  <span class="mf">0.0400</span>  <span class="mf">0.1919</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>  <span class="mf">0.0601</span>  <span class="mf">0.1836</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>  <span class="mf">0.0600</span>  <span class="mf">0.1918</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1842</span>  <span class="mf">0.0601</span>  <span class="mf">0.1829</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1846</span>  <span class="mf">0.0600</span>  <span class="mf">0.1915</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>  <span class="mf">0.0801</span>  <span class="mf">0.1828</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>  <span class="mf">0.0800</span>  <span class="mf">0.1914</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1840</span>  <span class="mf">0.0801</span>  <span class="mf">0.1821</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1845</span>  <span class="mf">0.0800</span>  <span class="mf">0.1912</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>  <span class="mf">0.1001</span>  <span class="mf">0.1820</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.2000</span>  <span class="mf">0.1001</span>  <span class="mf">0.1910</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1839</span>  <span class="mf">0.1001</span>  <span class="mf">0.1814</span><span class="p">;</span> <span class="p">...</span>
       <span class="mf">1.1844</span>  <span class="mf">0.1001</span>  <span class="mf">0.1908</span><span class="p">];</span>


<span class="n">G</span> <span class="p">=</span> <span class="n">hexahedralGrid</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">H</span><span class="p">);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">delaunay</span></code>, <a class="reference internal" href="#core.gridprocessing.tetrahedralGrid" title="core.gridprocessing.tetrahedralGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tetrahedralGrid</span></code></a>, <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.makeInternalBoundary">
<span class="sig-name descname"><span class="pre">makeInternalBoundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">faces</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.makeInternalBoundary" title="Permalink to this definition"></a></dt>
<dd><p>Make internal boundary in grid along specified faces.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">H</span>     <span class="p">=</span> <span class="n">makeInternalBoundary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">)</span>
 <span class="n">H</span>     <span class="p">=</span> <span class="n">makeInternalBoundary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="p">[</span><span class="n">H</span><span class="p">,</span> <span class="n">N</span><span class="p">]</span> <span class="p">=</span> <span class="n">makeInternalBoundary</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure as described by grid_structure.</p></li>
<li><p><strong>faces</strong> – Faces along which a boundary will be inserted.  Vector of
face indices.  Repeated indices are supported but generally
discouraged.  One pair of new grid faces will be created in
the output grid for each unique face in ‘faces’ provided the
identified face is not located on the boundary of ‘G’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘tag’</strong> – Tag inserted into ‘G.faces.tag’ (if present) for faces on the
internal boundary.  Integer scalar.
Default value: tag = -1.</p></li>
<li><p><strong>‘check’</strong> – Whether or not to check for repeated face indices in input
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces</span></code>.  Emit diagnostic when set and in presence of repeated
indices.  Logical scalar.
Default value: check = LOGICAL(mrstVerbose).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul>
<li><p><strong>H</strong> – Modified grid structure.</p></li>
<li><p><strong>N</strong> – An n-by-2 array of face indices. Each pair in the array corresponds
to a face in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces</span></code>.  In particular, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces(i)</span></code> in the input grid
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> is replaced by the pair of faces <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[N(i,1),</span> <span class="pre">N(i,2)]</span></code> in the
result grid <code class="xref mat mat-func docutils literal notranslate"><span class="pre">H</span></code>.</p>
<p>If any of the faces in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faces</span></code> are on the boundary, then the
corresponding rows in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">N</span></code> is <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NaN</span></code> in both columns.</p>
<p>The quantity <code class="xref mat mat-func docutils literal notranslate"><span class="pre">N</span></code> is sufficient to create flow over the internal
boundary or to remove the internal boundary at some later point.</p>
</li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.removeInternalBoundary" title="core.gridprocessing.removeInternalBoundary"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">removeInternalBoundary</span></code></a>, <a class="reference internal" href="#core.utils.mrstVerbose" title="core.utils.mrstVerbose"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstVerbose</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.makeLayeredGrid">
<span class="sig-name descname"><span class="pre">makeLayeredGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">layerSpec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.makeLayeredGrid" title="Permalink to this definition"></a></dt>
<dd><p>Extrude 2D Grid to layered 3D grid with specified layering structure</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">makeLayeredGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">layerSpec</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Valid 2D areal grid.</p></li>
<li><p><strong>layerSpec</strong> – Layering structure.  Interpreted as the number of layers in
an extruded grid (uniform thickness of 1 meter) if positive
scalar, otherwise as vector of layer thicknesses if array.
Elements should be positive numbers in the latter case.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Valid 3D grid as described in grid_structure.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Create three layers of uniform thickness (1 meter).</span>
<span class="n">Gu</span> <span class="p">=</span> <span class="n">makeLayeredGrid</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="mi">3</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">Gu</span><span class="p">),</span> <span class="nb">view</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>

<span class="c">% 2) Create five layers of increasing thickness.</span>
<span class="n">Gi</span> <span class="p">=</span> <span class="n">makeLayeredGrid</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">convertFrom</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="n">ft</span><span class="p">));</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">Gi</span><span class="p">),</span> <span class="nb">view</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>

<span class="c">% 3) Add extra layers to a &#39;topSurfaceGrid&#39; from the co2lab module.</span>
<span class="c">%    Probably not too useful in practice.</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">tensorGrid</span><span class="p">(</span><span class="mi">0</span> <span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span> <span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">...</span>
               <span class="s">&#39;depthz&#39;</span><span class="p">,</span> <span class="nb">repmat</span><span class="p">(</span><span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">]));</span>
<span class="p">[</span><span class="n">Gt</span><span class="p">,</span> <span class="n">G</span><span class="p">]</span> <span class="p">=</span> <span class="n">topSurfaceGrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
<span class="n">Gt_extra</span> <span class="p">=</span> <span class="n">Gt</span><span class="p">;</span>
<span class="n">Gt_extra</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span> <span class="p">=</span> <span class="p">[</span> <span class="n">Gt_extra</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">Gt_extra</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">z</span> <span class="p">];</span>
<span class="n">Gt_extra</span><span class="p">.</span><span class="n">nodes</span> <span class="p">=</span> <span class="nb">rmfield</span><span class="p">(</span><span class="n">Gt_extra</span><span class="p">.</span><span class="n">nodes</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">);</span>

<span class="n">thickness</span> <span class="p">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">convertFrom</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="n">ft</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="n">thickness</span><span class="p">(</span><span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span> <span class="p">=</span> <span class="n">thickness</span><span class="p">(</span><span class="mi">10</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">6</span><span class="p">);</span>  <span class="c">% Because &#39;why not?&#39;</span>
<span class="n">Gt_extra</span> <span class="p">=</span> <span class="n">makeLayeredGrid</span><span class="p">(</span><span class="n">Gt_extra</span><span class="p">,</span> <span class="n">thickness</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">Gt_extra</span><span class="p">),</span> <span class="nb">view</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>

<span class="c">% 4) Create a single layer of non-unit thickness.  This requires extra</span>
<span class="c">%    manual steps due to a quirk of the calling interface of function</span>
<span class="c">%    &#39;makeLayeredGrid&#39;.</span>
<span class="n">G1</span> <span class="p">=</span> <span class="n">makeLayeredGrid</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">k</span>  <span class="p">=</span> <span class="n">G1</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(:,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">G1</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1234</span><span class="o">*</span><span class="n">milli</span><span class="o">*</span><span class="n">meter</span><span class="p">;</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G1</span><span class="p">),</span> <span class="nb">view</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The special treatment of a <em>scalar</em> <code class="xref mat mat-func docutils literal notranslate"><span class="pre">layerSpec</span></code> parameter, to preserve
backwards compatibility with the original semantics of this function,
means that it is not possible to specify a single layer of non-unit
thickness.  If you need a single layer of non-unit thickness then you
need to manually update the third column of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.nodes.coords</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.markCutGrids">
<span class="sig-name descname"><span class="pre">markCutGrids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">faceStatus</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.markCutGrids" title="Permalink to this definition"></a></dt>
<dd><p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>m<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">markCutGrids</span><span class="p">(</span>G, faceStatus<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>DESCRIPTION:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid</p></li>
<li><p><strong>faceStatus</strong> – Face status vector from sliceGrid. If calling
sliceGrid as [G, gix] = sliceGrid(…), then
faceStatus = gix.new.faces.</p></li>
<li><p><strong>facesAlongPlane</strong> – Optional number indicating faceStatus value of
the internal boundary. Default is 3, since this
is the default value in sliceGrid.m.</p></li>
<li><p><strong>legacy</strong> – Optional force of older code without graph.</p></li>
<li><p><strong>start</strong> – Legacy code requires starting position</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>m</strong> – Vector with marked cells</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">[</span><span class="n">G2</span><span class="p">,</span> <span class="n">gix</span><span class="p">]</span> <span class="p">=</span> <span class="n">sliceGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;normal&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">m</span> <span class="p">=</span> <span class="n">markCutGrids</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="n">gix</span><span class="p">.</span><span class="n">new</span><span class="p">.</span><span class="n">faces</span><span class="p">);</span>
<span class="n">plotCellData</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>SEE ALSO: sliceGrid.m</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.pebi">
<span class="sig-name descname"><span class="pre">pebi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.pebi" title="Permalink to this definition"></a></dt>
<dd><p>Compute dual grid of triangular grid G.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="p">=</span> <span class="n">pebi</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Triangular grid structure as described by grid_structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>H</strong> – Dual of a triangular grid with edges that are perpendicular
bisectors of the edges in the triangular grid.  This grid is
also  known as a Voronoi diagram.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If triangulation is not Delaunay, some circumcenters may fall outside
its assiciated triangle.  This may generate warped grids or grids that
do not preserve the original outer boundary of the triangulation.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.triangleGrid" title="core.gridprocessing.triangleGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">triangleGrid</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.processFaults">
<span class="sig-name descname"><span class="pre">processFaults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">geomspec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.processFaults" title="Permalink to this definition"></a></dt>
<dd><p>Construct fault structure from input specification (keyword <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FAULTS</span></code>)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">faults</span><span class="p">,</span> <span class="n">id</span><span class="p">]</span> <span class="p">=</span> <span class="n">processFaults</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Valid grid data structure.  Must contain the second (third)
column of G.cells.faces, the values of which must identify the
cardinal direction of each face within each cell.</p></li>
<li><p><strong>geom</strong> – <p>Geometry specification.  Typically corresponds to the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">GRID</span></code>
section data structure defined by function <a class="reference internal" href="deckformat.html#deckformat.deckinput.readEclipseDeck" title="deckformat.deckinput.readEclipseDeck"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readEclipseDeck</span></code></a>
(i.e., <code class="xref mat mat-func docutils literal notranslate"><span class="pre">deck.GRID</span></code>).</p>
<p>If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">geom</span></code> contains the fault-related keywords <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FAULTS</span></code> and,
optionally, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MULTFLT</span></code> (matched case insensitively), then fault
structures will be generate for each named fault.  Otherwise,
empty return values will be produced by function
<a class="reference internal" href="#core.gridprocessing.processFaults" title="core.gridprocessing.processFaults"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processFaults</span></code></a>.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul>
<li><p><strong>faults</strong> – An n-by-1 structure array, one element for each of the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code>
unique faults in the geometry specification.  Each array
element has the following fields:</p>
<blockquote>
<div><p>name  - Fault name.  Copied from <code class="xref mat mat-func docutils literal notranslate"><span class="pre">geom</span></code>.</p>
<p>faces - Global grid faces (from the grid <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code>) connected to
the given, named fault.</p>
<p>numf  - Number of global faces connected to given, named
fault (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">==</span> <span class="pre">NUMEL(faces)</span></code>).</p>
<p>mult  - Fault transmissibility multiplier.
Numeric value 1 (one) unless redefined in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MULT</span></code>.</p>
</div></blockquote>
</li>
<li><p><strong>id</strong> – Fault enumeration mapping.  Function handle supporting the
following syntax:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="nb">i</span> <span class="p">=</span> <span class="n">id</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="xref mat mat-func docutils literal notranslate"><span class="pre">name</span></code> is one of the unique fault names defined in the
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">FAULTS</span></code> field of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">geom</span></code>.  The return value, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code>, is the index
into <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faults</span></code> such that <code class="xref mat mat-func docutils literal notranslate"><span class="pre">faults(i)</span></code> contains the information
pertaining to the <a href="#id23"><span class="problematic" id="id24">`</span></a>name`d fault.</p>
</li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="deckformat.html#deckformat.deckinput.readEclipseDeck" title="deckformat.deckinput.readEclipseDeck"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readEclipseDeck</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.processGRDECL">
<span class="sig-name descname"><span class="pre">processGRDECL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.processGRDECL" title="Permalink to this definition"></a></dt>
<dd><p>Compute grid topology and geometry from pillar grid description.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This code is designed to compute connectivity of fairly general
cornerpoint grids described in Eclipse <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SPECGRID/COORDS/ZCORN</span></code> format.
In short, the algorithm consist of</p>
<ol class="loweralpha">
<li><p>Compute 8 node coordinates of each grid block <a class="reference internal" href="#core.gridprocessing.buildCornerPtNodes" title="core.gridprocessing.buildCornerPtNodes"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildCornerPtNodes</span></code></a>.</p></li>
<li><p>Find unique points by comparing point coordinates and make matrix <code class="xref mat mat-func docutils literal notranslate"><span class="pre">P</span></code>
of point numbers for each grid block.</p></li>
<li><p>Add auxillary top and bottom layer to grid to ease processing of
outer boundary in the presence of faults.</p></li>
<li><p>Compute connectivity and corresponding face topology in i- j-
directions by considering pillar pairs.</p>
<p>Faulted pillar pairs, those where there is at least one non-matching
cell pair (non-neighboring connection), are processed separately by
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">findFaults</span></code>, the remaining pillar pairs with with matching cells are
processed by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">findFaces</span></code>.</p>
<p>Connectivity computation does not (ever) use the coordinates of
inactive cells as they are undefined by the grid format.  The
boundary between an active and an inactive region is considered as
outer boundary.</p>
<p>Collapsed faces and cells resulting form pinched layers are removed.</p>
</li>
<li><p>Compute connectivity in the k-direction by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">findVerticalFaces</span></code>. The
connectivity over pinched layers is restored.</p></li>
<li><p>Build grid struct <code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildGrid</span></code>, remove auxillary layers and pinched
cells (<a class="reference internal" href="#core.gridprocessing.removeCells" title="core.gridprocessing.removeCells"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">removeCells</span></code></a>), change cell and point numbering accordingly.</p></li>
<li><p>Check if grid is connected and reasonable.</p></li>
</ol>
<p>For each pair of pillars (1) and (2), compute geometric neighbor cells
and geometry of corresponding intersection of cell faces:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span>        <span class="p">(</span><span class="mi">1</span><span class="p">)</span>                        <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
         <span class="o">|</span>                          <span class="o">|</span>
<span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="o">*</span>                          <span class="o">|</span>
         <span class="o">|</span>  <span class="o">*</span>                       <span class="o">|</span>
<span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="n">o</span><span class="o">-----*--------------------</span><span class="n">o</span>  <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
         <span class="o">|</span>        <span class="o">*</span>                 <span class="o">|</span>
         <span class="o">|</span>           <span class="o">*</span>              <span class="o">|</span>
<span class="n">b</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="o">*</span>              <span class="o">*</span>           <span class="o">|</span>
         <span class="o">|</span>   <span class="o">*</span>             <span class="o">*</span>        <span class="o">|</span>
<span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="n">o</span><span class="o">-------*------------*-----</span><span class="n">o</span>  <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
         <span class="o">|</span>           <span class="o">*</span>           <span class="o">*</span>  <span class="o">|</span>
         <span class="o">|</span>               <span class="o">*</span>          <span class="o">*</span>  <span class="n">b</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
         <span class="o">|</span>                   <span class="o">*</span>      <span class="o">|</span>
         <span class="o">|</span>                       <span class="o">*</span>  <span class="o">|</span>
         <span class="o">|</span>                          <span class="o">*</span>  <span class="n">b</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
         <span class="o">|</span>                          <span class="o">|</span>
<span class="n">b</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*|</span>  <span class="n">b</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
         <span class="o">|</span>                          <span class="o">|</span>
         <span class="o">|</span>                          <span class="o">|</span>
<span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="n">o</span><span class="o">--------------------------</span><span class="n">o</span>  <span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
         <span class="o">|</span>                          <span class="o">|</span>
         <span class="o">|</span>                          <span class="o">|</span>
         <span class="o">|</span>                          <span class="o">|</span>
<span class="n">b</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>   <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*|</span>  <span class="n">b</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
         <span class="o">|</span>                          <span class="o">|</span>
         <span class="o">|</span>                          <span class="o">|</span>
</pre></div>
</div>
<p>Each row in point lists a and b correspond to a line as in the figure.
For cornerpoint grids, internal lines are repeated.  In the code below,
the odd spaces correspond to actual cells while the even spaces
correspond to inaccuracies in the format (or void space in the grid) and
are marked as inactive (with cell number 0)</p>
<p>Once the lines that corespond to active cells are identified, the
findConnections function loops through the z-coordinates of a- and
b-points to find the geometrical neighbors.  The face geometries are
computed last.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – Raw pillar grid structure, as defined by function
<a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, with fields <code class="xref mat mat-func docutils literal notranslate"><span class="pre">COORDS</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ZCORN</span></code> and, possibly,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ACTNUM</span></code>.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>Verbose</strong> – Whether or not to display progress information
Logical.  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Verbose</span> <span class="pre">=</span> <span class="pre">mrstVerbose</span></code>.</p></li>
<li><p><strong>Tolerance</strong> – Minimum distinguishing vertical distance for
points along a pillar.  Specifically, two points
(x1,y1,z1) and (x2,y2,z2) are considered separate
only if ABS(z2 - z1) &gt; Tolerance.
Non-negative scalar.
Default value: Tolerance = 0.0 (distinguish all
points along a pillar whose z coordinate differ
even slightly).</p></li>
<li><p><strong>CheckGrid</strong> – Whether or not to perform basic consistency
checks on the resulting grid.
Logical.  Default value: CheckGrid = true.</p></li>
<li><p><strong>SplitDisconnected</strong> – Whether or not to split disconnected grid
components into separate grids/reservoirs.
Logical.  Default value: SplitDisconnected=true.</p></li>
<li><p><strong>RepairZCORN</strong> – Make an effort to detect and repair artifacts
that may occur in the corner-point depth
specification.  Specifically, detect and repair
the following, rare, conditions:</p>
<blockquote>
<div><ul class="simple">
<li><p>Upper corners of a cell below lower corners
of that same cell</p></li>
<li><p>Lower corners of a cell below that cell’s
lower neighbour’s upper corners.</p></li>
</ul>
</div></blockquote>
<p>Logical.  Default value: RepairZCORN = false.</p>
</li>
<li><p><strong>PreserveCpNodes</strong> –</p>
<dl>
<dt>Whether or not to capture the vertex indicies of</dt><dd><p>each cell’s original corner-point nodes.  If true,
an additional G.cells.num-by-8 array named
‘cpnodes’ containing vertex indicies will be stored
in the ‘cells’ substructure of the fully
constructed grid.  Columns 1:4 are the vertices of
the “minimum K” surface while columns 5:8 are the
vertices of the “maximum K” surface.</p>
<p>The columns are stored in natural ordering of the
vertices, as demonstrated in the figure below.</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>+———–&gt; I</p>
</div></blockquote>
<p>/|</p>
</div></blockquote>
<p>/ |     1 ——— 2</p>
</div></blockquote>
<p>/  |    /|          /|   Column numbers mapped</p>
</div></blockquote>
</dd>
<dt>J v   |   / |         / |   to vertices in ECLIPSE’s</dt><dd><blockquote>
<div><div class="line-block">
<div class="line">3 ——— 4  |   default right-handed</div>
</div>
</div></blockquote>
<dl>
<dt>K v  |  |        |  |   coordinate system</dt><dd><div class="line-block">
<div class="line-block">
<div class="line">5 ——-<a href="#id25"><span class="problematic" id="id26">|</span></a>- 6   (origin is top, left,</div>
</div>
<div class="line">/         | /    back vertex with Z-axis</div>
</div>
<p><a href="#id27"><span class="problematic" id="id28">|</span></a>/          <a href="#id29"><span class="problematic" id="id30">|</span></a>/     pointing down.)
7 ——— 8</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>G</strong> – Valid grid definition containing connectivity, cell geometry, face
geometry and unique nodes.</p>
<p>If the pillar grid structure contains a pinch-out definition field
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">PINCH</span></code>, then the grid structure will contain a separate field
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">nnc</span></code> in the top-level structure if any explicit non-neighbouring
connections are deemed to exist according to the tolerances
specified in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PINCH</span></code>.  See function <a class="reference internal" href="#core.gridprocessing.processPINCH" title="core.gridprocessing.processPINCH"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processPINCH</span></code></a> for a more
detailed description of the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nnc</span></code> field.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">readGRDECL</span><span class="p">(</span><span class="s">&#39;small.grdecl&#39;</span><span class="p">));</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">45</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processPINCH" title="core.gridprocessing.processPINCH"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processPINCH</span></code></a>, <a class="reference internal" href="#core.gridprocessing.removeCells" title="core.gridprocessing.removeCells"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">removeCells</span></code></a>, <a class="reference internal" href="#core.gridprocessing.checkAndRepairZCORN" title="core.gridprocessing.checkAndRepairZCORN"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">checkAndRepairZCORN</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.processNNC">
<span class="sig-name descname"><span class="pre">processNNC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">NNC</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.processNNC" title="Permalink to this definition"></a></dt>
<dd><p>Establish explicit non-neighbouring connections from NNC keyword</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">nnc</span> <span class="p">=</span> <span class="n">processNNC</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">NNC</span><span class="p">)</span>
<span class="n">nnc</span> <span class="p">=</span> <span class="n">processNNC</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">NNC</span><span class="p">,</span> <span class="n">excludeExisting</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – MRST grid as defined by <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p></li>
<li><p><strong>NNC</strong> – Explicit list of non-neighbouring (according to Cartesian cell
indices) as defined by function <a class="reference internal" href="deckformat.html#deckformat.deckinput.readEclipseDeck" title="deckformat.deckinput.readEclipseDeck"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readEclipseDeck</span></code></a> from ECLIPSE
keyword <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NNC</span></code>.  Must be an m-by-7 array in which the first six
columns are (I,J,K) Cartesian indices of the first and second
connecting cells, respectively, and the seventh column is the
transmissibility of the corresponding connection.</p></li>
<li><p><strong>excludeExisiting</strong> – Flag indicating whether or not check if any of the explicit
non-neighbouring (tentatively non-geometrical) connections (pairs
of cells) are already present in the interface list and, if so,
exclude those from the new connections.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nnc</strong> – Structure describing explicit, additional non-neighbouring
connections.  Contains the following fields,</p>
<blockquote>
<div><p>cells - Active cells connected across an NNC.  An m-by-2 array
of active cell numbers in the format of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.neighbors</span></code>.
Each row of nnc.cells represents a single non-neighbouring
connection.</p>
<p>trans - Transmissibility of the corresponding connections.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Option <code class="xref mat mat-func docutils literal notranslate"><span class="pre">excludeExisting=true</span></code> is implemented in terms of function
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ismember(...,'rows')</span></code> which uses function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sortrows</span></code>.  This is
potentially very costly.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="deckformat.html#deckformat.deckinput.readEclipseDeck" title="deckformat.deckinput.readEclipseDeck"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readEclipseDeck</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ismember</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sortrows</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.processPINCH">
<span class="sig-name descname"><span class="pre">processPINCH</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.processPINCH" title="Permalink to this definition"></a></dt>
<dd><p>Establish vertical non-neighbouring across pinched-out layers</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">nnc</span> <span class="p">=</span> <span class="n">processPINCH</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function establishes non-neighbouring connections across
pinched-out layers that may nevertheless have a non-zero thickness.  In
other words, this function creates connections that do not otherwise
correspond to geometric interfaces.</p>
<p>This function is used within function <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a> to implement the
processing of keyword <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PINCH</span></code> in an <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ECLIPSE</span></code> input deck.  Note that we
currently do not support the complete feature set that may be input
through <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PINCH</span></code>.  Specifically, we only support the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">TOPBOT</span></code>
transmissibility option for item 4 of the keyword.  Any other setting
will be reset to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">TOPBOT</span></code> and a warning will be issued.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grdecl</strong> – Raw pillar grid structure, as defined (e.g.,) by function
<a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, with fields <code class="xref mat mat-func docutils literal notranslate"><span class="pre">COORDS</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ZCORN</span></code> and, possibly,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">ACTNUM</span></code>.</p></li>
<li><p><strong>G</strong> – Grid structure–typically created by function <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nnc</strong> – Structure describing explicit, additional non-neighbouring
connections.  Contains the following fields.</p>
<blockquote>
<div><p>cells - Active cells connected across an NNC.  An m-by-2 array
of active cell numbers in the format of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.neighbors</span></code>.
Each row of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nnc.cells</span></code> represents a single non-neighbouring
connection.</p>
<p>faces - Partially redundant connection information.  An m-by-2
array of interface numbers that represent those interfaces that
would otherwise be geometrically connected if the NNC were in
fact a geometric connection (single interface).</p>
</div></blockquote>
<p>If the pillar grid contains transmissibility multipliers in the
field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MULTZ</span></code>, the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nnc</span></code> structure will furthermore contain a
field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mult</span></code> of multipliers defined by item <code class="xref mat mat-func docutils literal notranslate"><span class="pre">5</span></code> of the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PINCH</span></code>
keyword.  The <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mult</span></code> field is an m-by-1 array of non-negative
scalars, the i’th of which is the multiplier of the i’th explicit
non-neighbouring connection (i.e., row <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nnc.cells</span></code>).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>At present, we only support generating NNCs across explicitly
deactivated layers–i.e., layers/cells for which <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ACTNUM==0</span></code>.  Therefore,
function <a class="reference internal" href="#core.gridprocessing.processPINCH" title="core.gridprocessing.processPINCH"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processPINCH</span></code></a> will fail unless the raw pillar grid structure
contains an <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ACTNUM</span></code> field.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.refineDeck">
<span class="sig-name descname"><span class="pre">refineDeck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deck_in</span></em>, <em class="sig-param"><span class="pre">dim</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.refineDeck" title="Permalink to this definition"></a></dt>
<dd><p>Refine the grid resolution of a deck, and update other information
(<code class="xref mat mat-func docutils literal notranslate"><span class="pre">RUNSPEC</span></code>, wells, selected cell-based fields under <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SOLUTION</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">REGIONS</span></code>
and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PROPS</span></code>) accordingly.</p>
<p>Cell-based fields are updated by letting refined cells inherit the values from
their ‘parent’ coarse cells.  Wells are updated by changing the cell indexing,
adding perforations in the direction of the original perforations, and divide
refined well indices and KH by the refinement in the perforation direction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is not fully tested and has only been used on a limited
subset of models. While potentially useful, it should be used with care
and results should be carefully examined.</p>
</div>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>deck<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">refineDeck</span><span class="p">(</span>deck_in, dim, varargin<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deck_in</strong> – deck to refine</p></li>
<li><p><strong>dim</strong> – 3-component vector with refinement factor in each cooridinate
direction</p></li>
<li><p><strong>varargin</strong> – supports the (true/false) keyword ‘default_well’.  If this is
false (default), prescribed well transmissibilities will be
kept (and updated based on the selected refinement).
Otherwise, transmissibilities will be replaced with default
values (i.e. to be computed from the grid).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>deck</strong> – defined deck</p>
</dd>
</dl>
<p>EXAMPLE:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>refineGRDECL</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.refineGrdecl">
<span class="sig-name descname"><span class="pre">refineGrdecl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl_in</span></em>, <em class="sig-param"><span class="pre">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.refineGrdecl" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Refine an Eclipse grid (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">GRDECL</span> <span class="pre">file</span></code>) with a specified factor in each of
the three logical grid directions.</p>
<dl class="simple">
<dt>Currently, the function</dt><dd><ul class="simple">
<li><p>Refines the grid by subdividing each cell according to input
parameter <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dim</span></code>.</p></li>
<li><p>Updates the following keywords: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ACTNUM</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PERMX</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PERMY</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PERMZ</span></code>,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">PORO</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MULTX</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MULTY</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MULTZ</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">EQLNUM</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FLUXNUM</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NTG</span></code>.</p></li>
<li><p>Updates the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">FAULTS</span></code> keyword.  Multipliers are not changed, which is
only correct for refinements in the z-direction.</p></li>
</ul>
</dd>
</dl>
<p>Function does not handle flow-based upscaling keywords (e.g. <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MULTX</span></code>,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">MULTY</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">MULTZ</span></code>) for which there is no natural automated refinement
process.</p>
<dl class="simple">
<dt>NOTE:</dt><dd><p>This function is not fully tested and has only been used on a limited
subset of models. While potentially useful, it should be used with care
and results should be carefully examined.</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>grdecl<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">refineGrdecl</span><span class="p">(</span>grdecl_in, dim<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grdecl_in</strong> – Eclipse grid to refine (grdecl)</p></li>
<li><p><strong>dim</strong> – refinement factor in each logical direction (3-component vector)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grdecl</strong> – refined grid</p>
</dd>
</dl>
<p>SEE ALSO:
refineDeck</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.removeCells">
<span class="sig-name descname"><span class="pre">removeCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">cells</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.removeCells" title="Permalink to this definition"></a></dt>
<dd><p>Remove cells from grid and renumber cells, faces and nodes.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="p">=</span> <span class="n">removeCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">);</span>
<span class="p">[</span><span class="n">H</span><span class="p">,</span> <span class="n">cellmap</span><span class="p">,</span> <span class="n">facemap</span><span class="p">,</span> <span class="n">nodemap</span><span class="p">]</span> <span class="p">=</span> <span class="n">removeCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Valid grid definition</p></li>
<li><p><strong>cells</strong> – List of cell numbers (cell IDs) to remove.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>H</strong> – Updated grid definition where cells have been removed.
Moreover, any unreferenced faces or nodes are subsequently
removed.</p></li>
<li><p><strong>cellmap</strong> – Cell numbers in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> for each cell in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">H</span></code>.  Specifically,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">cellmap(i)</span></code> is the cell ID of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> that corresponds to cell
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">H</span></code>.</p></li>
<li><p><strong>facemap</strong> – Face numbers in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> for each face in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">H</span></code>.  Specifically,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">facemap(i)</span></code> is the face ID of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> that corresponds to face
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">H</span></code>.</p></li>
<li><p><strong>nodemap</strong> – Node numbers in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> for each node in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">H</span></code>.  Specifically,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">nodemap(i)</span></code> is the node ID of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> that corresponds to node
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">H</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">removeCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">);</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="nb">view</span><span class="p">(</span><span class="o">-</span><span class="mi">35</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">camlight</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The process of removing cells is irreversible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.makeInternalBoundary" title="core.gridprocessing.makeInternalBoundary"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeInternalBoundary</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.removeFaultBdryFaces">
<span class="sig-name descname"><span class="pre">removeFaultBdryFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">flt</span></em>, <em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.removeFaultBdryFaces" title="Permalink to this definition"></a></dt>
<dd><p>Remove fault faces on boundary</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">flt</span>       <span class="p">=</span> <span class="n">removeFaultBdryFaces</span><span class="p">(</span><span class="n">flt</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>

<span class="p">[</span><span class="n">flt</span><span class="p">,</span> <span class="n">msk</span><span class="p">]</span> <span class="p">=</span> <span class="n">removeFaultBdryFaces</span><span class="p">(</span><span class="n">flt</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flt</strong> – A fault structure as defined by function <a class="reference internal" href="#core.gridprocessing.processFaults" title="core.gridprocessing.processFaults"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processFaults</span></code></a>.</p></li>
<li><p><strong>G</strong> – A grid structure representing a discretised reservoir geometry.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>flt</strong> – An updated fault structure.  Faults that no longer have any
constituent faces from the grid are removed.</p></li>
<li><p><strong>msk</strong> – Logical mask into original <code class="xref mat mat-func docutils literal notranslate"><span class="pre">flt</span></code> that indicates whether or not
the corresponding fault structure was still active after removing
its boundary faces.  Specifically, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">msk(i)==true</span></code> if fault <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code>
still has active faces after removing boundary contributions.
Moreover, its position in the updated <code class="xref mat mat-func docutils literal notranslate"><span class="pre">flt</span></code> structure is <code class="xref mat mat-func docutils literal notranslate"><span class="pre">pos(i)</span></code>
where <code class="xref mat mat-func docutils literal notranslate"><span class="pre">pos=cumsum(double(msk))</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processFaults" title="core.gridprocessing.processFaults"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processFaults</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.removeIntGrid">
<span class="sig-name descname"><span class="pre">removeIntGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.removeIntGrid" title="Permalink to this definition"></a></dt>
<dd><p>Cast any grid fields that are presently int32 to double</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">removeIntGrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid with fields that are possibly int32.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid where int32 has been removed from cells/faces subfields</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Previously <code class="xref mat mat-func docutils literal notranslate"><span class="pre">int32</span></code> was used in the grid structure to conserve memory.
This routine converts grids of the old type to the new one.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.removeInternalBoundary">
<span class="sig-name descname"><span class="pre">removeInternalBoundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">N</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.removeInternalBoundary" title="Permalink to this definition"></a></dt>
<dd><p>Remove internal boundary in grid by merging faces in face list N</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">removeInternalBoundary</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure as described by grid_structure.</p></li>
<li><p><strong>N</strong> – An n x 2 array of face numbers.  Each pair in the array
will be merged to a single face in G.  The connectivity if
the new grid is updated accordingly.  The geometric adjacency
of faces is not checked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>G</strong> – Modified grid structure.</p></li>
<li><p><strong>f</strong> – New face numbers for the faces that have been merged.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>What if nodes in f1 are permuted compared to nodes in f2, either due to
sign of face (2D) or due to arbitary starting node (3D)?  For the time
being, this code assumes that nodes that appear in faces that are being
merged coincide exactly — no checking is done on node positions.  If
nodes are permuted in one of the faces, the resulting grid will be
warped.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.makeInternalBoundary" title="core.gridprocessing.makeInternalBoundary"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeInternalBoundary</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.removePinch">
<span class="sig-name descname"><span class="pre">removePinch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">tol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.removePinch" title="Permalink to this definition"></a></dt>
<dd><p>Uniquify nodes, remove pinched faces and cells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="p">=</span> <span class="n">removePinch</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">H</span> <span class="p">=</span> <span class="n">removePinch</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure as described by <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p></li>
<li><p><strong>tol</strong> – Absolute tolerance to distinguish neighbouring points</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid structure where duplicate nodes have been removed in
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.nodes.coords</span></code> and duplicate node numbers are removed from
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.nodes</span></code>.  Faces with fewer than 3 nodes and cells with
fewer than <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.griddim+1</span></code> faces are also removed to avoid zero
areas and zero volumes subsequently.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.removeCells" title="core.gridprocessing.removeCells"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">removeCells</span></code></a>, <a class="reference internal" href="#core.gridprocessing.extractSubgrid" title="core.gridprocessing.extractSubgrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">extractSubgrid</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.removeShortEdges">
<span class="sig-name descname"><span class="pre">removeShortEdges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">tol</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.removeShortEdges" title="Permalink to this definition"></a></dt>
<dd><p>Replace short edges in grid G by a single node.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">removeShortEdges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure as described by grid_structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>G</strong> – Grid structure. Nodes joined by an edge with ||edge||&lt;tol
are collapsed to a single node at the edge midpoint. Faces
and cells that collapse as a consequence are removed.</p></li>
<li><p><strong>tol</strong> – OPTIONAL
The maximum length of edges that are removed. Default: 0.0</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is useful to remove very short edges that may appear in
PEBI/Voronoi grids and on faults in cornerpoint grids.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.pebi" title="core.gridprocessing.pebi"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pebi</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.repairNormals">
<span class="sig-name descname"><span class="pre">repairNormals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.repairNormals" title="Permalink to this definition"></a></dt>
<dd><p>temporary fix for non-XY 2D-grids, should be merged into computeGeometry!
Also computes 2D cell-normals which is useful for dealing with non-planar
grids</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.sliceGrid">
<span class="sig-name descname"><span class="pre">sliceGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">pnts</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.sliceGrid" title="Permalink to this definition"></a></dt>
<dd><p>Generate cut-cell-grid (G) and lower dim grid G_slice from slices/cuts
defined by pnts and optional inputs ‘normal’ or ‘cutDir’ as described in
computeGridSlicePolygons.m. For multiple cuts/slices list (cell) of pnts
and corresponding normal/cutDir are supported. See
computeGridSlicePolygons.m for further info on optional params.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.splitDisconnectedGrid">
<span class="sig-name descname"><span class="pre">splitDisconnectedGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.splitDisconnectedGrid" title="Permalink to this definition"></a></dt>
<dd><p>Split grid into disconnected components</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">splitDisconnectedGrid</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">splitDisconnectedGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>Verbose</strong> – Whether or not to display progress information
Logical.  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Verbose</span> <span class="pre">=</span> <span class="pre">mrstVerbose</span></code>.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>G</strong> – Array of grid structures, one element for each disconnected grid
component, sorted in order of decreasing number of cells.  If the
grid consists of a single component (i.e., if there are no
disconnected grid components), then the return value <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> is equal
to the input parameter <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>Function <a class="reference internal" href="#core.gridprocessing.splitDisconnectedGrid" title="core.gridprocessing.splitDisconnectedGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">splitDisconnectedGrid</span></code></a> will also consider any explicit
non-neighbouring connections represented in a field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nnc</span></code> stored in
the top-level structure of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> when determining whether or not any
disconnected components exist.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processPINCH" title="core.gridprocessing.processPINCH"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processPINCH</span></code></a>, <a class="reference internal" href="#core.gridprocessing.extractSubgrid" title="core.gridprocessing.extractSubgrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">extractSubgrid</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.tensorGrid">
<span class="sig-name descname"><span class="pre">tensorGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.tensorGrid" title="Permalink to this definition"></a></dt>
<dd><p>Construct Cartesian grid with variable physical cell sizes.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">tensorGrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">tensorGrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">tensorGrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s">&#39;depthz&#39;</span><span class="p">,</span> <span class="n">dz</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">tensorGrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">tensorGrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="s">&#39;depthz&#39;</span><span class="p">,</span> <span class="n">dz</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Vectors giving cell vertices, in units of meters, of individual
coordinate directions.  Specifically, the grid cell at
logical location (I,J,K) will have a physical dimension of
[x(I+1)-x(I), y(J+1)-y(J), z(K+1)-z(K)] (meters).</p></li>
<li><p><strong>y</strong> – Vectors giving cell vertices, in units of meters, of individual
coordinate directions.  Specifically, the grid cell at
logical location (I,J,K) will have a physical dimension of
[x(I+1)-x(I), y(J+1)-y(J), z(K+1)-z(K)] (meters).</p></li>
<li><p><strong>z</strong> – Vectors giving cell vertices, in units of meters, of individual
coordinate directions.  Specifically, the grid cell at
logical location (I,J,K) will have a physical dimension of
[x(I+1)-x(I), y(J+1)-y(J), z(K+1)-z(K)] (meters).</p></li>
<li><p><strong>dz</strong> – <p>Depth, in units of meters, at which upper reservoir nodes
are encountered.  Assumed to be a
NUMEL(x)-by-NUMEL(y) array of nodal depths.</p>
<p>OPTIONAL.
Default value: depthz = ZEROS([numel(x), numel(y)])</p>
<blockquote>
<div><p>(i.e., top of reservoir at zero depth).</p>
</div></blockquote>
</p></li>
<li><p><strong>cellnodes</strong> – OPTIONAL.
Default value FALSE.  If TRUE, the corner points of each
cell is added as field G.cellNodes.  The field has one row
per cell, the sequence of nodes on each is (imin,
jmin,kmin), (imax,jmin,kmin), (imin,jmax,kmin), …</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid structure with a subset of the fields <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.
Specifically, the geometry fields are missing:</p>
<blockquote>
<div><ul class="simple">
<li><p>G.cells.volumes</p></li>
<li><p>G.cells.centroids</p></li>
<li><p>G.faces.areas</p></li>
<li><p>G.faces.normals</p></li>
<li><p>G.faces.centroids</p></li>
</ul>
</div></blockquote>
<p>These fields may be computed using the function <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>.</p>
<p>There is, however, an additional field not described in
<a href="#id31"><span class="problematic" id="id32">`</span></a>grid_structure:</p>
<blockquote>
<div><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartDims</span></code> is a length 1, 2 or 3 vector giving number of cells
in each coordinate direction.  In other words</p>
<blockquote>
<div><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">all(G.cartDims</span> <span class="pre">==</span> <span class="pre">celldim)</span></code>.</p>
</div></blockquote>
</div></blockquote>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.faces(:,2)</span></code> contains integers 1-6 corresponding to
directions W, E, S, N, T, B respectively.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.tessellationGrid">
<span class="sig-name descname"><span class="pre">tessellationGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.tessellationGrid" title="Permalink to this definition"></a></dt>
<dd><p>Construct valid grid definition from points and tessellation list</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">tessellationGrid</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>P</strong> – Node coordinates.  Must be an m-by-2 matrix, one row for each
node/point.</p></li>
<li><p><strong>T</strong> – Tessellation list: an n-by-k matrix where each row holds node
numbers for a k-polygon, or a n-by-1 cell array where each
entry holds an array of node numbers, where the array length
can vary for each entry</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Valid grid definition.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span>% Construct a standard Cartesian grid
[nx,ny] = deal(15,10);
[x,y] = meshgrid(linspace(0,1,nx+1),linspace(0,1,ny+1));
p = [x(:) y(:)];
n = (nx+1)*(ny+1);
I = reshape(1:n,ny+1,nx+1);
T = [
    reshape(I(1:end-1,1:end-1),[],1)&#39;;
    reshape(I(1:end-1,2:end  ),[],1)&#39;;
    reshape(I(2:end,  2:end  ),[],1)&#39;;
    reshape(I(2:end,  1:end-1),[],1)&#39;
    ]&#39;;
G = tessellationGrid(p, T);
clf, plotGrid(G);

% Construct a symmetric pattern of 6-point polygons
[dx, dy, dPhi] = deal(cos(pi/3),sin(pi/3), pi*15/180);
v = pi/180*[0 120 240]&#39;;
dv = [cos(v-dPhi) sin(v-dPhi) cos(v+dPhi) sin(v+dPhi)]/2;
P = [ 0           0           0           0;
      0+dv(1,1)   0+dv(1,2)   0+dv(1,3)   0+dv(1,4);
      1           0           1           0;
      1+dv(2,1)   0+dv(2,2)   1+dv(2,3)   0+dv(2,4);
      dx          dy          dx          dy;
      dx+dv(3,1)  dy+dv(3,2)  dx+dv(3,3)  dy+dv(3,4)];
P1 = P(:,1:2);
P2 = [P([1 6:-1:2],3) -P([1 6:-1:2],4)];
T  = reshape(1:24,6,4)&#39;;

[p,t,n] = deal([],[],0);
for j=0:2
    for i=0:4
        p = [p; bsxfun(@plus,P1,[i 2*j*dy])];
        p = [p; bsxfun(@plus,P2,[i-dx (2*j+1)*dy])];
        p = [p; bsxfun(@plus,P1,[i-dx (2*j+1)*dy])];
        p = [p; bsxfun(@plus,P2,[i 2*(j+1)*dy])];
        t = [t; T+n]; n=n+24;
   end
end

[p,ia,ic] = unique(round(p*1e5)/1e5,&#39;rows&#39;);
G = tessellationGrid(p, ic(t));
i=repmat((1:2)&#39;,G.cells.num/2,1);
plotCellData(G,i(:));
plotFaces(G,find(any(G.faces.neighbors==0,2)),&#39;EdgeColor&#39;,&#39;r&#39;,&#39;LineWidth&#39;,2);
axis tight off;

% Construct a polyhedral grid
p = [0 0; 1 0 ; 0.4 0.6; 1.5 0.5; 0 1; 1 1];
T = {[1 3 5],[3 6 5],[1 2 4 6 3]}&#39;;
G = tessellationGrid(p, T);
clf, plotGrid(G);
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.triangleGrid" title="core.gridprocessing.triangleGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">triangleGrid</span></code></a>, <a class="reference internal" href="#core.gridprocessing.tetrahedralGrid" title="core.gridprocessing.tetrahedralGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tetrahedralGrid</span></code></a>, <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.tetrahedralGrid">
<span class="sig-name descname"><span class="pre">tetrahedralGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.tetrahedralGrid" title="Permalink to this definition"></a></dt>
<dd><p>Construct valid grid definition from points and tetrahedron list</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">tetrahedralGrid</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">tetrahedralGrid</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>P</strong> – Node coordinates.  Must be an m-by-3 matrix, one row for each
node/point.</p></li>
<li><p><strong>T</strong> – <p>Tetrahedron list (point tesselation): an n-by-4 matrix where each
row holds node numbers for a tetrahedron.</p>
<p>OPTIONAL.  Default value: T = DELAUNAY3(P(:,1), P(:,2), P(:,3))</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Valid grid definition.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.triangleGrid" title="core.gridprocessing.triangleGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">triangleGrid</span></code></a>, <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.triangleGrid">
<span class="sig-name descname"><span class="pre">triangleGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.triangleGrid" title="Permalink to this definition"></a></dt>
<dd><p>Construct valid grid definition from points and triangle list</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">triangleGrid</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">triangleGrid</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>P</strong> – Node coordinates.  Must be an m-by-2 matrix, one row for each
node/point.</p></li>
<li><p><strong>T</strong> – <p>Triangle list: an n-by-3 matrix where each row holds node
numbers for a triangle.</p>
<p>OPTIONAL.  Default value:  T = DELAUNAY(P(:,1), P(:,2))</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Valid grid definition.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">N</span>     <span class="p">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">N1</span>    <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">;</span>
<span class="n">N2</span>    <span class="p">=</span> <span class="mi">3</span><span class="o">*</span><span class="nb">ceil</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
<span class="p">[</span><span class="n">X</span> <span class="n">Y</span><span class="p">]</span> <span class="p">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="n">N1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="n">N2</span><span class="p">);</span>
<span class="n">X</span>     <span class="p">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">X</span><span class="p">;</span>
<span class="n">Y</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">)=</span><span class="n">Y</span><span class="p">(:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="p">;</span>
<span class="n">p</span>     <span class="p">=</span> <span class="p">[</span><span class="n">X</span><span class="p">(:),</span> <span class="n">Y</span><span class="p">(:)];</span>
<span class="n">t</span>     <span class="p">=</span> <span class="nb">delaunayn</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="n">G</span>     <span class="p">=</span> <span class="n">triangleGrid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="nb">cla</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">delaunay</span></code>, <a class="reference internal" href="#core.gridprocessing.tetrahedralGrid" title="core.gridprocessing.tetrahedralGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tetrahedralGrid</span></code></a>, <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.triangulateFaces">
<span class="sig-name descname"><span class="pre">triangulateFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.triangulateFaces" title="Permalink to this definition"></a></dt>
<dd><p>Split face f in grid G into subfaces.</p>
<p class="rubric">Description:</p>
<p>For each face listed in F, face center as compute average of face node
coordinates.  Use face center to triangulate face.  remove original
face and add triangular faces.</p>
<p>If no face list F is given, all faces in G are triangulated.  This
should make a grid with curved faces polyhedral, i.e., a grid with onlu
plane faces.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">triangulateFaces</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">triangulateFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid</p></li>
<li><p><strong>f</strong> – indices to faces that are to be split. Default is all faces.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a></p>
</div>
</dd></dl>

<div class="section" id="module-core.gridprocessing.testgrids">
<span id="test-grids"></span><h3>Test grids<a class="headerlink" href="#module-core.gridprocessing.testgrids" title="Permalink to this headline"></a></h3>
<dl class="mat script">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.gridprocessing.testgrids.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>TESTGRIDS</dt><dd><p>Simple to moderately advanced synthetic test models</p>
</dd>
<dt>Files</dt><dd><p>cartesianGrdecl      - Construct Cartesian grid with variable physical cell sizes.
createPinchedColumn  - Create a single column containing a single pinched layer of thickess 0.01
extrudedTriangleGrid - Build a synthetic grid with a curved fault in the lateral direction
makeModel3           - Build a synthetic geometry with two faults.
oneSlopingFault      - Make a GRDECL structure for a box grid with a single sloping fault.
pinchedLayersGrdecl  - Make a GRDECL structure for simple corner-point grid, possibly faulted.
pinchedNode          - Define two-cell corner-point specification with single, pinched vertex
pinchMiddleCell      - Create corner-point descriptions with variable number of pinched nodes
raisedColumn         - Create corner-point description of 2-by-1-by-2 grid with one fault
simpleGrdecl         - Make a GRDECL structure for simple corner-point grid, possibly faulted.
threeLayers          - Construct a corner point discretization of a three-layered structure.
twister              - Permutes x- and y-coordinates of nodes in a grid.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat script">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.cutCellGrids">
<span class="sig-name descname"><span class="pre">cutCellGrids</span></span><a class="headerlink" href="#core.gridprocessing.testgrids.cutCellGrids" title="Permalink to this definition"></a></dt>
<dd><p>Some simple tests</p>
</dd></dl>

<dl class="mat script">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.markCutGridsExample1">
<span class="sig-name descname"><span class="pre">markCutGridsExample1</span></span><a class="headerlink" href="#core.gridprocessing.testgrids.markCutGridsExample1" title="Permalink to this definition"></a></dt>
<dd><p>Test marking cut domains from sliceGrid</p>
</dd></dl>

<dl class="mat script">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.markCutGridsExample2">
<span class="sig-name descname"><span class="pre">markCutGridsExample2</span></span><a class="headerlink" href="#core.gridprocessing.testgrids.markCutGridsExample2" title="Permalink to this definition"></a></dt>
<dd><p>Test marking cut domains from sliceGrid</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.cartesianGrdecl">
<span class="sig-name descname"><span class="pre">cartesianGrdecl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">xi</span></em>, <em class="sig-param"><span class="pre">yi</span></em>, <em class="sig-param"><span class="pre">zi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.cartesianGrdecl" title="Permalink to this definition"></a></dt>
<dd><p>Construct Cartesian grid with variable physical cell sizes.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">cartesianGrdecl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">cartesianGrdecl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s">&#39;depthz&#39;</span><span class="p">,</span> <span class="n">depthz</span><span class="p">)</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">cartesianGrdecl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">cartesianGrdecl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="s">&#39;depthz&#39;</span><span class="p">,</span> <span class="n">depthz</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Vectors specifying cell vertices, in units of meters, of
individual coordinate directions.  Specifically, the grid
cell at logical location (I, J, K) will have a physical
dimension of [x(I+1)-x(I), y(J+1)-y(J), z(K+1)-z(K)] (meters).</p></li>
<li><p><strong>y</strong> – Vectors specifying cell vertices, in units of meters, of
individual coordinate directions.  Specifically, the grid
cell at logical location (I, J, K) will have a physical
dimension of [x(I+1)-x(I), y(J+1)-y(J), z(K+1)-z(K)] (meters).</p></li>
<li><p><strong>z</strong> – Vectors specifying cell vertices, in units of meters, of
individual coordinate directions.  Specifically, the grid
cell at logical location (I, J, K) will have a physical
dimension of [x(I+1)-x(I), y(J+1)-y(J), z(K+1)-z(K)] (meters).</p></li>
<li><p><strong>depthz</strong> – <p>Depth, in units of meters, at which upper reservoir nodes
are encountered.  Assumed to be a NUMEL(x)-by-NUMEL(y) array
of nodal depths.</p>
<p>OPTIONAL.
Default value: depthz = ZEROS([numel(x), numel(y)])</p>
<blockquote>
<div><p>(i.e., top of reservoir at zero depth).</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grdecl</strong> – A GRDECL structure suitable for further processing by
function ‘processGRDECL’ or for permanent storage on disk by
function ‘writeGRDECL’.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Create a 20-by-20-by-5 Cartesian grid and plot it.</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">cartesianGrdecl</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">);</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">));</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">grid</span> <span class="n">on</span><span class="p">,</span> <span class="nb">axis</span> <span class="n">tight</span>

<span class="c">% 2) Make a 20-by-20-by-5 Cartesian grid with wavy shape</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span> <span class="p">=</span> <span class="nb">ndgrid</span><span class="p">(</span><span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">21</span><span class="p">),</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="mi">21</span><span class="p">));</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">cartesianGrdecl</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s">&#39;depthz&#39;</span><span class="p">,</span> <span class="nb">sin</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.*</span><span class="nb">sin</span><span class="p">(</span><span class="n">Y</span><span class="p">));</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">));</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">grid</span> <span class="n">on</span><span class="p">,</span> <span class="nb">axis</span> <span class="n">tight</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <a class="reference internal" href="#core.utils.inout.writeGRDECL" title="core.utils.inout.writeGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">writeGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.testgrids.simpleGrdecl" title="core.gridprocessing.testgrids.simpleGrdecl"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simpleGrdecl</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.createPinchedColumn">
<span class="sig-name descname"><span class="pre">createPinchedColumn</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.createPinchedColumn" title="Permalink to this definition"></a></dt>
<dd><p>Create a single column containing a single pinched layer of thickess 0.01</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">createPinchedColumn</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grdecl</strong> – Corner-point specification suitable for passing to grid
constructor <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.extrudedTriangleGrid">
<span class="sig-name descname"><span class="pre">extrudedTriangleGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">maxarea</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.extrudedTriangleGrid" title="Permalink to this definition"></a></dt>
<dd><p>Build a synthetic grid with a curved fault in the lateral direction</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">extrudedTriangleGrid</span><span class="p">()</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">extrudedTriangleGrid</span><span class="p">(</span><span class="n">maxarea</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">extrudedTriangleGrid</span><span class="p">(</span><span class="n">maxarea</span><span class="p">,</span> <span class="n">dual</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxarea</strong> – maximal area of triangles in the areal grid from which the
prismatic grid is extruded
Default: 100</p></li>
<li><p><strong>dual</strong> – if true, use a lateral pebi grid rather than a triangle grid
as basis for the extrusion process.
Default: false</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – a standard grid structure</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Prismatic grid</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">extrudedTriangleGrid</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span><span class="mi">60</span><span class="p">),</span> <span class="nb">axis</span> <span class="n">tight</span> <span class="n">off</span>

<span class="c">% PEBI grid</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">extrudedTriangleGrid</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span><span class="mi">60</span><span class="p">),</span> <span class="nb">axis</span> <span class="n">tight</span> <span class="n">off</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.makeModel3">
<span class="sig-name descname"><span class="pre">makeModel3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dims</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.makeModel3" title="Permalink to this definition"></a></dt>
<dd><p>Build a synthetic geometry with two faults.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">makeModel3</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">makeModel3</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">physDims</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims</strong> – A 3-vector <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[nx,</span> <span class="pre">ny,</span> <span class="pre">nz]</span></code> giving the number of cells in each of
the three coordinate directions.</p></li>
<li><p><strong>physdims</strong> – <p>A 3-vector <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[hx,</span> <span class="pre">hy,</span> <span class="pre">hz]</span></code> giving the physical extent (in units
of meters) of the original sandbox before the transformations
that emulate geological activity. OPTIONAL.  Default value:
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">[1000,</span> <span class="pre">600,</span> <span class="pre">15]</span></code>,  meaning the geometry discretises a sandbox
of the following size in physical domain:</p>
<blockquote>
<div><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">[0,1000]</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[0,600]</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[0,15]</span></code></p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grdecl</strong> – A GRDECL structure suitable for passing to function
<a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">plotGrid</span><span class="p">(</span><span class="n">processGRDECL</span><span class="p">(</span><span class="n">makeModel3</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">15</span><span class="p">])));</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.oneSlopingFault">
<span class="sig-name descname"><span class="pre">oneSlopingFault</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dims</span></em>, <em class="sig-param"><span class="pre">drop</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.oneSlopingFault" title="Permalink to this definition"></a></dt>
<dd><p>Make a GRDECL structure for a box grid with a single sloping fault.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">oneSlopingFault</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">drop</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function creates a (possibly non-matching) nx-by-ny-by-nz cell
corner-point grid containing a single fault.  The resulting geometry
discretises the physical domain</p>
<blockquote>
<div><p>[0,500] x [0,100] x [0,32].</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Three-element vector, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[nx,</span> <span class="pre">ny,</span> <span class="pre">nz]</span></code>, specifying the number of
cells in the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">y</span></code>, and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">z</span></code> coordinate directions
respectively.</p></li>
<li><p><strong>drop</strong> – Length of fault drop (i.e., the physical length (in metres)
by which the two faulted blocks should be offset (along the
fault)).  OPTIONAL.  Default value: drop = 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grdecl</strong> – A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">GRDECL</span></code> structure suitable for passing to function
<a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This example is due to knl.</p>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Create a 90-by-10-by-16 fault grid file with a fault drop of 5 (m)</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">oneSlopingFault</span><span class="p">([</span><span class="mi">90</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="mi">5</span><span class="p">);</span>

<span class="c">% Create the grid data structure</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">));</span>

<span class="c">% Plot the geometry</span>
<span class="n">hg</span> <span class="p">=</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">,</span> <span class="s">&#39;EdgeAlpha&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">grid</span> <span class="n">on</span><span class="p">,</span> <span class="nb">axis</span> <span class="n">tight</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECl</span></code>, <a class="reference internal" href="#core.utils.inout.writeGRDECL" title="core.utils.inout.writeGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">writeGRDECL</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.pinchMiddleCell">
<span class="sig-name descname"><span class="pre">pinchMiddleCell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">k</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.pinchMiddleCell" title="Permalink to this definition"></a></dt>
<dd><p>Create corner-point descriptions with variable number of pinched nodes</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">pinchMiddleCell</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> – Number of middle cell pinched corners.  Must be between zero
and four, inclusive.  OPTIONAL.  Default value: n = 1.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grdecl</strong> – Cell array of corner-point descriptions suitable for
subsequent processing using function <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.  Array
size is <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nchoosek(4,n)</span></code>, one element for each combination of
selecting <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code> elements from four possibilities.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an extension of the test case defined by function <a class="reference internal" href="#core.gridprocessing.testgrids.pinchedNode" title="core.gridprocessing.testgrids.pinchedNode"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pinchedNode</span></code></a></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.testgrids.pinchedNode" title="core.gridprocessing.testgrids.pinchedNode"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pinchedNode</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nchoosek</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.pinchedLayersGrdecl">
<span class="sig-name descname"><span class="pre">pinchedLayersGrdecl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dims</span></em>, <em class="sig-param"><span class="pre">drop</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.pinchedLayersGrdecl" title="Permalink to this definition"></a></dt>
<dd><p>Make a GRDECL structure for simple corner-point grid, possibly faulted.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">pinchedLayersGrdecl</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">pinchedLayersGrdecl</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">drop</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function creates a nx-by-ny-by-nz cell corner-point grid.  The
resulting geometry discretises the physical domain</p>
<blockquote>
<div><p>[0,1] x [0,1] x [0,0.5].</p>
</div></blockquote>
<p>which is deformed by adding <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sin(x)</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sin(x*y)</span></code> perturbations.  In
addition, the pillars are skewed.  If a second input parameter is
provided, a single fault of given drop size is added in the model at
approximately x=0.5.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Three-element vector, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[nx,</span> <span class="pre">ny,</span> <span class="pre">nz]</span></code>, specifying the number of
cells in the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">y</span></code>, and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">z</span></code> coordinate directions
respectively.</p></li>
<li><p><strong>drop</strong> – Length of fault drop (i.e., the physical length (in metres) by
which the two blocks should be offset (along the fault)).
The drop size can be a numeric value or a handle to a function
of a spatial coordinate along the fault.
OPTIONAL.  Default value: drop = 0 (no fault).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grdecl</strong> – A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">GRDECL</span></code> structure suitable for further processing by
function <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a> or for permanent storage on disk by
function <a class="reference internal" href="#core.utils.inout.writeGRDECL" title="core.utils.inout.writeGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">writeGRDECL</span></code></a>.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Create a 50-by-50-by-10 fault grid file with a linear fault drop.</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">pinchedLayersGrdecl</span><span class="p">([</span><span class="mi">50</span> <span class="mi">50</span> <span class="mi">10</span><span class="p">],</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="p">.</span><span class="mi">05</span><span class="o">+</span><span class="mf">0.07</span><span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="c">% Create the grid data structure</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">));</span>

<span class="c">% Plot the geometry</span>
<span class="n">hg</span> <span class="p">=</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">);</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">grid</span> <span class="n">on</span><span class="p">,</span> <span class="nb">axis</span> <span class="n">tight</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <a class="reference internal" href="#core.utils.inout.writeGRDECL" title="core.utils.inout.writeGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">writeGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.testgrids.simpleGrdecl" title="core.gridprocessing.testgrids.simpleGrdecl"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simpleGrdecl</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.pinchedNode">
<span class="sig-name descname"><span class="pre">pinchedNode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.pinchedNode" title="Permalink to this definition"></a></dt>
<dd><p>Define two-cell corner-point specification with single, pinched vertex</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">pinchedNode</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grdecl</strong> – A GRDECL structure suitable for further processing by function
<a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, refinement by function <a class="reference internal" href="#core.gridprocessing.refineGrdecl" title="core.gridprocessing.refineGrdecl"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">refineGrdecl</span></code></a>, or
permanent storage on disk by function <a class="reference internal" href="#core.utils.inout.writeGRDECL" title="core.utils.inout.writeGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">writeGRDECL</span></code></a>.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">refineGrdecl</span><span class="p">(</span><span class="n">pinchedNode</span><span class="p">,</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">20</span><span class="p">]);</span>
<span class="n">g</span>      <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">));</span>
<span class="n">fluid</span>  <span class="p">=</span> <span class="n">initSingleFluid</span><span class="p">(</span><span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;rho&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">rock</span>   <span class="p">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s">&#39;perm&#39;</span><span class="p">,</span> <span class="nb">ones</span><span class="p">([</span><span class="n">g</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">]));</span>
<span class="n">s</span>      <span class="p">=</span> <span class="n">computeMimeticIP</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">rock</span><span class="p">);</span>
<span class="n">bc</span>     <span class="p">=</span> <span class="n">fluxside</span><span class="p">([],</span> <span class="n">g</span><span class="p">,</span> <span class="s">&#39;LEFT&#39;</span> <span class="p">,</span>  <span class="mi">1</span><span class="p">);</span>
<span class="n">bc</span>     <span class="p">=</span> <span class="n">fluxside</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="s">&#39;RIGHT&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">x</span>      <span class="p">=</span> <span class="n">initState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">x</span>      <span class="p">=</span> <span class="n">solveIncompFlow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="s">&#39;bc&#39;</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">plotCellData</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">pressure</span><span class="p">,</span> <span class="p">...</span>
             <span class="s">&#39;EdgeColor&#39;</span><span class="p">,</span> <span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="s">&#39;EdgeAlpha&#39;</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">colorbar</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.refineGrdecl" title="core.gridprocessing.refineGrdecl"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">refineGrdecl</span></code></a>, <a class="reference internal" href="#core.utils.inout.writeGRDECL" title="core.utils.inout.writeGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">writeGRDECL</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.raisedColumn">
<span class="sig-name descname"><span class="pre">raisedColumn</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.raisedColumn" title="Permalink to this definition"></a></dt>
<dd><p>Create corner-point description of 2-by-1-by-2 grid with one fault</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">raisedColum</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grdecl</strong> – Corner-point description.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is primarily intended as a test grid in the development of an
edge-conforming corner-point processing routine.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.testgrids.simpleGrdecl" title="core.gridprocessing.testgrids.simpleGrdecl"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simpleGrdecl</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.simpleGrdecl">
<span class="sig-name descname"><span class="pre">simpleGrdecl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dims</span></em>, <em class="sig-param"><span class="pre">drop</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.simpleGrdecl" title="Permalink to this definition"></a></dt>
<dd><p>Make a GRDECL structure for simple corner-point grid, possibly faulted.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">simpleGrdecl</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">simpleGrdecl</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">drop</span><span class="p">)</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">simpleGrdecl</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">drop</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function creates a nx-by-ny-by-nz cell corner-point grid.  The
resulting geometry discretises the physical domain</p>
<blockquote>
<div><p>[0,1] x [0,1] x [0,0.5].</p>
</div></blockquote>
<p>which is deformed by adding <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sin(x)</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sin(x*y)</span></code> perturbations.  In
addition, the pillars are skewed.  If a second input parameter is
provided, a single fault of given drop size is added in the model at
approximately x=0.5.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Three-element vector, [nx, ny, nz], specifying the number of
cells in the ‘x’, ‘y’, and ‘z’ coordinate directions
respectively.</p></li>
<li><p><strong>drop</strong> – Length of fault drop (i.e., the physical length (in metres) by
which the two blocks should be offset (along the fault)).
The drop size can be a numeric value or a handle to a function
of a spatial coordinate along the fault.
OPTIONAL.  Default value: drop = 0 (no fault).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>flat</strong> – Flag indicating if the sine perturbations should <em>NOT</em>
be added.  Default: FALSE (add perturbations).</p></li>
<li><p><strong>undisturbed</strong> – Flag indicating that skew pillars should not be created.
Default: FALSE (make skew pillars)</p></li>
<li><p><strong>physDims</strong> – A three element vector corresponding to the physical
dimensions of the domain. Defaults to [1,1,0.5].</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – A <code class="xref mat mat-func docutils literal notranslate"><span class="pre">GRDECL</span></code> structure suitable for further processing by
function <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a> or for permanent storage on disk by
function <a class="reference internal" href="#core.utils.inout.writeGRDECL" title="core.utils.inout.writeGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">writeGRDECL</span></code></a>.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Create a 20-by-20-by-5 faulted grid with a fault drop of 0.15 (m).</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">simpleGrdecl</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mf">0.15</span><span class="p">);</span>

<span class="c">% Create the grid data structure.</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">);</span>

<span class="c">% Plot the resulting geometry.</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">hg1</span> <span class="p">=</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">);</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">grid</span> <span class="n">on</span><span class="p">,</span> <span class="nb">axis</span> <span class="n">tight</span>

<span class="c">% 2) Create the same 20-by-20-by-5 faulted grid, but now with a</span>
<span class="c">%    variable fault drop implemented as a function handle.</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">simpleGrdecl</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="p">(</span><span class="nb">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">);</span>

<span class="c">% Create the grid data structure.</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">);</span>

<span class="c">% Plot the resulting geometry.</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">hg2</span> <span class="p">=</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">);</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">grid</span> <span class="n">on</span><span class="p">,</span> <span class="nb">axis</span> <span class="n">tight</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <a class="reference internal" href="#core.utils.inout.writeGRDECL" title="core.utils.inout.writeGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">writeGRDECL</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.threeLayers">
<span class="sig-name descname"><span class="pre">threeLayers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nx</span></em>, <em class="sig-param"><span class="pre">ny</span></em>, <em class="sig-param"><span class="pre">nz</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.threeLayers" title="Permalink to this definition"></a></dt>
<dd><p>Construct a corner point discretization of a three-layered structure.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">threeLayers</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function creates a corner point discretization of a mapped
three-layered structure from the physical domain</p>
<blockquote>
<div><p>[-1,1] x [0,1] x [0,1].</p>
</div></blockquote>
<p>The horizontal regions correspond to dividing planes at z=0.25 and
z=0.75.  Moreover, when x&gt;=0, the z-coordinate of each vertex is mapped
according to the rule</p>
<blockquote>
<div><p>z = z - (z + 1)*y/2,  y in [0, 1]</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – One- or two-element vector defining the number of intervals along
the X axis.  Specifically, if nx=[n1, n2], then the interval
[-1,0] will be divided into n1 sub-intervals and the interval
[0,1] will be divided into n2 sub-intervals.  A scalar <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nx</span></code>
parameter is treated as if the caller specified nx = [nx, nx].</p></li>
<li><p><strong>ny</strong> – Number of sub-intervals along the Y axis.  Single positive integer.</p></li>
<li><p><strong>nz</strong> – One or three-element vector defining the number of sub-intervals
along the Z axis.  Specifically, if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nz=[n1,</span> <span class="pre">n2,</span> <span class="pre">n3]</span></code>, then the
interval <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[0,0.25]</span></code> will be divided into <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n1</span></code> sub-intervals, the
interval <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[0.25,0.75]</span></code> will be divided into <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n2</span></code> sub-intervals,
and the interval <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[0.75,1]</span></code> will be divided into <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n3</span></code>
sub-intervals. A scalar <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nz</span></code> parameter is treated as if the caller
specified nz = [nz, nz, nz].</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">threeLayers</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">)</span>
<span class="n">h</span> <span class="p">=</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;EdgeAlpha&#39;</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span> <span class="mf">0.375</span><span class="p">);</span>
<span class="k">set</span><span class="p">(</span><span class="k">get</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s">&#39;Parent&#39;</span><span class="p">),</span> <span class="s">&#39;ZDir&#39;</span><span class="p">,</span> <span class="s">&#39;normal&#39;</span><span class="p">)</span>
<span class="nb">view</span><span class="p">(</span><span class="mf">148.5</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – A GRDECL structure suitable for further processing by
function ‘processGRDECL’ or for permanent storage on disk by
function ‘writeGRDECL’.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <a class="reference internal" href="#core.utils.inout.writeGRDECL" title="core.utils.inout.writeGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">writeGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.testgrids.simpleGrdecl" title="core.gridprocessing.testgrids.simpleGrdecl"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simpleGrdecl</span></code></a>, <a class="reference internal" href="#core.gridprocessing.testgrids.makeModel3" title="core.gridprocessing.testgrids.makeModel3"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeModel3</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.gridprocessing.testgrids.twister">
<span class="sig-name descname"><span class="pre">twister</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pt</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.gridprocessing.testgrids.twister" title="Permalink to this definition"></a></dt>
<dd><p>Permutes x- and y-coordinates of nodes in a grid.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">pt</span> <span class="p">=</span> <span class="n">twister</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
<span class="n">G</span>  <span class="p">=</span> <span class="n">twister</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pt</strong> – Coordinates to permute</p></li>
<li><p><strong>G</strong> – Grid structure</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pt</strong> – Modified coordinates.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">pt</span></code> is the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nodes.coords</span></code> field of a <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, then
function <a class="reference internal" href="#core.gridprocessing.testgrids.twister" title="core.gridprocessing.testgrids.twister"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">twister</span></code></a> invalidates any pre-computed face areas and cell
volues (and other fields).  Consequently, function <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>
must be called <em>after</em> a call to function <a class="reference internal" href="#core.gridprocessing.testgrids.twister" title="core.gridprocessing.testgrids.twister"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">twister</span></code></a>.</p>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">]);</span>
<span class="n">G</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span> <span class="p">=</span> <span class="n">twister</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
<span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">volumes</span><span class="p">,</span> <span class="s">&#39;EdgeColor&#39;</span><span class="p">,</span> <span class="s">&#39;k&#39;</span><span class="p">),</span> <span class="nb">colorbar</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <a class="reference internal" href="#core.gridprocessing.cartGrid" title="core.gridprocessing.cartGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartGrid</span></code></a>.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="parameters-states-and-forces">
<h2>Parameters, states and forces<a class="headerlink" href="#parameters-states-and-forces" title="Permalink to this headline"></a></h2>
<div class="section" id="module-core.solvers">
<span id="input-to-solvers"></span><h3>Input to solvers<a class="headerlink" href="#module-core.solvers" title="Permalink to this headline"></a></h3>
<dl class="mat script">
<dt class="sig sig-object mat" id="core.solvers.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.solvers.Contents" title="Permalink to this definition"></a></dt>
<dd><p>Routines for computing transmissibilities and defining initial states</p>
<dl class="simple">
<dt>Files</dt><dd><p>accumulateCartesianMultipliers - Compute Face Multipliers From Collection of Cell/Face Multipliers
computeTrans                   - Compute transmissibilities.
getFaceTransmissibility        - Compute face transmissibilities, accounting for input-specific multipliers
initResSol                     - Initialise incompressible reservoir solution data structure
initState                      - Initialise state object for reservoir and wells.
initWellSol                    - Initialize well solution data structure.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.solvers.accumulateCartesianMultipliers">
<span class="sig-name descname"><span class="pre">accumulateCartesianMultipliers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">mult</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.solvers.accumulateCartesianMultipliers" title="Permalink to this definition"></a></dt>
<dd><p>Compute Face Multipliers From Collection of Cell/Face Multipliers</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">faceMult</span> <span class="p">=</span> <span class="n">accumulateCartesianMultipliers</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cellFaceMult</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure.  Must identify Cardinal/Cartesian
direction in column 2 of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.faces</span></code>.  Typically
created by construction function <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a> or
<a class="reference internal" href="#core.gridprocessing.tensorGrid" title="core.gridprocessing.tensorGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tensorGrid</span></code></a>.</p></li>
<li><p><strong>cellFaceMult</strong> – <p>Collection of multipliers defined in terms of pairs of
cells and Cardinal directions.  Structure with one or
more of the following fields, each assumed to be numeric
arrays of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.num</span></code> or <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PROD(G.cartDims)</span></code> elements:</p>
<blockquote>
<div><ul>
<li><p>x and <a href="#id39"><span class="problematic" id="id40">x_</span></a>: Multipliers per cell in cell’s positive
and negative X directions respectively.</p></li>
<li><p>y and <a href="#id41"><span class="problematic" id="id42">y_</span></a>: Multipliers per cell in cell’s positive
and negative Y directions respectively.</p></li>
<li><p>z and <a href="#id43"><span class="problematic" id="id44">z_</span></a>: Multipliers per cell in cell’s positive
and negative Z directions respectively.</p></li>
</ul>
</div></blockquote>
<p>This multiplier structure often corresponds to the
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">rock.multipliers</span></code> field generated by <a class="reference internal" href="#core.params.rock.grdecl2Rock" title="core.params.rock.grdecl2Rock"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl2Rock</span></code></a> or
similar functions.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>faceMult</strong> – Numeric array, size <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.num</span></code>-by-1, of aggregate
multiplier values.  In particular, the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code>-th element is the
product of all multiplier values from the input data that
apply to grid face <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code>.  This value is guaranteed to be one
(1) if no input multiplier applies to the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code>-th grid face.</p>
<p>If there either are no multipliers in the input array at all
or if the input grid does not identify Cartesian directions
then faceMult is an empty array of size <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.num</span></code>-by-0.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Input &#39;NORNE&#39; dataset and build a grid and a rock structure for it.</span>
<span class="c">% This structure contains transmissibility multipliers in the positive</span>
<span class="c">% Z direction (MULTZ, downwards).</span>
<span class="c">%</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">readGRDECL</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="n">getDatasetPath</span><span class="p">(</span><span class="s">&#39;NORNE&#39;</span><span class="p">),</span> <span class="s">&#39;NORNE.GRDECL&#39;</span><span class="p">));</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">convertInputUnits</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="n">getUnitSystem</span><span class="p">(</span><span class="s">&#39;METRIC&#39;</span><span class="p">));</span>
<span class="n">G</span>      <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="s">&#39;SplitDisconnected&#39;</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="n">rock</span>   <span class="p">=</span> <span class="n">grdecl2Rock</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">indexMap</span><span class="p">);</span>

<span class="c">% Aggregate multiplier values to grid&#39;s active faces.</span>
<span class="n">mult</span> <span class="p">=</span> <span class="n">accumulateCartesianMultipliers</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">.</span><span class="n">multipliers</span><span class="p">);</span>

<span class="c">% Visualise layered multiplier structure by colouring those faces where</span>
<span class="c">% the total transmissibility multiplier value is less than 0.5 by the</span>
<span class="c">% base 10 logarithm of the total multiplier value.</span>
<span class="c">%</span>
<span class="n">pick</span> <span class="p">=</span> <span class="n">mult</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;FaceColor&#39;</span><span class="p">,</span> <span class="s">&#39;none&#39;</span><span class="p">,</span> <span class="s">&#39;EdgeAlpha&#39;</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="n">plotFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pick</span><span class="p">,</span> <span class="n">log10</span><span class="p">(</span><span class="n">mult</span><span class="p">(</span><span class="n">pick</span><span class="p">)),</span> <span class="s">&#39;FaceAlpha&#39;</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">)</span>
<span class="nb">view</span><span class="p">(</span><span class="o">-</span><span class="mi">300</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span> <span class="nb">axis</span> <span class="n">tight</span><span class="p">,</span> <span class="nb">grid</span> <span class="n">on</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.tensorGrid" title="core.gridprocessing.tensorGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tensorGrid</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <a class="reference internal" href="#core.params.rock.grdecl2Rock" title="core.params.rock.grdecl2Rock"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl2Rock</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.solvers.computeTrans">
<span class="sig-name descname"><span class="pre">computeTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.solvers.computeTrans" title="Permalink to this definition"></a></dt>
<dd><p>Compute transmissibilities.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="p">=</span> <span class="n">computeTrans</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">)</span>
<span class="n">T</span> <span class="p">=</span> <span class="n">computeTrans</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure as described by grid_structure.</p></li>
<li><p><strong>rock</strong> – <p>Rock data structure with valid field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">perm</span></code>.  The permeability
is assumed to be in measured in units of metres squared (m^2).
Use function <a class="reference internal" href="#core.utils.units.darcy" title="core.utils.units.darcy"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">darcy</span></code></a> to convert from darcies to m^2, e.g:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">perm</span> <span class="p">=</span> <span class="n">convertFrom</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">milli</span><span class="o">*</span><span class="n">darcy</span><span class="p">)</span>
</pre></div>
</div>
<p>if the permeability is provided in units of millidarcies.</p>
<p>The field rock.perm may have ONE column for a scalar
permeability in each cell, TWO/THREE columns for a diagonal
permeability in each cell (in 2/3 D) and THREE/SIX columns for a
symmetric full tensor permeability.  In the latter case, each
cell gets the permeability tensor:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">K_i</span> <span class="p">=</span> <span class="p">[</span> <span class="n">k1</span>  <span class="n">k2</span> <span class="p">]</span>      <span class="n">in</span> <span class="n">two</span> <span class="n">space</span> <span class="n">dimensions</span>
      <span class="p">[</span> <span class="n">k2</span>  <span class="n">k3</span> <span class="p">]</span>

<span class="n">K_i</span> <span class="p">=</span> <span class="p">[</span> <span class="n">k1</span>  <span class="n">k2</span>  <span class="n">k3</span> <span class="p">]</span>  <span class="n">in</span> <span class="n">three</span> <span class="n">space</span> <span class="n">dimensions</span>
      <span class="p">[</span> <span class="n">k2</span>  <span class="n">k4</span>  <span class="n">k5</span> <span class="p">]</span>
      <span class="p">[</span> <span class="n">k3</span>  <span class="n">k5</span>  <span class="n">k6</span> <span class="p">]</span>
</pre></div>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>K_system</strong> – Define the system permeability is defined in valid values
are <code class="xref mat mat-func docutils literal notranslate"><span class="pre">xyz</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">loc_xyz</span></code>.</p></li>
<li><p><strong>cellCenters</strong> – Compute transmissibilities based on supplied
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">cellCenters</span></code> rather than default <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.centroids</span></code></p></li>
<li><p><strong>cellFaceCenters</strong> – Compute transmissibilities based on supplied
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">cellFaceCenters</span></code> rather then default
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.centroids(G.cells.faces(:,1),</span> <span class="pre">:)</span></code></p></li>
<li><p><strong>fixNegative</strong> – Take absolute value of negative transmissibilities if
present. This typically happens if the grid cell
geometry is degenerate, for instance with a centroid
outside the cell. Default: true.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>T</strong> – half-transmissibilities for each local face of each grid cell in
the grid.  The number of half-transmissibilities equals the number
of rows in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.faces</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Face normals are assumed to have length equal to the corresponding face
areas. This property is guaranteed by function <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>, <a class="reference internal" href="#core.params.rock.permTensor" title="core.params.rock.permTensor"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">permTensor</span></code></a>, <a class="reference internal" href="#core.params.rock.makeRock" title="core.params.rock.makeRock"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeRock</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.solvers.getFaceTransmissibility">
<span class="sig-name descname"><span class="pre">getFaceTransmissibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.solvers.getFaceTransmissibility" title="Permalink to this definition"></a></dt>
<dd><p>Compute face transmissibilities, accounting for input-specific multipliers</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="p">=</span> <span class="n">getFaceTransmissibility</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">)</span>
<span class="n">T</span> <span class="p">=</span> <span class="n">getFaceTransmissibility</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span>       <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">T</span> <span class="p">=</span> <span class="n">getFaceTransmissibility</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">mult</span><span class="p">)</span>
<span class="n">T</span> <span class="p">=</span> <span class="n">getFaceTransmissibility</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Computes transmissibilities per interface.  Incorporates multipliers if
provided by caller.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Valid grid structure.</p></li>
<li><p><strong>rock</strong> – Valid rock structure.  May contain transmissibility multiplier
information as derived using function <a class="reference internal" href="#core.params.rock.grdecl2Rock" title="core.params.rock.grdecl2Rock"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl2Rock</span></code></a> or similar.
Those multipliers will be applied directly to the resulting face
transmissibility values returned from <a class="reference internal" href="#core.solvers.getFaceTransmissibility" title="core.solvers.getFaceTransmissibility"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getFaceTransmissibility</span></code></a>.</p></li>
<li><p><strong>mult</strong> – <p>User-defined multiplier structure.  This is optional.  If you
don’t need any multipliers in addition to those that exist in
the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">rock</span></code> structure, you do not need to pass this parameter.
Function <a class="reference internal" href="#core.solvers.getFaceTransmissibility" title="core.solvers.getFaceTransmissibility"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getFaceTransmissibility</span></code></a> supports both one-sided
(“half face”) multipliers that are applied before reducing the
transmissibility to per-face values and per-face multipliers
that are applied after the reduction to per-face values.</p>
<dl>
<dt>We support two primary multiplier source types</dt><dd><ul>
<li><p>mult is numeric, shape numel(T)-by-n.  In this case, the</p></li>
</ul>
<p>number of rows is used to infer whether the array contains
one-sided or per-face multipliers.</p>
<ul>
<li><dl>
<dt>mult is structure</dt><dd><ul class="simple">
<li><p>Field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">onesided</span></code>, if present, is one of the following</p></li>
</ul>
<dl>
<dt>types</dt><dd><ul>
<li><p>numeric, shape size(G.cells.faces,1)-by-n</p></li>
<li><dl>
<dt>structure with one or both of the field types</dt><dd><ul class="simple">
<li><p>direct: numeric, shape size(G.cells.faces,1)-by-n</p></li>
<li><p>face and value: Sparse representation.  Elements of</p></li>
</ul>
<p>’face’ are treated as face indices and the elements
of ‘value’ are treated as numeric multiplier values.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<ul>
<li><p>Field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">face</span></code>, if present, is one of the following types
* numeric, shape G.faces.num-by-n</p>
<ul>
<li><dl>
<dt>structure with one or both of the field types</dt><dd><ul class="simple">
<li><p>direct: numeric, shape G.faces.num-by-n</p></li>
<li><p>cellface and value: Sparse representation. Elements</p></li>
</ul>
<p>of ‘cellface’ are treated as cell-face indices and
the elements of ‘value’ are treated as multiplier
values.</p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>All additional ‘key’/value parameters are passed directly on to</strong></p></li>
<li><p><strong>underlying function `computeTrans`.</strong></p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>T</strong> – Transmissibilities, one per interface, including boundary faces if
present in the input grid <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.solvers.computeTrans" title="core.solvers.computeTrans"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeTrans</span></code></a>, <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.solvers.initResSol">
<span class="sig-name descname"><span class="pre">initResSol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">p0</span></em>, <em class="sig-param"><span class="pre">s0</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.solvers.initResSol" title="Permalink to this definition"></a></dt>
<dd><p>Initialise incompressible reservoir solution data structure</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">initResSol</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">initResSol</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>p0</strong> – Initial reservoir pressure.  Scalar or a G.cells.num-by-1 vector.</p></li>
<li><p><strong>s0</strong> – Initial reservoir saturation.  A 1-by-(number of phases) vector
or a (G.cells.num)-by-(number of phases) array.
Default value: s0 = 0 (single phase).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – Initialized reservoir solution structure having fields
- pressure – One scalar pressure value for each cell in ‘G’.
- flux     – One Darcy flux value for each face in ‘G’.
- s        – Phase saturations for all phases in each cell.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the case of a <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">3</span></code> array of fluid saturations,
state.s, the columns are generally interpreted as</p>
<blockquote>
<div><p>1 &lt;-&gt; Aqua, 2 &lt;-&gt; Liquid, 3 &lt;-&gt; Vapour</p>
</div></blockquote>
<p>Single pressures (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">p0</span></code>) and initial phase saturations (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">s0</span></code>) are repeated
uniformly for all grid cells.</p>
<p>The initial Darcy flux is zero throughout the reservoir.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.solvers.initWellSol" title="core.solvers.initWellSol"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initWellSol</span></code></a>, <a class="reference internal" href="incomp.html#incomp.incompTPFA" title="incomp.incompTPFA"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">incompTPFA</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.solvers.initState">
<span class="sig-name descname"><span class="pre">initState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">p0</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.solvers.initState" title="Permalink to this definition"></a></dt>
<dd><p>Initialise state object for reservoir and wells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="p">=</span> <span class="n">initState</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span>
<span class="n">state</span> <span class="p">=</span> <span class="n">initState</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure.</p></li>
<li><p><strong>W</strong> – Well structure.  Pass an empty array for models without wells.</p></li>
<li><p><strong>p0</strong> – Initial reservoir pressure.  Also used as initial well BHP.</p></li>
<li><p><strong>s0</strong> – Initial reservoir composition (saturation).  If the model contains
wells, then the number of declared components in the injected well
fluids must equal the number of declared components in the
reservoir fluids.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>state</strong> – Initial reservoir (and well) state object.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.solvers.initWellSol">
<span class="sig-name descname"><span class="pre">initWellSol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">p0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.solvers.initWellSol" title="Permalink to this definition"></a></dt>
<dd><p>Initialize well solution data structure.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">wellSol</span> <span class="p">=</span> <span class="n">initWellSol</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Initialize the well solution structure to uniform well bottom-hole
pressures and all-zero well rates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> – Well data structure as defined by addWell &amp;c.</p></li>
<li><p><strong>p0</strong> – Initial uniform well bottom-hole pressure (scalar).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wellSol</strong> – Initialized reservoir solution structure having fields
- flux     – Well rates in all perforations (== 0).
- pressure – Well bottom-hole pressure (== p0).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.solvers.initResSol" title="core.solvers.initResSol"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initResSol</span></code></a>, <a class="reference internal" href="mimetic.html#mimetic.solveIncompFlow" title="mimetic.solveIncompFlow"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solveIncompFlow</span></code></a>.</p>
</div>
</dd></dl>

<span class="target" id="module-core.params"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.params.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.params.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>PARAMS</dt><dd><p>Functions for setting simulation parameters</p>
</dd>
<dt>Files</dt><dd><p>gravity - Manage effects of gravity.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.gravity">
<span class="sig-name descname"><span class="pre">gravity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.gravity" title="Permalink to this definition"></a></dt>
<dd><p>Manage effects of gravity.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Either</span> <span class="n">of</span> <span class="n">the</span> <span class="n">modes</span>
  <span class="mi">1</span><span class="p">)</span>     <span class="n">gravity</span><span class="p">()</span>
  <span class="mi">2</span><span class="p">)</span>     <span class="n">gravity</span><span class="p">(</span><span class="nb">arg</span><span class="p">)</span>
  <span class="mi">3</span><span class="p">)</span>     <span class="n">gravity</span> <span class="n">arg1</span> <span class="n">arg2</span> <span class="p">...</span>
  <span class="mi">4</span><span class="p">)</span> <span class="n">g</span> <span class="p">=</span> <span class="n">gravity</span><span class="p">(</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> – <p>Control mode for effect of gravity.  OPTIONAL. Must be one of</p>
<ul>
<li><p>String, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'off',</span> <span class="pre">'on'}</span></code>, for disabling or enabling effects
of gravity.  The default state is ‘off’.</p></li>
<li><p>String <code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'x',</span> <span class="pre">'y',</span> <span class="pre">'z'}</span></code>.  The string ‘&lt;p&gt;’ sets the gravity
direction to point along the positive physical coordinate
direction ‘&lt;p&gt;’ of the underlying grid model.</p>
<p>The default direction in function ‘gravity’ is ‘z’.  In other
words, the gravity by default field points along the positive
Z axis of the underlying grid model.</p>
</li>
<li><p>String, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">'reset'</span></code>, for restoring effects of gravity to the
default state: gravity off, but acceleration strength
nevertheless as at the Tellus equator, in the direction
‘z’.  Note that the gravity vector returned in call mode 2)
will be the zero vector unless effects of gravity are
specifically enabled.</p></li>
<li><p>Logical, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">{</span> <span class="pre">false,</span> <span class="pre">true</span> <span class="pre">}</span></code>, for disabling or enabling effects
of gravity.</p></li>
<li><p>Numeric (Real) scalar value.  Specifically set acceleration
strength.  The value is assumed to be in units of m/s^2.
However, unless effects of gravity are specifically enabled,
clients (those using call mode 2) will still retrieve a zero
gravity vector.</p></li>
<li><p>Numeric (Real) two- or three-component real vector giving
explicit gravity vector.  In this case, the acceleration
strength is NORM(v) in units of m/s^2.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>g</strong> – A three-component <em>ROW</em> vector defining the current gravity field.
The Euclidian norm of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">g</span></code> is the acceleration strength, in units
of m/s^2, of the gravity field.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>String arguments may be combined together.  Later control modes
override former. The default state, unless changed using a call from
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">gravity</span> <span class="pre">on</span></code>, is to disable all effects of gravity.  In other words,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">gravity</span> <span class="pre">off</span></code> is the default state of gravity effects.</p>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Demonstrate &#39;String&#39; form (Command and Function syntax).</span>
<span class="n">gravity</span> <span class="n">x</span> <span class="n">on</span>   <span class="c">% Enable gravity (of default strength).</span>
<span class="n">gravity</span><span class="p">(</span><span class="s">&#39;off&#39;</span><span class="p">)</span> <span class="c">% Disable gravity (default state).</span>
<span class="n">gravity</span> <span class="nb">reset</span>  <span class="c">% Restore gravity defaults (off).</span>
<span class="n">gravity</span> <span class="n">x</span>      <span class="c">% Set gravity direction along x-axis of current model.</span>

<span class="c">% 2) Demonstrate &#39;Logical&#39; form of gravity function.</span>
<span class="c">%    (only Function syntax supported in this case).</span>
<span class="n">gravity</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>  <span class="c">% Enable gravity.</span>
<span class="n">gravity</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="c">% Disable gravity (default state).</span>

<span class="c">% 3) Demonstrate &#39;Numeric&#39; form of gravity function.</span>
<span class="c">%    (only Function syntax supported in this case).</span>
<span class="n">gravity</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>   <span class="c">% Set acceleration strength to 1 m/s^2.</span>
<span class="n">gravity</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>   <span class="c">% Set acceleration strength to 0 m/s^2 (i.e., disable).</span>
<span class="c">% Gravity field along direction [1,1] of underlying grid model.</span>
<span class="c">% Acceleration strength of SQRT(2) m/s^2.</span>
<span class="n">gravity</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="c">% Set gravity field along direction [1,1,-10] of underlying grid model.</span>
<span class="c">% Acceleration strength of SQRT(102) m/s^2.</span>
<span class="n">gravity</span><span class="p">([</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">10</span><span class="p">])</span>

<span class="c">% 4) Retrieve current gravity vector field.</span>
<span class="c">%    (Only function syntax supported in this case).</span>
<span class="n">g</span> <span class="p">=</span> <span class="n">gravity</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-core.params.rock">
<span id="petrophysical-properties"></span><h3>Petrophysical properties<a class="headerlink" href="#module-core.params.rock" title="Permalink to this headline"></a></h3>
<dl class="mat script">
<dt class="sig sig-object mat" id="core.params.rock.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.params.rock.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>ROCK</dt><dd><p>Routines related to rock data (permeability and porosity).</p>
</dd>
<dt>Files</dt><dd><p>gaussianField         - Compute realization of lognormal, isotropic permeability field.
grdecl2Rock           - Extract rock properties from input deck (grdecl structure)
logNormLayers         - Compute realization of lognormal, isotropic permeability field.
makeRock              - Create rock structure from given permeabilty and porosity values
permeabilityConverter - Add tensor permeability to GRDECL struct
permTensor            - Expand permeability tensor to full format.
poreVolume            - Compute pore volumes of individual cells in grid.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.rock.gaussianField">
<span class="sig-name descname"><span class="pre">gaussianField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">N</span></em>, <em class="sig-param"><span class="pre">vals</span></em>, <em class="sig-param"><span class="pre">sz</span></em>, <em class="sig-param"><span class="pre">std</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.rock.gaussianField" title="Permalink to this definition"></a></dt>
<dd><p>Compute realization of lognormal, isotropic permeability field.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">p</span>  <span class="p">=</span> <span class="n">gaussianField</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">p</span>  <span class="p">=</span> <span class="n">gaussianField</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
<span class="n">p</span>  <span class="p">=</span> <span class="n">gaussianField</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="nb">size</span><span class="p">)</span>
<span class="n">p</span>  <span class="p">=</span> <span class="n">gaussianField</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="nb">size</span><span class="p">,</span> <span class="nb">std</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function creates an approximate Gaussian random field with
dimensions given by N. The field is generated by convolving a normal
distributed random field with a Gaussian filter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> – Three-element vector, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[nx,</span> <span class="pre">ny,</span> <span class="pre">nz]</span></code>, specifying the number of
discrete values in the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">y</span></code>, and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">z</span></code> coordinate directions
respectively.</p></li>
<li><p><strong>VALS</strong> – Target interval for the values of the random field</p></li>
<li><p><strong>SIZE</strong> – Sets the size of the convolution kernel. Default value is
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">[3,3,3]</span></code>. If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SIZE</span></code> is a scalar,  the size is interpreted as
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">[SIZE</span> <span class="pre">SIZE</span> <span class="pre">SIZE].</span></code> The convolution kernel must be specified so
that numel(SIZE)&gt;=numel(N).</p></li>
<li><p><strong>STD</strong> – Standard deviation used in the Gaussian filter (default: 0.65)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – The scalar <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nx</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ny</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nz</span></code> Gaussian random field</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.rock.grdecl2Rock">
<span class="sig-name descname"><span class="pre">grdecl2Rock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.rock.grdecl2Rock" title="Permalink to this definition"></a></dt>
<dd><p>Extract rock properties from input deck (grdecl structure)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">rock</span> <span class="p">=</span> <span class="n">grdecl2Rock</span><span class="p">(</span><span class="n">grdecl</span><span class="p">)</span>
<span class="n">rock</span> <span class="p">=</span> <span class="n">grdecl2Rock</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="n">actmap</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grdecl</strong> – Raw input data in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">GRDECL</span></code> form (typically corresponding to
values from the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">GRID</span></code> section of an ECLIPSE or FrontSim input
deck.</p></li>
<li><p><strong>actmap</strong> – <p>Active-to-global cell mapping.  An n-by-1 array of global cell
indices.  Specifically, actmap(i) is the linearized Cartesian
index of the global cell (from the nx-by-ny-by-nz bounding
box) corresponding to active cell <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code>.</p>
<p>OPTIONAL.  Default value corresponds to treating all input
values as corresponding to active grid cells.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>rock</strong> – Rock data stucture suitable for passing to function
<a class="reference internal" href="#core.params.rock.permTensor" title="core.params.rock.permTensor"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">permTensor</span></code></a>.  Specifically, function <a class="reference internal" href="#core.params.rock.grdecl2Rock" title="core.params.rock.grdecl2Rock"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl2Rock</span></code></a> assigns the
permeability tensor values, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">rock.perm</span></code>.  Moreover, the
following data values will be assigned if present in the input
deck:</p>
<blockquote>
<div><ul class="simple">
<li><p>poro – Porosity values.  Corresponds to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PORO</span></code> keyword.</p></li>
<li><p>ntg  – Net-to-gross values.  Corresponds to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">NTG</span></code> keyword.</p></li>
</ul>
</div></blockquote>
<p>If, additionally, the input ‘grdecl’ structure contains
transmissibility multiplier data (keywords ‘MULTX’, ‘MULTY’,
‘MULTZ’, ‘MULTX-‘, ‘MULTY-‘, ‘MULTZ-‘), then those values will
be stored as individual fields in a substructure ‘multipliers’.
The field names are lower case without ‘MULT’ and hypens are
replaced by underscores.  For instance, the ‘MULTX-‘ data will
be stored as</p>
<blockquote>
<div><ul class="simple">
<li><p><a href="#id45"><span class="problematic" id="id46">rock.multipliers.x_</span></a></p></li>
</ul>
</div></blockquote>
<p>Furthermore, if the input ‘grdecl’, structure contains fault
multiplier data (both of the keywords ‘FAULTS’ and ‘MULTFLT’),
then those values will be copied verbatim to a substructure
‘faultdata’ and retain their original field names, converted to
lower case, in this substructure.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Function <a class="reference internal" href="#core.params.rock.grdecl2Rock" title="core.params.rock.grdecl2Rock"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl2Rock</span></code></a> only extracts the raw data values from the input
vectors.  The caller will have to perform any required unit conversion
separately, possibly aided by functions <a class="reference internal" href="#core.utils.inout.convertInputUnits" title="core.utils.inout.convertInputUnits"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertInputUnits</span></code></a> and
<a class="reference internal" href="#core.utils.units.convertFrom" title="core.utils.units.convertFrom"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertFrom</span></code></a>.</p>
<p>For backwards compatibility, the caller may pass a valid grid_structure
as the second parameter (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">actmap</span></code>) of function <a class="reference internal" href="#core.params.rock.grdecl2Rock" title="core.params.rock.grdecl2Rock"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl2Rock</span></code></a>.  In this
case, the field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure.cells.indexMap</span></code> (if present and
non-empty) will be used in place of the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">actmap</span></code> array described above.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <a class="reference internal" href="#core.params.rock.permTensor" title="core.params.rock.permTensor"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">permTensor</span></code></a>, <a class="reference internal" href="#core.utils.inout.convertInputUnits" title="core.utils.inout.convertInputUnits"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertInputUnits</span></code></a>, <a class="reference internal" href="#core.utils.units.convertFrom" title="core.utils.units.convertFrom"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertFrom</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.rock.logNormLayers">
<span class="sig-name descname"><span class="pre">logNormLayers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">N</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.rock.logNormLayers" title="Permalink to this definition"></a></dt>
<dd><p>Compute realization of lognormal, isotropic permeability field.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">K</span>     <span class="p">=</span> <span class="n">logNormLayers</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="p">[</span><span class="n">K</span><span class="p">,</span><span class="n">L</span><span class="p">]</span> <span class="p">=</span> <span class="n">logNormLayers</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="p">[</span><span class="n">K</span><span class="p">,</span><span class="n">L</span><span class="p">]</span> <span class="p">=</span> <span class="n">logNormLayers</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function creates a nx-by-ny-by-nz scalar permeability field
consisting of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">M</span></code> layers. If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">M</span></code> is a vector, then the number of layers
equals <code class="xref mat mat-func docutils literal notranslate"><span class="pre">numel(M)</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">M</span></code> gives the desired mean for each layer. If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">L</span></code>
is given, we assume that <code class="xref mat mat-func docutils literal notranslate"><span class="pre">M</span></code> gives the desired mean values of each
layer and then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">numel(M)=numel(L)-1</span></code>.</p>
<p>The gaussian field within each layer is generated based on the
formulas:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="p">=</span> <span class="n">smooth3</span><span class="p">(</span><span class="nb">randn</span><span class="p">(..)</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="nb">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">std</span><span class="p">);</span>
<span class="n">k</span> <span class="p">=</span> <span class="nb">exp</span><span class="p">(</span> <span class="n">b</span> <span class="o">+</span> <span class="n">sigma</span><span class="o">*</span><span class="n">k</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="xref mat mat-func docutils literal notranslate"><span class="pre">a</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">b</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sigma</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sz</span></code>, and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">std</span></code> are optional parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> – Three-element vector, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[nx,</span> <span class="pre">ny,</span> <span class="pre">nz]</span></code>, specifying the number of
discrete values in the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">y</span></code>, and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">z</span></code> coordinate
directions respectively.</p></li>
<li><p><strong>M</strong> – The number of layers if a scalar and the desired means of the
layers if a vector.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>‘Verbose’</strong> – Whether or not to emit progress reports during the
computation.
Logical.  Default value: <a class="reference internal" href="#core.utils.mrstVerbose" title="core.utils.mrstVerbose"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstVerbose</span></code></a>.</p></li>
<li><p><strong>‘indices’</strong> –</p>
<dl class="simple">
<dt>List <code class="xref mat mat-func docutils literal notranslate"><span class="pre">L</span></code> of k-indices for the generated layers, given such</dt><dd><p>that layer &lt;i&gt; is represented by k-indices <code class="xref mat mat-func docutils literal notranslate"><span class="pre">L(i):L(i+1)-1</span></code>
in the grid. The number of layers must agree with the
specification of means in the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">M</span></code> parameter.
Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[]</span></code></p>
</dd>
</dl>
<p>‘sigma   - Scalar. Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">2</span></code></p>
<p>‘a’      - Scalar. Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">0.6</span></code></p>
<p>‘b’      - Scalar. Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">2</span></code></p>
<p>‘sz’     - Gaussian mask. Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[9,3,3]</span></code></p>
<p>‘std’    - Standard deviation. Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">4.5</span></code></p>
</li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>K</strong> – The scalar nx-by-ny-by-nz permeability field in units mD</p></li>
<li><p><strong>L</strong> – list of indices for the layers in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">K</span></code>, so that layer <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> has
k-indices=`L(i):L(i+1)-1`</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.rock.makeRock">
<span class="sig-name descname"><span class="pre">makeRock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">perm</span></em>, <em class="sig-param"><span class="pre">poro</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.rock.makeRock" title="Permalink to this definition"></a></dt>
<dd><p>Create rock structure from given permeabilty and porosity values</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">rock</span> <span class="p">=</span> <span class="n">makeRock</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">poro</span><span class="p">)</span>
<span class="n">rock</span> <span class="p">=</span> <span class="n">makeRock</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">poro</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid for which to construct a rock property structure.</p></li>
<li><p><strong>perm</strong> – <p>Permeability field.  Supported input is:
- A scalar.  Interpreted as uniform, scalar (i.e.,</p>
<blockquote>
<div><p>homogenous and isotropic) permeability field repeated for
all active cells in the grid G.</p>
</div></blockquote>
<ul>
<li><p>A row vector of 1/2/3 columns in two space dimensions or
1/3/6 in columns three space dimensions.  The row vector
will be repetead for each active cell in the grid G and
therefore interpreted as a uniform (i.e., a homogeneous),
possibly anisotropic, permeability field.</p></li>
<li><p>A matrix with column count as above, but with
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.num</span></code> rows in total.  This input will be treated
as per-cell values, resulting in heterogeneous
permeability.</p></li>
</ul>
</p></li>
<li><p><strong>poro</strong> – Porosity field.  Can be either a single, scalar value or a
column vector with one entry per cell.  Non-positive values
will result in a warning.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘ntg’</strong> – Net-to-gross factor.  Either a single scalar value that is
repeated for all active cells, or a column vector with one
entry per cell.  <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ntg</span></code> acts as a multiplicative factor on
porosity when calculating pore volumes. Typically in the range
[0 .. 1].</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>rock</strong> – Valid rock with properties for each active cell in the grid.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

<span class="n">r1</span> <span class="p">=</span> <span class="n">makeRock</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">milli</span><span class="o">*</span><span class="n">darcy</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="n">r2</span> <span class="p">=</span> <span class="n">makeRock</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span> <span class="p">]</span><span class="o">*</span><span class="n">milli</span><span class="o">*</span><span class="n">darcy</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>

<span class="n">K</span>   <span class="p">=</span> <span class="n">logNormLayers</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">,</span> <span class="nb">repmat</span><span class="p">([</span><span class="mi">400</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]));</span>
<span class="n">phi</span> <span class="p">=</span> <span class="n">gaussianField</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cartDims</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]);</span>
<span class="n">ntg</span> <span class="p">=</span> <span class="nb">rand</span><span class="p">([</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
<span class="n">r3</span>  <span class="p">=</span> <span class="n">makeRock</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">convertFrom</span><span class="p">(</span><span class="n">K</span><span class="p">(:),</span> <span class="n">milli</span><span class="o">*</span><span class="n">darcy</span><span class="p">),</span> <span class="n">phi</span><span class="p">(:),</span> <span class="s">&#39;ntg&#39;</span><span class="p">,</span> <span class="n">ntg</span><span class="p">)</span>

<span class="n">plotCellData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">poreVolume</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">r3</span><span class="p">)),</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">axis</span> <span class="n">tight</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.solvers.computeTrans" title="core.solvers.computeTrans"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeTrans</span></code></a>, <a class="reference internal" href="#core.params.rock.poreVolume" title="core.params.rock.poreVolume"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">poreVolume</span></code></a>, <a class="reference internal" href="#core.params.rock.permTensor" title="core.params.rock.permTensor"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">permTensor</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.rock.permTensor">
<span class="sig-name descname"><span class="pre">permTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.rock.permTensor" title="Permalink to this definition"></a></dt>
<dd><p>Expand permeability tensor to full format.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">K</span>        <span class="p">=</span> <span class="n">permTensor</span><span class="p">(</span><span class="n">rock</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

<span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="p">=</span> <span class="n">permTensor</span><span class="p">(</span><span class="n">rock</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rock</strong> – <p>Rock data structure with valid field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">perm</span></code>–one value of the
permeability tensor for each cell (nc) in the discretised model.</p>
<p>The field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">rock.perm</span></code> may have ONE column for a scalar
(isotropic) permeability in each cell, TWO or THREE columns for
a diagonal permeability in each cell (in two or three space
dimensions, respectively) and THREE or SIX columns for a
symmetric, full tensor permeability.  In the latter case, each
cell gets the permeability tensor:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">K_i</span> <span class="p">=</span> <span class="p">[</span> <span class="n">k1</span>  <span class="n">k2</span> <span class="p">]</span>      <span class="n">in</span> <span class="n">two</span> <span class="n">space</span> <span class="n">dimensions</span>
      <span class="p">[</span> <span class="n">k2</span>  <span class="n">k3</span> <span class="p">]</span>

<span class="n">K_i</span> <span class="p">=</span> <span class="p">[</span> <span class="n">k1</span>  <span class="n">k2</span>  <span class="n">k3</span> <span class="p">]</span>  <span class="n">in</span> <span class="n">three</span> <span class="n">space</span> <span class="n">dimensions</span>
      <span class="p">[</span> <span class="n">k2</span>  <span class="n">k4</span>  <span class="n">k5</span> <span class="p">]</span>
      <span class="p">[</span> <span class="n">k3</span>  <span class="n">k5</span>  <span class="n">k6</span> <span class="p">]</span>
</pre></div>
</div>
</p></li>
<li><p><strong>dim</strong> – Number of space dimensions in the discretised model.  Must be
two or three.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul>
<li><p><strong>K</strong> – Expanded permeability tensor.  An <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nc</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dim^2</span></code> array of
permeability values as described above.</p></li>
<li><p><strong>r, c</strong> –</p>
<p>Row- and column indices from which the two-form</p>
<blockquote>
<div><p>(x, Ky) = sum_r sum_c x(r) * K(r,c) * y(c)</p>
</div></blockquote>
<p>may be easily evaluated by a single call to SUM (see EXAMPLE).
OPTIONAL.  Only returned if specifically requested.</p>
</li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Compute n&#39;Kg gravity term on each cell face (half contact).</span>
<span class="c">%</span>
<span class="n">cellNo</span> <span class="p">=</span> <span class="n">rldecode</span><span class="p">(</span><span class="mi">1</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="nb">diff</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">facePos</span><span class="p">),</span> <span class="mi">2</span><span class="p">).</span><span class="o">&#39;</span><span class="p">;</span>
<span class="n">sgn</span>    <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="nb">double</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">faces</span><span class="p">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">faces</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">cellNo</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="c">% cfn  = cell-face normal = *outward* face normals on each cell.</span>
<span class="n">cfn</span>    <span class="p">=</span> <span class="nb">bsxfun</span><span class="p">(@</span><span class="nb">times</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">faces</span><span class="p">.</span><span class="n">normals</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">faces</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span> <span class="p">:),</span> <span class="n">sgn</span><span class="p">);</span>

<span class="n">dim</span>    <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">nodes</span><span class="p">.</span><span class="n">coords</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="p">=</span> <span class="n">permTensor</span><span class="p">(</span><span class="n">rock</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>

<span class="n">g</span>   <span class="p">=</span> <span class="n">gravity</span><span class="p">();</span>   <span class="n">g</span> <span class="p">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="mi">1</span> <span class="p">:</span> <span class="n">dim</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]);</span>
<span class="n">nKg</span> <span class="p">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cfn</span><span class="p">(:,</span><span class="n">r</span><span class="p">)</span> <span class="o">.*</span> <span class="nb">bsxfun</span><span class="p">(@</span><span class="nb">times</span><span class="p">,</span> <span class="n">K</span><span class="p">(</span><span class="n">cellNo</span><span class="p">,:),</span> <span class="n">g</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.solvers.computeTrans" title="core.solvers.computeTrans"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeTrans</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.rock.permeabilityConverter">
<span class="sig-name descname"><span class="pre">permeabilityConverter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.rock.permeabilityConverter" title="Permalink to this definition"></a></dt>
<dd><p>Add tensor permeability to GRDECL struct</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">permeabilityConverter</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – struct representing the grdecl file with permeability modified or possibly new extra fields <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PERMXY</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PERMZX</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PERMYZ</span></code>.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘K_system’</strong> – String defining the interpretation of the permeability
tensor. Broadly speaking, this has to do with the
interpretation as a tensor either in coordinate space or
some other transformed space such as logical indices.
Possible choices:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘xyz’ the coordinate system (DEFAULT)</p></li>
<li><p>‘cell’ the cell system defined by direction between
centroids of the logical cell.</p></li>
<li><p>‘bedding_plane’ the same above for xy direction but
use the cross product of these direction for z
direction</p></li>
<li><p>‘bedding_plane_normal’ the same as above but now the
xy system is made orthogonal</p></li>
</ul>
</div></blockquote>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – Updated grdecl with modified <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PERM*</span></code> fields</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl2rock</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.rock.poreVolume">
<span class="sig-name descname"><span class="pre">poreVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.rock.poreVolume" title="Permalink to this definition"></a></dt>
<dd><p>Compute pore volumes of individual cells in grid.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">pv</span> <span class="p">=</span> <span class="n">poreVolume</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.
Must contain valid field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.volumes</span></code>.</p></li>
<li><p><strong>rock</strong> – Rock data structure.
Must contain valid field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">rock.poro</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pv</strong> – Vector of size <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.num</span></code> by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">1</span></code> of pore volumes for each
individual cell in the grid.  This typically amounts to the
expression <code class="xref mat mat-func docutils literal notranslate"><span class="pre">rock.poro</span> <span class="pre">.*</span> <span class="pre">G.cells.volumes</span></code>, but the function
handles non-unit net-to-gross factors as well.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>, <a class="reference internal" href="#core.params.rock.makeRock" title="core.params.rock.makeRock"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeRock</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="wells-boundary-conditions-and-source-terms">
<h3>Wells, boundary conditions and source terms<a class="headerlink" href="#wells-boundary-conditions-and-source-terms" title="Permalink to this headline"></a></h3>
<span class="target" id="module-core.params.wells_and_bc"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.params.wells_and_bc.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.params.wells_and_bc.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>WELLS_AND_BC</dt><dd><p>Support for wells and boundary conditions.</p>
</dd>
<dt>Files</dt><dd><p>addBC        - Add boundary condition to (new or existing) BC object
addSource    - Add an explicit source to (new or existing) source object.
addWell      - Insert a well into the simulation model.
fluxside     - Impose flux boundary condition on global side.
pside        - Impose pressure boundary condition on global side.
psideh       - Impose hydrostatic pressure boundary condition on global side.
verticalWell - Insert a vertical well into the simulation model.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.wells_and_bc.addBC">
<span class="sig-name descname"><span class="pre">addBC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">bc</span></em>, <em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">t</span></em>, <em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.wells_and_bc.addBC" title="Permalink to this definition"></a></dt>
<dd><p>Add boundary condition to (new or existing) BC object</p>
<p>There can only be a single boundary condition per face in the grid.
Solvers assume boundary conditions are given on the boundary; conditions
in the interior of the domain yield unpredictable results and is not
officially supported. Faces with no boundary conditions are generally
interpreted as no-flux boundary conditions for all phases.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">bc</span> <span class="p">=</span> <span class="n">addBC</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">addBC</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bc</strong> – Boundary condition structure from a prior call to <a class="reference internal" href="#core.params.wells_and_bc.addBC" title="core.params.wells_and_bc.addBC"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addBC</span></code></a>
which will be updated on output or an empty array (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">bc==[]</span></code>)
in which case a new boundary condition structure is created.</p></li>
<li><p><strong>faces</strong> – Global faces in external model for which this boundary
condition should be applied.</p></li>
<li><p><strong>type</strong> – Type of boundary condition.  Supported values are ‘pressure’
and ‘flux’, or cell array of such strings.</p></li>
<li><p><strong>values</strong> – <p>Boundary condition value.  Interpreted as a pressure value (in
units of ‘Pa’) when <code class="xref mat mat-func docutils literal notranslate"><span class="pre">type=='pressure'</span></code> and as a flux value (in
units of ‘m^3/s’) when <code class="xref mat mat-func docutils literal notranslate"><span class="pre">type=='flux'</span></code>.  One scalar value for
each face in ‘faces’. If a single value is given, it will be
repeated for all faces.</p>
<p>Note: If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">type=='flux'</span></code>, the values in ‘values’ are interpreted
as injection fluxes (into the reservoir).  Specifically, a
positive value is interpreted as an injection flux.  To
specify an extraction flux (i.e., flux out of the reservoir),
the caller should provide a negative value in ‘values’.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>sat</strong> – Volumetric composition of fluid injected across inflow faces.
An n-by-m array of fluid compositions with ‘n’ being the
number of faces in ‘faces’ and for m=3, the columns
interpreted as 1 &lt;-&gt; Aqua, 2 &lt;-&gt; Liquid, 3 &lt;-&gt; Vapor.
The fractions should sum up to one, i.e. have row-sum of
unity. If a row vector is specified, this vector is used for
all faces in the definition.</p>
<p>This field is for the benefit of transport solvers such as
‘implicitTransport’ and will be ignored for outflow faces.</p>
<p>Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sat</span> <span class="pre">=</span> <span class="pre">1</span></code> (assume single-phase flow).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For convenience, values and sat may contain a single value.  This value
is then used for all faces specified in the call.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bc</strong> – New or updated boundary condition structure having the following
fields:</p>
<blockquote>
<div><ul class="simple">
<li><p>face:  External faces for which explicit BCs are provided.</p></li>
<li><p>type:  Cell array of strings denoting type of BC.</p></li>
<li><p>value: Boundary condition values for all faces in ‘face’.</p></li>
<li><p>sat: Fluid composition of fluids passing through inflow faces.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.params.wells_and_bc.pside" title="core.params.wells_and_bc.pside"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pside</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.fluxside" title="core.params.wells_and_bc.fluxside"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fluxside</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.addSource" title="core.params.wells_and_bc.addSource"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addSource</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a>, <a class="reference internal" href="mimetic.html#mimetic.solveIncompFlow" title="mimetic.solveIncompFlow"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solveIncompFlow</span></code></a>, <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.wells_and_bc.addSource">
<span class="sig-name descname"><span class="pre">addSource</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">c</span></em>, <em class="sig-param"><span class="pre">r</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.wells_and_bc.addSource" title="Permalink to this definition"></a></dt>
<dd><p>Add an explicit source to (new or existing) source object.</p>
<p>There can only be a single net source term per cell in the grid.  This
is now enforced.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">src</span> <span class="p">=</span> <span class="n">addSource</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="n">src</span> <span class="p">=</span> <span class="n">addSource</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> – Source structure from a prior call to ‘addSource’ which will
be updated on output or an empty array (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">src==[]</span></code>) in which
case a new source structure is created.</p></li>
<li><p><strong>cells</strong> – Indices in external model for which this source should be
applied.</p></li>
<li><p><strong>values</strong> – <p>Strength of source.  One scalar value for each cell in
‘cells’.  Note that the values in ‘values’ are interpreted as
flux rates (typically in units of m^3/Day) rather than as flux
density rates (which must be integrated over the cell volumes
in order to obtain flux rates).  Specifically, the mimetic
pressure solvers do not integrate these values.</p>
<p>In the special case that a single value is provided, it will
be assumed valid for all cells in the input.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>sat</strong> – Fluid composition of injected fluid in injection cells.
An n-by-m array of fluid compositions with ‘n’ being the
number of cells in ‘cells’ and ‘m’ the number of components in
the saturation. For m=3, the columns interpreted as</p>
<blockquote>
<div><p>1 &lt;-&gt; Aqua, 2 &lt;-&gt; Liquid, 3 &lt;-&gt; Vapor.</p>
</div></blockquote>
<p>This field is for the benefit of transport solvers such as
<a class="reference internal" href="incomp.html#incomp.transport.implicitTransport" title="incomp.transport.implicitTransport"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">implicitTransport</span></code></a> and will be ignored for production source
cells (i.e. when values &lt; 0).</p>
<p>Default value: sat = [] (assume single-phase flow).</p>
<p>As a special case, if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">size(sat,1)==1</span></code>, then the saturation
value will be repeated for all affected cells defined by the
‘cells’ parameter.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>src</strong> – New or updated source structure having the following fields:
- cell: Cells for which explicit sources are provided
- rate: Rates or values of these explicit sources
- sat:  Fluid composition of injected fluids in injection cells.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">simpleSRCandBC</span><span class="p">.</span><span class="n">m</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.addBC" title="core.params.wells_and_bc.addBC"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addBC</span></code></a>, <a class="reference internal" href="mimetic.html#mimetic.solveIncompFlow" title="mimetic.solveIncompFlow"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solveIncompFlow</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.wells_and_bc.addWell">
<span class="sig-name descname"><span class="pre">addWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">cellInx</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.wells_and_bc.addWell" title="Permalink to this definition"></a></dt>
<dd><p>Insert a well into the simulation model.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="p">=</span> <span class="n">addWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">cellInx</span><span class="p">)</span>
<span class="n">W</span> <span class="p">=</span> <span class="n">addWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="n">cellInx</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> – Well structure or empty if no other wells exist.
Updated upon return.</p></li>
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>rock</strong> – Rock data structure.  Must contain valid field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">perm</span></code>.</p></li>
<li><p><strong>cellInx</strong> – Perforated well cells (vector of cell indices or a logical
mask with length equal to G.cells.num).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>Type</strong> – Well control type. String. Supported values depend on the
solver in question. Most solvers support at least two options:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘bhp’: Controlled by bottom hole pressure (DEFAULT)</p></li>
<li><p>‘rate’: Controlled by total rate.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Val</strong> – Well control target value.  Interpretation of this value is
dependent upon <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Type</span></code>.  Default value is 0.  If the well
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">Type</span></code> is ‘bhp’, then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Val</span></code> is given in unit Pascal and if
the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Type</span></code> is ‘rate’, then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Val</span></code> is given in unit m^3/second.</p></li>
<li><p><strong>Radius</strong> – Well bore radius (in unit of meters).  Either a single,
scalar value which applies to all perforations or a vector of
radii (one radius value for each perforation).
Default value: Radius = 0.1 (i.e., 10 cm).</p></li>
<li><p><strong>Dir</strong> – Well direction.  Single CHAR or CHAR array.  A single CHAR
applies to all perforations while a CHAR array defines the
direction of the corresponding perforation.  In other words,
Dir(i) is the direction in perforation cellInx(i) in the CHAR
array case.</p>
<p>Supported values for a single perforation are ‘x’, ‘y’, or
‘z’ (case insensitive) meaning the corresponding cell is
perforated in the X, Y, or Z direction, respectively.
Default value: Dir = ‘z’ (vertical well).</p>
</li>
<li><p><strong>InnerProduct</strong> – The inner product with which to define the mass matrix.
String.  Default value = ‘ip_tpf’.
Supported values are ‘ip_simple’, ‘ip_tpf’, ‘ip_quasitpf’,
and ‘ip_rt’.</p></li>
<li><p><strong>WI</strong> – Well productivity index. Vector of length <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nc=numel(cellInx)</span></code>.
Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">WI</span> <span class="pre">=</span> <span class="pre">repmat(-1,</span> <span class="pre">[nc,</span> <span class="pre">1])</span></code>, whence the
productivity index will be computed from available grid block
data in grid blocks containing well completions.</p></li>
<li><p><strong>Kh</strong> – Permeability thickness.  Vector of length <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nc=numel(cellInx)</span></code>.
Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Kh</span> <span class="pre">=</span> <span class="pre">repmat(-1,</span> <span class="pre">[nc,</span> <span class="pre">1])</span></code>, whence the thickness
will be computed from available grid block data in grid
blocks containing well completions.</p></li>
<li><p><strong>Skin</strong> – Skin factor for computing effective well bore radius.  Scalar
value or vector of length <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nc=numel(cellInx)</span></code>.
Default value: 0.0 (no skin effect).</p></li>
<li><p><strong>compi</strong> – Fluid phase composition for injection wells.  Vector of phase
volume fractions.
Default value:  <code class="xref mat mat-func docutils literal notranslate"><span class="pre">compi</span> <span class="pre">=</span> <span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0]</span></code> (water injection)</p></li>
<li><p><strong>Sign</strong> – Well type: Production (Sign = -1) or Injection (Sign = 1).
Default value: 0 (Undetermined sign. Will be derived from
rates if possible).</p></li>
<li><p><strong>Name</strong> – Well name (string).
Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sprintf('W%d',</span> <span class="pre">numel(W)</span> <span class="pre">+</span> <span class="pre">1)</span></code></p></li>
<li><p><strong>refDepth</strong> – Reference depth for the well, i.e. the value for which
bottom hole pressures are defined. Defaults to the top of
formation (calculated when refDepth = [])</p></li>
<li><p><strong>calcReprRad</strong> – Whether or not to compute the representative radius of
each perforation.  The representative radius is needed to
derive shear thinning calculations in the context of polymer
injection.  LOGICAL.  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">calcReprRad</span> <span class="pre">=</span> <span class="pre">true</span></code> (do
calculate the representative radius).  If set to false, the
resulting well structure cannot be used to simulate polymer
injection.</p></li>
<li><p><strong>cellDims</strong> – optional cellDims of grid cells</p></li>
<li><p><strong>lineSegments</strong> – nx3 matrix where row k represents x,y, and z-lengths of the
line segment cooresponding to the part of trajectory traversing
cell k. If nonempty, well indices will be computed using the
projected directional well indices, i.e.,</p>
<blockquote>
<div><p>WI^2 = sum_i WI_i^2,  WI_i = (l_i/d_i)*WI(Dir=i), i = x,y,z</p>
</div></blockquote>
<p>where l_i and d_i are the segment length and cell dimention in
direction i, respectively.</p>
</li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>W</strong> – Updated (or freshly created) well structure, each element of which
has the following fields:</p>
<blockquote>
<div><ul class="simple">
<li><p>cells:   Grid cells perforated by this well (== cellInx).</p></li>
<li><p>type:    Well control type (== Type).</p></li>
<li><p>val:     Target control value (== Val).</p></li>
<li><p>r:       Well bore radius (== Radius).</p></li>
<li><p>dir:     Well direction (== Dir).</p></li>
<li><p>WI:      Well productivity index.</p></li>
<li><p>dZ: Displacement of each well perforation measured from
‘highest’ horizontal contact (i.e., the ‘TOP’ contact with the
minimum ‘Z’ value counted amongst all cells perforated by this
well).</p></li>
<li><p>name:    Well name (== Name).</p></li>
<li><p>compi:   Fluid composition–only used for injectors (== Comp_i).</p></li>
<li><p>sign:    Injection (+) or production (-) flag.</p></li>
<li><p>status:  Boolean indicating if the well is open or shut.</p></li>
<li><p>cstatus: One entry per perforation, indicating if the completion is open.</p></li>
<li><p>lims:    Limits for the well. Contains subfields for the types
of limits applicable to the well (bhp, rate, orat, …)
Injectors generally have upper limits, while producers have
lower limits.</p></li>
<li><p>rR:      The representative radius for the wells, which is used
in the shear thinning calculation when polymer is involved in
the simulation.  Empty if ‘calcReprRad’ is false.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">incompTutorialWells</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Wells in one/two-dimensional grids are not well defined in terms of
computing well indices. However, such wells are often useful for
simulation scenarios where the exact value of well indices is not of
great importance. For this reason, we make the following approximations
when addWell is used to compute e.g. horizontal wells in 2D:</p>
<blockquote>
<div><ul class="simple">
<li><p>K_z is assumed to be the harmonic average of K_x and K_y:
K_z = 1/(1/K_x + 1/K_y).</p></li>
<li><p>The depth of a grid block is assumed to be unit length (1 meter)</p></li>
</ul>
</div></blockquote>
<p>This generally produces reasonable ranges for the WI field, but it is
the user’s responsibility to keep these assumptions in mind.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.params.wells_and_bc.verticalWell" title="core.params.wells_and_bc.verticalWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">verticalWell</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.addSource" title="core.params.wells_and_bc.addSource"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addSource</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.addBC" title="core.params.wells_and_bc.addBC"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addBC</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.wells_and_bc.fluxside">
<span class="sig-name descname"><span class="pre">fluxside</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">bc</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">side</span></em>, <em class="sig-param"><span class="pre">flux</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.wells_and_bc.fluxside" title="Permalink to this definition"></a></dt>
<dd><p>Impose flux boundary condition on global side.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">bc</span> <span class="p">=</span> <span class="n">fluxside</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">flux</span><span class="p">)</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">fluxside</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">fluxside</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">)</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">fluxside</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bc</strong> – boundary condition structure as defined by function ‘addBC’.</p></li>
<li><p><strong>G</strong> – Grid structure as described by <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.  Currently
restricted to grids produced by functions <a class="reference internal" href="#core.gridprocessing.cartGrid" title="core.gridprocessing.cartGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartGrid</span></code></a> and
<a class="reference internal" href="#core.gridprocessing.tensorGrid" title="core.gridprocessing.tensorGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tensorGrid</span></code></a> and other grids that add cardinal directions to
<a href="#id33"><span class="problematic" id="id34">`</span></a>G.cells.faces(:, 2) in the same format.</p></li>
<li><p><strong>side</strong> – <p>Global side from which to extract face indices.  String.  Must
(case insensitively) match one of six alias groups:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'West'</span> <span class="pre">,</span> <span class="pre">'XMin',</span> <span class="pre">'Left'</span>&#160; <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'East'</span> <span class="pre">,</span> <span class="pre">'XMax',</span> <span class="pre">'Right'</span> <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'South',</span> <span class="pre">'YMin',</span> <span class="pre">'Back'</span>&#160; <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'North',</span> <span class="pre">'YMax',</span> <span class="pre">'Front'</span> <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'Upper',</span> <span class="pre">'ZMin',</span> <span class="pre">'Top'</span>&#160;&#160; <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'Lower',</span> <span class="pre">'ZMax',</span> <span class="pre">'Bottom'}</span></code></p></li>
</ol>
</div></blockquote>
<p>These groups correspond to the cardinal directions mentioned
as the first alternative in each group.</p>
</p></li>
<li><p><strong>flux</strong> – <p>Total flux, in units of m^3/s, (scalar) accounted for by
faces on side in ranges <code class="xref mat mat-func docutils literal notranslate"><span class="pre">I1</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">I2</span></code>.</p>
<p>Note: The ‘flux’ value is interpreted by the pressure and
transport solvers as an injection flux (into the reservoir).
Specifically, a positive value is interpreted as an injection
flux.  To specify an extraction flux (i.e., flux out of the
reservoir), the caller should provide a negative value in
‘flux’.</p>
</p></li>
<li><p><strong>I1</strong> – Cell index ranges for local (in-plane) axes one and two,
respectively.  An empty index range ([]) is interpreted as
covering the entire corresponding local axis of ‘side’ in the
grid ‘G’.  The local axes on a ‘side’ in ‘G’ are ordered
according to ‘X’ before ‘Y’, and ‘Y’ before ‘Z’.</p></li>
<li><p><strong>I2</strong> – Cell index ranges for local (in-plane) axes one and two,
respectively.  An empty index range ([]) is interpreted as
covering the entire corresponding local axis of ‘side’ in the
grid ‘G’.  The local axes on a ‘side’ in ‘G’ are ordered
according to ‘X’ before ‘Y’, and ‘Y’ before ‘Z’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>sat</strong> – Volumetric composition of fluid injected across inflow faces.
An n-by-m array of fluid compositions with ‘n’ being the
number of faces in ‘faces’ and for m=3, the columns
interpreted as 1 &lt;-&gt; Aqua, 2 &lt;-&gt; Liquid, 3 &lt;-&gt; Vapor.
The fractions should sum up to one, i.e. have row-sum of
unity. If a row vector is specified, this vector is used for
all faces in the definition.</p>
<p>This field is for the benefit of transport solvers such as
‘implicitTransport’ and will be ignored for outflow faces.</p>
<p>Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sat</span> <span class="pre">=</span> <span class="pre">1</span></code> (assume single-phase flow).</p>
</li>
<li><p><strong>range</strong> – Restricts the search for outer faces to a subset of the cells
in the direction perpendicular to that of the face. Example:
if side=’LEFT’, one will only search for outer faces in the
cells with logical indexes [range,:,:].
Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">[]</span></code> (do not restrict search).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bc</strong> – Updated boundary condition structure.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">See</span> <span class="n">simpleBC</span><span class="p">.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.params.wells_and_bc.pside" title="core.params.wells_and_bc.pside"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pside</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.addBC" title="core.params.wells_and_bc.addBC"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addBC</span></code></a>, <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.wells_and_bc.pside">
<span class="sig-name descname"><span class="pre">pside</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">bc</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">side</span></em>, <em class="sig-param"><span class="pre">pressure</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.wells_and_bc.pside" title="Permalink to this definition"></a></dt>
<dd><p>Impose pressure boundary condition on global side.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">bc</span> <span class="p">=</span> <span class="n">pside</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">pside</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">pside</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">)</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">pside</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bc</strong> – Boundary condition structure as defined by function ‘addBC’.</p></li>
<li><p><strong>G</strong> – Grid structure as described by <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.  Currently
restricted to grids produced by functions <a class="reference internal" href="#core.gridprocessing.cartGrid" title="core.gridprocessing.cartGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartGrid</span></code></a> and
<a class="reference internal" href="#core.gridprocessing.tensorGrid" title="core.gridprocessing.tensorGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tensorGrid</span></code></a> and other grids that add cardinal directions to
<a href="#id35"><span class="problematic" id="id36">`</span></a>G.cells.faces(:, 2) in the same format.</p></li>
<li><p><strong>side</strong> – <p>Global side from which to extract face indices.  String.  Must
(case insensitively) match one of six alias groups:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'West'</span> <span class="pre">,</span> <span class="pre">'XMin',</span> <span class="pre">'Left'</span>&#160; <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'East'</span> <span class="pre">,</span> <span class="pre">'XMax',</span> <span class="pre">'Right'</span> <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'South',</span> <span class="pre">'YMin',</span> <span class="pre">'Back'</span>&#160; <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'North',</span> <span class="pre">'YMax',</span> <span class="pre">'Front'</span> <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'Upper',</span> <span class="pre">'ZMin',</span> <span class="pre">'Top'</span>&#160;&#160; <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'Lower',</span> <span class="pre">'ZMax',</span> <span class="pre">'Bottom'}</span></code></p></li>
</ol>
</div></blockquote>
<p>These groups correspond to the cardinal directions mentioned
as the first alternative in each group.</p>
</p></li>
<li><p><strong>p</strong> – Pressure value, in units of Pascal, to be applied to the face.
Either a scalar or a vector of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">numel(I1)*numel(I2)</span></code> values.</p></li>
<li><p><strong>I1</strong> – Cell index ranges for local (in-plane) axes one and two,
respectively.  An empty index range ([]) is interpreted as
covering the entire corresponding local axis of ‘side’ in the
grid ‘G’.  The local axes on a ‘side’ in ‘G’ are ordered
according to ‘X’ before ‘Y’, and ‘Y’ before ‘Z’.</p></li>
<li><p><strong>I2</strong> – Cell index ranges for local (in-plane) axes one and two,
respectively.  An empty index range ([]) is interpreted as
covering the entire corresponding local axis of ‘side’ in the
grid ‘G’.  The local axes on a ‘side’ in ‘G’ are ordered
according to ‘X’ before ‘Y’, and ‘Y’ before ‘Z’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>sat</strong> – Volumetric composition of fluid injected across inflow faces.
An n-by-m array of fluid compositions with ‘n’ being the
number of faces in ‘faces’ and for m=3, the columns
interpreted as 1 &lt;-&gt; Aqua, 2 &lt;-&gt; Liquid, 3 &lt;-&gt; Vapor.
The fractions should sum up to one, i.e. have row-sum of
unity. If a row vector is specified, this vector is used for
all faces in the definition.</p>
<p>This field is for the benefit of transport solvers such as
‘implicitTransport’ and will be ignored for outflow faces.</p>
<p>Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sat</span> <span class="pre">=</span> <span class="pre">1</span></code> (assume single-phase flow).</p>
</li>
<li><p><strong>range</strong> – Restricts the search for outer faces to a subset of the cells
in the direction perpendicular to that of the face. Example:
if side=’LEFT’, one will only search for outer faces in the
cells with logical indexes [range,:,:].
Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">[]</span></code> (do not restrict search).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bc</strong> – Updated boundary condition structure.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">See</span> <span class="n">simpleBC</span><span class="p">,</span> <span class="n">simpleSRCandBC</span><span class="p">.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.params.wells_and_bc.fluxside" title="core.params.wells_and_bc.fluxside"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fluxside</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.addBC" title="core.params.wells_and_bc.addBC"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addBC</span></code></a>, <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.wells_and_bc.psideh">
<span class="sig-name descname"><span class="pre">psideh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">bc</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">side</span></em>, <em class="sig-param"><span class="pre">fluid</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.wells_and_bc.psideh" title="Permalink to this definition"></a></dt>
<dd><p>Impose hydrostatic pressure boundary condition on global side.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">bc</span> <span class="p">=</span> <span class="n">psideh</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">fluid</span><span class="p">)</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">psideh</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">psideh</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">)</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">psideh</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">fluid</span><span class="p">,</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bc</strong> – Boundary condition structure as defined by function ‘addBC’.</p></li>
<li><p><strong>G</strong> – Grid structure as described by <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.  Currently
restricted to grids produced by functions <a class="reference internal" href="#core.gridprocessing.cartGrid" title="core.gridprocessing.cartGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartGrid</span></code></a> and
<a class="reference internal" href="#core.gridprocessing.tensorGrid" title="core.gridprocessing.tensorGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tensorGrid</span></code></a> and other grids that add cardinal directions to
<a href="#id37"><span class="problematic" id="id38">`</span></a>G.cells.faces(:, 2) in the same format.</p></li>
<li><p><strong>side</strong> – <p>Global side from which to extract face indices.  String.  Must
(case insensitively) match one of six alias groups:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'West'</span> <span class="pre">,</span> <span class="pre">'XMin',</span> <span class="pre">'Left'</span>&#160; <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'East'</span> <span class="pre">,</span> <span class="pre">'XMax',</span> <span class="pre">'Right'</span> <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'South',</span> <span class="pre">'YMin',</span> <span class="pre">'Back'</span>&#160; <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'North',</span> <span class="pre">'YMax',</span> <span class="pre">'Front'</span> <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'Upper',</span> <span class="pre">'ZMin',</span> <span class="pre">'Top'</span>&#160;&#160; <span class="pre">}</span></code></p></li>
<li><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'Lower',</span> <span class="pre">'ZMax',</span> <span class="pre">'Bottom'}</span></code></p></li>
</ol>
</div></blockquote>
<p>These groups correspond to the cardinal directions mentioned
as the first alternative in each group.</p>
</p></li>
<li><p><strong>fluid</strong> – Fluid object.</p></li>
<li><p><strong>I1</strong> – Cell index ranges for local (in-plane) axes one and two,
respectively.  An empty index range ([]) is interpreted as
covering the entire corresponding local axis of ‘side’ in the
grid ‘G’.  The local axes on a ‘side’ in ‘G’ are ordered
according to ‘X’ before ‘Y’, and ‘Y’ before ‘Z’.</p></li>
<li><p><strong>I2</strong> – Cell index ranges for local (in-plane) axes one and two,
respectively.  An empty index range ([]) is interpreted as
covering the entire corresponding local axis of ‘side’ in the
grid ‘G’.  The local axes on a ‘side’ in ‘G’ are ordered
according to ‘X’ before ‘Y’, and ‘Y’ before ‘Z’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>sat</strong> – Fluid composition of fluid outside of the reservoir.
An m array of fluid phase saturations. If m=3, ‘sat’
are interpreted as 1 &lt;-&gt; Aqua, 2 &lt;-&gt; Liquid, 3 &lt;-&gt; Vapor.</p>
<p>This field is to side the density of the outside fluid and to
set the saturation of incoming fluid in a transport solver</p>
<p>Default value: sat = 0 (assume single-phase flow).</p>
</li>
<li><p><strong>range</strong> – Restricts the search for outer faces to a subset of the cells
in the direction perpendicular to that of the face. Example:
if side=’LEFT’, one will only search for outer faces in the
cells with logical indexes [:,range,:].
Default value: range = [] (do not restrict search)</p></li>
<li><p><strong>ref_depth</strong> – Reference depth for pressure. Default is 0.</p></li>
<li><p><strong>ref_pressure</strong> – Reference pressure. Default is 0</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bc</strong> – Updated boundary condition structure.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">simpleBC</span><span class="p">,</span> <span class="n">simpleSRCandBC</span><span class="p">.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.params.wells_and_bc.pside" title="core.params.wells_and_bc.pside"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pside</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.fluxside" title="core.params.wells_and_bc.fluxside"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fluxside</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.addBC" title="core.params.wells_and_bc.addBC"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addBC</span></code></a>, <a class="reference internal" href="mimetic.html#mimetic.solveIncompFlow" title="mimetic.solveIncompFlow"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solveIncompFlow</span></code></a>, <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.params.wells_and_bc.verticalWell">
<span class="sig-name descname"><span class="pre">verticalWell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">W</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">I</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.params.wells_and_bc.verticalWell" title="Permalink to this definition"></a></dt>
<dd><p>Insert a vertical well into the simulation model.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Either</span> <span class="mi">1</span><span class="p">)</span>
   <span class="n">W</span> <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="no">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
   <span class="n">W</span> <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="no">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">Or</span> <span class="mi">2</span><span class="p">)</span>
   <span class="n">W</span> <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="no">I</span><span class="p">,</span>    <span class="n">K</span><span class="p">)</span>
   <span class="n">W</span> <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="no">I</span><span class="p">,</span>    <span class="n">K</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>W</strong> – Input well structure defining existing wells.  Pass an empty
structure if there are no previously defined wells.  This
structure is updated on output.</p></li>
<li><p><strong>G</strong> – Grid data structure.  Must contain valid field
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cells.centroids</span></code>.  Call function <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a> to obtain
these values.</p></li>
<li><p><strong>rock</strong> – Rock data structure.  Must contain valid field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">rock.perm</span></code>.</p></li>
<li><p><strong>I</strong> – <p>Horizontal location of well heel. Two possible modes,</p>
<dl>
<dt>Mode 1:</dt><dd><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">I</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">J</span></code> are Cartesian indices.  Specifically,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">I</span></code> is the index along the first logical direction while
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">J</span></code> is the index along the second logical direction.</p>
<p>This mode is only supported in grids which have an underlying
Cartesian (logical) structure such as purely Cartesian grids or
corner-point grids.</p>
</dd>
<dt>Mode 2:</dt><dd><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">I</span></code> is the cell index <code class="xref mat mat-func docutils literal notranslate"><span class="pre">(1</span> <span class="pre">&lt;=</span> <span class="pre">I</span> <span class="pre">&lt;=</span> <span class="pre">G.cells.num)</span></code> of the
<em>top-most</em> cell in the column through which the vertical well
will be completed.  <code class="xref mat mat-func docutils literal notranslate"><span class="pre">J</span></code> must not be present.</p>
<p>This mode is supported for logically Cartesian grids containing
a three-component field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cartDims</span></code> or for otherwise layered
grids which contain the fields <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.numLayers</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.layerSize</span></code>.</p>
</dd>
</dl>
</p></li>
<li><p><strong>J</strong> – <p>Horizontal location of well heel. Two possible modes,</p>
<dl>
<dt>Mode 1:</dt><dd><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">I</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">J</span></code> are Cartesian indices.  Specifically,
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">I</span></code> is the index along the first logical direction while
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">J</span></code> is the index along the second logical direction.</p>
<p>This mode is only supported in grids which have an underlying
Cartesian (logical) structure such as purely Cartesian grids or
corner-point grids.</p>
</dd>
<dt>Mode 2:</dt><dd><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">I</span></code> is the cell index <code class="xref mat mat-func docutils literal notranslate"><span class="pre">(1</span> <span class="pre">&lt;=</span> <span class="pre">I</span> <span class="pre">&lt;=</span> <span class="pre">G.cells.num)</span></code> of the
<em>top-most</em> cell in the column through which the vertical well
will be completed.  <code class="xref mat mat-func docutils literal notranslate"><span class="pre">J</span></code> must not be present.</p>
<p>This mode is supported for logically Cartesian grids containing
a three-component field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cartDims</span></code> or for otherwise layered
grids which contain the fields <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.numLayers</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.layerSize</span></code>.</p>
</dd>
</dl>
</p></li>
<li><p><strong>K</strong> – <p>A vector of layers in which this well should be completed.
An empty layer vector (i.e., <code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(K)</span></code>), is replaced by:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">K</span> <span class="p">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">num_layers</span>
</pre></div>
</div>
<p>In other words, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(K)</span></code> implies completion in ALL layers.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘Any’</strong> – All options supported by function <a class="reference internal" href="#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a> are supported in
<a class="reference internal" href="#core.params.wells_and_bc.verticalWell" title="core.params.wells_and_bc.verticalWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">verticalWell</span></code></a>.  Any direction specifications (i.e., option
‘Dir’) are ignored and replaced by ‘z’.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>W</strong> – Updated well structure.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">60</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">85</span><span class="p">],</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">85</span><span class="p">]</span><span class="o">.*</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.*</span><span class="n">ft</span><span class="p">);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
<span class="n">rock</span><span class="p">.</span><span class="n">perm</span> <span class="p">=</span> <span class="nb">repmat</span><span class="p">([</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span><span class="o">.*</span><span class="n">milli</span><span class="o">*</span><span class="n">darcy</span><span class="p">(),</span> <span class="p">[</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
<span class="n">W</span> <span class="p">=</span> <span class="nb">struct</span><span class="p">([]);</span>
<span class="n">W</span> <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">85</span><span class="p">),</span>     <span class="p">...</span>
                 <span class="s">&#39;Type&#39;</span><span class="p">,</span> <span class="s">&#39;bhp&#39;</span><span class="p">,</span> <span class="s">&#39;Val&#39;</span><span class="p">,</span> <span class="mi">300</span><span class="o">*</span><span class="n">barsa</span><span class="p">,</span> <span class="p">...</span>
                 <span class="s">&#39;Radius&#39;</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">,</span> <span class="s">&#39;Name&#39;</span><span class="p">,</span> <span class="s">&#39;P1&#39;</span><span class="p">);</span>
<span class="n">W</span> <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">85</span><span class="p">),</span>     <span class="p">...</span>
                 <span class="s">&#39;Type&#39;</span><span class="p">,</span> <span class="s">&#39;bhp&#39;</span><span class="p">,</span> <span class="s">&#39;Val&#39;</span><span class="p">,</span> <span class="mi">300</span><span class="o">*</span><span class="n">barsa</span><span class="p">,</span> <span class="p">...</span>
                 <span class="s">&#39;Radius&#39;</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">,</span> <span class="s">&#39;Name&#39;</span><span class="p">,</span> <span class="s">&#39;P2&#39;</span><span class="p">);</span>
<span class="n">W</span> <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">85</span><span class="p">),</span>     <span class="p">...</span>
                 <span class="s">&#39;Type&#39;</span><span class="p">,</span> <span class="s">&#39;bhp&#39;</span><span class="p">,</span> <span class="s">&#39;Val&#39;</span><span class="p">,</span> <span class="mi">300</span><span class="o">*</span><span class="n">barsa</span><span class="p">,</span> <span class="p">...</span>
                 <span class="s">&#39;Radius&#39;</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">,</span> <span class="s">&#39;Name&#39;</span><span class="p">,</span> <span class="s">&#39;P3&#39;</span><span class="p">);</span>
<span class="n">W</span> <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">85</span><span class="p">),</span>     <span class="p">...</span>
                 <span class="s">&#39;Type&#39;</span><span class="p">,</span> <span class="s">&#39;bhp&#39;</span><span class="p">,</span> <span class="s">&#39;Val&#39;</span><span class="p">,</span> <span class="mi">300</span><span class="o">*</span><span class="n">barsa</span><span class="p">,</span> <span class="p">...</span>
                 <span class="s">&#39;Radius&#39;</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">,</span> <span class="s">&#39;Name&#39;</span><span class="p">,</span> <span class="s">&#39;P4&#39;</span><span class="p">);</span>
<span class="n">W</span> <span class="p">=</span> <span class="n">verticalWell</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">85</span><span class="p">),</span>     <span class="p">...</span>
                 <span class="s">&#39;Type&#39;</span><span class="p">,</span> <span class="s">&#39;bhp&#39;</span><span class="p">,</span> <span class="s">&#39;Val&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="o">*</span><span class="n">barsa</span><span class="p">,</span> <span class="p">...</span>
                 <span class="s">&#39;Radius&#39;</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">,</span> <span class="s">&#39;Name&#39;</span><span class="p">,</span> <span class="s">&#39;I1&#39;</span><span class="p">,</span>   <span class="p">...</span>
                 <span class="s">&#39;Comp_i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <a class="reference internal" href="#core.gridprocessing.makeLayeredGrid" title="core.gridprocessing.makeLayeredGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeLayeredGrid</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.addWell" title="core.params.wells_and_bc.addWell"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">addWell</span></code></a>.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline"></a></h2>
<div class="section" id="various-utilities">
<h3>Various utilities<a class="headerlink" href="#various-utilities" title="Permalink to this headline"></a></h3>
<p>The MRST core has a number of different utilies. Some routines, e.g. <a class="reference internal" href="#core.utils.mrstModule" title="core.utils.mrstModule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstModule</span></code></a>
and <a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a>, help MRST manage add-ons and extensions, while others are useful
when writing scripts, functions and new solvers.</p>
<span class="target" id="module-core.utils"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>UTILS</dt><dd><p>Supporting utilities for MATLAB Reservoir Simulation Toolbox (MRST).</p>
</dd>
<dt>Files</dt><dd><p>ADI                         - class: simple implementation of automatic differentiation for easy construction of jacobian matrices.
blockDiagIndex              - Compute subscript or linear index to nonzeros of block-diagonal matrix
buildmex                    - Wrapper around MEX which abstracts away details of pathname generation.
cellDims                    - cellDims – Compute physical dimensions of all cells in single well
cellDimsCG                  - cellDims – Compute physical dimensions of all cells in single well
cellFlux2faceFlux           - Transform cell-based flux field to face-based.
computeWellIndex            - Undocumented Utility Function for Connection Transmissibility Factors
dinterpq1                   - Compute derivative of piecewise linear interpolant.
dinterpTable                - Compute derivative of one-dimensional interpolant, possibly using splines.
dispif                      - Produce textual output contingent upon predicate.
evalFunStandalone           - Utility for performing stand-alone function evaluation in new matlab session
evalFunWrapper              - Utility to launch (mrst-)function evaluation in seperate matlab session
faceFlux2cellFlux           - Transform face-based flux field to cell-based.
faceFlux2cellVelocity       - Transform face-based flux field to one constant velocity per cell.
findFilesSubfolders         - Find all files in a directory hierarchy
formatTimeRange             - Small utility which returns a human readable string from seconds.
geomspace                   - Geometrically spaced vector.
getSortedCellNodes          - Construct n x 2 table of cell edges with edges oriented the same
githubDownload              - Download objects from GitHub (.ZIP or collection of files)
incompHydrostaticPressure   - Undocumented Utility Function
initVariablesADI            - Initialize a set of automatic differentiation variables
interpTable                 - Interpolate a one-dimensional table, possibly using splines.
interpTableMEX              - Interpolate a one-dimensional table with MEX acceleration
isCoarseGrid                - Check if a grid is a coarse grid or a fine grid
mcolon                      - Compute vector of consecutive indices from separate lower/upper bounds.
md5sum_fallback             - Alternative implementation of md5sum for systems without C compiler.
merge_options               - Override default control options.
merge_options_relaxed       - A less general version of merge_options focused on specific choices:
moduleGUI                   - Interactive user interface for activation/deactivation of known mrst modules
mrstConfigureMETISLocations - Configure Installed Location of METIS Library and Associate Header Files
mrstDataDirectory           - Set or retrieve the current canonical data directory for MRST
mrstDebug                   - Globally control default settings for MRST debugging information.
mrstDefaultMexFlags         - Define Common Compiler and Linker Flags/Libraries for MRST’s MEX Functions
mrstExamples                - Discover Example M-Files Pertaining to One or More MRST Modules
mrstExtraDirs               - Get List of Directories Added to MATLAB’s Search PATH by MRST
mrstIsLiveEditorDir         - Detect if Script is Run From Live Editor or in Cell Mode
mrstModule                  - Query or modify list of activated add-on MRST modules
mrstNargInCheck             - Check number of input arguments to function
mrstOutputDirectory         - Set or retrieve the current canonical data directory for MRST
mrstPath                    - Establish and maintain mapping from module names to system directory paths
mrstStartupMessage          - Print a welcome message with helpful commands for new MRST users
mrstVerbose                 - Globally control default settings for MRST verbose information.
mrstWebSave                 - Get Call-Back for Downloading Online Resources Specified by URLs
msgid                       - Construct Error/Warning message ID by prepending function name.
multiEig                    - Solve sequence of general (unsymmetric) eigenvalue problems using LAPACK
multiSymmEig                - Solve sequence of symmetric eigenvalue problems using LAPACK
propertynames               - Undocumented Utility Function
reduceToDouble              - Reduce ADI variable to double.
require                     - Announce and enforce module dependency.
rldecode                    - Decompress run length encoding of array <code class="xref mat mat-func docutils literal notranslate"><span class="pre">A</span></code> along dimension <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dim</span></code>.
rlencode                    - Compute run length encoding of array A along dimension dim.
ROOTDIR                     - Retrieve full path of Toolbox installation directory.
subsetMinus                 - Undocumented Utility Function
subsetPlus                  - Undocumented Utility Function
ternaryAxis                 - Create a ternary axis and mappings to ternary space
tetrahedralAxis             - Create a ternary axis and mappings to ternary space
ticif                       - Evaluate function TIC if input is true.
tocif                       - Evaluate function TOC if input is true.
uniqueStable                - Support <code class="xref mat mat-func docutils literal notranslate"><span class="pre">unique(A,</span> <span class="pre">'stable')</span></code> in all versions of MATLAB
value                       - Remove AD state and compact 1 by n cell arrays to matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.mrstDataDirectory">
<span class="sig-name descname"><span class="pre">mrstDataDirectory</span></span><a class="headerlink" href="#core.utils.mrstDataDirectory" title="Permalink to this definition"></a></dt>
<dd><p>Set or retrieve the current canonical data directory for MRST</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Query directory</span>
<span class="n">mrstDataDirectory</span><span class="p">();</span>
<span class="n">datadir</span> <span class="p">=</span> <span class="n">mrstDataDirectory</span><span class="p">();</span>

<span class="c">% Set directory</span>
<span class="n">mrstDataDirectory</span><span class="p">(</span><span class="s">&#39;/some/path&#39;</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>datadir</strong> – If provided, the current data directory for the MRST session
will be set to this directory. If the directory itself does
not exist, a warning will be given and the directory will not
be changed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>datadir</strong> – Current datadir. If not requested, this will instead be
printed to the command window.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you do not wish to use the default MRST data directory, consider
placing a call to mrstDataDirectory in your startup_user.m file located
under the mrst root directory (see ROOTDIR())</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.mrstModule" title="core.utils.mrstModule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstModule</span></code></a>, <a class="reference internal" href="#core.utils.dataset_manager.gui.mrstDatasetGUI" title="core.utils.dataset_manager.gui.mrstDatasetGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDatasetGUI</span></code></a>, <a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a>, <a class="reference internal" href="#core.utils.dataset_manager.getDatasetPath" title="core.utils.dataset_manager.getDatasetPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDatasetPath</span></code></a></p>
</div>
</dd></dl>

<dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.mrstOutputDirectory">
<span class="sig-name descname"><span class="pre">mrstOutputDirectory</span></span><a class="headerlink" href="#core.utils.mrstOutputDirectory" title="Permalink to this definition"></a></dt>
<dd><p>Set or retrieve the current canonical data directory for MRST</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Query directory</span>
<span class="n">mrstOutputDirectory</span><span class="p">();</span>
<span class="n">outdir</span> <span class="p">=</span> <span class="n">mrstOutputDirectory</span><span class="p">();</span>

<span class="c">% Set directory</span>
<span class="n">mrstOutputDirectory</span><span class="p">(</span><span class="s">&#39;/some/path&#39;</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><p><strong>outdir</strong> – If provided, the current output directory for the MRST session
will be set to this directory. If the directory itself does
not exist, a warning will be given and the directory will not
be changed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>outdir</strong> – Current output dir. If not requested, this will instead be
printed to the command window.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you do not wish to use the default MRST output directory, consider
placing a call to mrstOutputDirectory in your startup_user.m file
located under the mrst root directory (see ROOTDIR())</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.mrstModule" title="core.utils.mrstModule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstModule</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDataDirectory</span></code>, <a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a></p>
</div>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="core.utils.ADI">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">ADI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI" title="Permalink to this definition"></a></dt>
<dd><p>ADI class: simple implementation of automatic differentiation for easy construction of jacobian matrices.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="p">=</span> <span class="n">ADI</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">jacobian</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> – The numerical value of the object</p></li>
<li><p><strong>jacobian</strong> – The Jacobian of the object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>u</strong> – ADI object.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is typically instansiated for a set of different variables
using <a class="reference internal" href="#core.utils.initVariablesADI" title="core.utils.initVariablesADI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initVariablesADI</span></code></a>. The file contains a worked example
demonstrating the usage for several variables.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.initVariablesADI" title="core.utils.initVariablesADI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initVariablesADI</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">PhysicalModel</span></code></p>
</div>
<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.ADI">
<span class="sig-name descname"><span class="pre">ADI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">b</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.ADI" title="Permalink to this definition"></a></dt>
<dd><p>ADI class constructor</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.abs">
<span class="sig-name descname"><span class="pre">abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.abs" title="Permalink to this definition"></a></dt>
<dd><p>Absolute value</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.combineEquations">
<span class="sig-name descname"><span class="pre">combineEquations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.combineEquations" title="Permalink to this definition"></a></dt>
<dd><p>Combine a set of equations of either ADI or double type to a
single equation with ADI type. The resulting equation will have
a single assembled sparse Jacobian containing all derivatives.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.convertDouble">
<span class="sig-name descname"><span class="pre">convertDouble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.convertDouble" title="Permalink to this definition"></a></dt>
<dd><p>Convert numeric type v into AD with zero derivatives with
respect to the same variables as x (which is already AD)</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.cos">
<span class="sig-name descname"><span class="pre">cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.cos" title="Permalink to this definition"></a></dt>
<dd><p>Element-wise cosine: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h=cos(u)</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.cumsum">
<span class="sig-name descname"><span class="pre">cumsum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.cumsum" title="Permalink to this definition"></a></dt>
<dd><p>Cumulative sum of vector</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.double">
<span class="sig-name descname"><span class="pre">double</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.double" title="Permalink to this definition"></a></dt>
<dd><p>Cast to double and thereby remove derivatives:</p>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="core.utils.ADI.double2AD">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">double2AD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">J1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.double2AD" title="Permalink to this definition"></a></dt>
<dd><p>u is vector, J reference jacobian</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.exp" title="Permalink to this definition"></a></dt>
<dd><p>Element-wise exponential: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h=exp(u)</span></code>.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.ge">
<span class="sig-name descname"><span class="pre">ge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.ge" title="Permalink to this definition"></a></dt>
<dd><p>Greater than or equal: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">u&gt;=v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.getNumVars">
<span class="sig-name descname"><span class="pre">getNumVars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ad</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.getNumVars" title="Permalink to this definition"></a></dt>
<dd><p>Get number of derivatives in each Jacobian block.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.gt">
<span class="sig-name descname"><span class="pre">gt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.gt" title="Permalink to this definition"></a></dt>
<dd><p>Greater than: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">u&gt;v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.interpReg">
<span class="sig-name descname"><span class="pre">interpReg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">T</span></em>, <em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">reginx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.interpReg" title="Permalink to this definition"></a></dt>
<dd><p>Interpolate property with region support</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.interpTable">
<span class="sig-name descname"><span class="pre">interpTable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">X</span></em>, <em class="sig-param"><span class="pre">Y</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.interpTable" title="Permalink to this definition"></a></dt>
<dd><p>Interpolate in a table</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.ldivide">
<span class="sig-name descname"><span class="pre">ldivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.ldivide" title="Permalink to this definition"></a></dt>
<dd><p>Left element-wise division: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">u.v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.le">
<span class="sig-name descname"><span class="pre">le</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.le" title="Permalink to this definition"></a></dt>
<dd><p>Less than or equal: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">u&lt;=v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.log" title="Permalink to this definition"></a></dt>
<dd><p>Element-wise natural logarithm: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h=log(u)</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.lt">
<span class="sig-name descname"><span class="pre">lt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.lt" title="Permalink to this definition"></a></dt>
<dd><p>Less than: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">u</span> <span class="pre">&lt;</span> <span class="pre">v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.max" title="Permalink to this definition"></a></dt>
<dd><p>Take the element-wise maximum value of two objects</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.min" title="Permalink to this definition"></a></dt>
<dd><p>Element-wise minimum value of two objects.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.minus">
<span class="sig-name descname"><span class="pre">minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.minus" title="Permalink to this definition"></a></dt>
<dd><p>Subtraction with two elements: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">u</span> <span class="pre">-</span> <span class="pre">v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.mldivide">
<span class="sig-name descname"><span class="pre">mldivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.mldivide" title="Permalink to this definition"></a></dt>
<dd><p>Left matrix divide: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h=uv</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.mrdivide">
<span class="sig-name descname"><span class="pre">mrdivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.mrdivide" title="Permalink to this definition"></a></dt>
<dd><p>Right matrix divide: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h=u/v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.mtimes">
<span class="sig-name descname"><span class="pre">mtimes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.mtimes" title="Permalink to this definition"></a></dt>
<dd><p>Multiplication with matrix or scalar: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">u*v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.numelValue">
<span class="sig-name descname"><span class="pre">numelValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.numelValue" title="Permalink to this definition"></a></dt>
<dd><p>Get number of values. Equivalent of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">numel</span></code> for doubles. We do
not overload numel directly as it is not recommended by
Mathworks.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.plus">
<span class="sig-name descname"><span class="pre">plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.plus" title="Permalink to this definition"></a></dt>
<dd><p>Addition ot two values, where either value can be ADI of
appropriate dimensions: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">u</span> <span class="pre">+</span> <span class="pre">v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.power">
<span class="sig-name descname"><span class="pre">power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.power" title="Permalink to this definition"></a></dt>
<dd><p>Element-wise poewr. <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h=u.^v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.rdivide">
<span class="sig-name descname"><span class="pre">rdivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.rdivide" title="Permalink to this definition"></a></dt>
<dd><p>Right element-wise division: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">u./v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.reduceToDouble">
<span class="sig-name descname"><span class="pre">reduceToDouble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.reduceToDouble" title="Permalink to this definition"></a></dt>
<dd><p>Switch to double representation if no derivatives are present.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.repmat">
<span class="sig-name descname"><span class="pre">repmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.repmat" title="Permalink to this definition"></a></dt>
<dd><p>Replicate and tile array of values.
.. note:: Only allowed in the first (column) dimension for ADI objects.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.sign">
<span class="sig-name descname"><span class="pre">sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.sign" title="Permalink to this definition"></a></dt>
<dd><p>Element-wise sign of vector</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.sin">
<span class="sig-name descname"><span class="pre">sin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.sin" title="Permalink to this definition"></a></dt>
<dd><p>Element-wise sine: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h=sin(u)</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.subsasgn">
<span class="sig-name descname"><span class="pre">subsasgn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">s</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.subsasgn" title="Permalink to this definition"></a></dt>
<dd><p>Subscripted reference. Called for <code class="xref mat mat-func docutils literal notranslate"><span class="pre">u(s)</span> <span class="pre">=</span> <span class="pre">v</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.subsref">
<span class="sig-name descname"><span class="pre">subsref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.subsref" title="Permalink to this definition"></a></dt>
<dd><p>Subscripted reference. Called for <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">u(v)</span></code>.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.sum">
<span class="sig-name descname"><span class="pre">sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.sum" title="Permalink to this definition"></a></dt>
<dd><p>Sum of vector</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.times">
<span class="sig-name descname"><span class="pre">times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.times" title="Permalink to this definition"></a></dt>
<dd><p>Element-wise multiplication: h = u.*v</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.uminus">
<span class="sig-name descname"><span class="pre">uminus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.uminus" title="Permalink to this definition"></a></dt>
<dd><p>Unitary minus: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">-u</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.uplus">
<span class="sig-name descname"><span class="pre">uplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.uplus" title="Permalink to this definition"></a></dt>
<dd><p>Unitary plus: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">+u</span></code></p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.value">
<span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.value" title="Permalink to this definition"></a></dt>
<dd><p>Cast to double and thereby remove derivatives:</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="core.utils.ADI.vertcat">
<span class="sig-name descname"><span class="pre">vertcat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ADI.vertcat" title="Permalink to this definition"></a></dt>
<dd><p>Vertical concatentation of both ADI and double types.</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="core.utils.ADI.jac">
<span class="sig-name descname"><span class="pre">jac</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#core.utils.ADI.jac" title="Permalink to this definition"></a></dt>
<dd><p>cell array of sparse jacobian matrices</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="core.utils.ADI.val">
<span class="sig-name descname"><span class="pre">val</span></span><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#core.utils.ADI.val" title="Permalink to this definition"></a></dt>
<dd><p>function value as a column vector of doubles</p>
</dd></dl>

</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.ROOTDIR">
<span class="sig-name descname"><span class="pre">ROOTDIR</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ROOTDIR" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve full path of Toolbox installation directory.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="p">=</span> <span class="n">ROOTDIR</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>root</strong> – Full path to MRST installation directory.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.applyFunction">
<span class="sig-name descname"><span class="pre">applyFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fn</span></em>, <em class="sig-param"><span class="pre">array</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.applyFunction" title="Permalink to this definition"></a></dt>
<dd><p>Apply a function to entries of (cell) arrays, giving cell arrays as output</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="p">=</span> <span class="n">applyFunction</span><span class="p">(@(</span><span class="n">x</span><span class="p">)</span> <span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">array</span><span class="p">)</span>
<span class="n">f</span> <span class="p">=</span> <span class="n">applyFunction</span><span class="p">(@(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> – function_handle that will be applied to each element of all
subsequent inputs.</p></li>
<li><p><strong>array</strong> – Either a cell array or a regular double array. The outputs will
match the dimensions of this input, as a cell array.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>extra</strong> – Any number of additional arrays that match array in type and
dimension can be passed as additional arguments.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>v</strong> – Cell array where each entry contains the function result. Even
when the function outputs are scalar, this will be a cell
array.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="p">=</span> <span class="n">applyFunction</span><span class="p">(@(</span><span class="n">x</span><span class="p">)</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">{</span><span class="nb">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)})</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All calls are redirected to arrayfun or cellfun with the
UniformOutput parameter disabled. This function is primarily a
convenience function since this type of call occurs a lot in MRST, and
also allows for easier Octave compatibility.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>arrayfun, cellfun</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.blockDiagIndex">
<span class="sig-name descname"><span class="pre">blockDiagIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">m</span></em>, <em class="sig-param"><span class="pre">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.blockDiagIndex" title="Permalink to this definition"></a></dt>
<dd><p>Compute subscript or linear index to nonzeros of block-diagonal matrix</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="n">blockDiagIndex</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="n">blockDiagIndex</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
 <span class="n">i</span>     <span class="p">=</span> <span class="n">blockDiagIndex</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> – <p>Vectors of dimensions/block sizes of each diagonal block.
Input <code class="xref mat mat-func docutils literal notranslate"><span class="pre">m</span></code> is interpreted as the row dimension of each block
while <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code> is interpreted as the column dimension of each
block.</p>
<p>Vector <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code> must have the same number of entries as vector <code class="xref mat mat-func docutils literal notranslate"><span class="pre">m</span></code>,
i.e., the number of blocks.</p>
<p>If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code> is not supplied, function <a class="reference internal" href="#core.utils.blockDiagIndex" title="core.utils.blockDiagIndex"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">blockDiagIndex</span></code></a> will behave
as if it were called as:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="nb">i</span><span class="p">,</span> <span class="nb">j</span><span class="p">]</span> <span class="p">=</span> <span class="n">blockDiagIndex</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, using square blocks.</p>
</p></li>
<li><p><strong>n</strong> – <p>Vectors of dimensions/block sizes of each diagonal block.
Input <code class="xref mat mat-func docutils literal notranslate"><span class="pre">m</span></code> is interpreted as the row dimension of each block
while <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code> is interpreted as the column dimension of each
block.</p>
<p>Vector <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code> must have the same number of entries as vector <code class="xref mat mat-func docutils literal notranslate"><span class="pre">m</span></code>,
i.e., the number of blocks.</p>
<p>If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code> is not supplied, function <a class="reference internal" href="#core.utils.blockDiagIndex" title="core.utils.blockDiagIndex"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">blockDiagIndex</span></code></a> will behave
as if it were called as:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="nb">i</span><span class="p">,</span> <span class="nb">j</span><span class="p">]</span> <span class="p">=</span> <span class="n">blockDiagIndex</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, using square blocks.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>i,j</strong> – Index vectors that may be used to form sparse block-diagonal
matrix.  This process is demonstrated in the example below.</p>
<p>The return values are of type <code class="xref mat mat-func docutils literal notranslate"><span class="pre">double</span></code> irrespective of the
class of the dimension vectors <code class="xref mat mat-func docutils literal notranslate"><span class="pre">m</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>If called using a single output value, that value is the
linear index, computed using <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sub2ind</span></code>, of the index pair
(i,j).</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">m</span>      <span class="p">=</span> <span class="p">[</span> <span class="mi">1</span> <span class="p">;</span> <span class="mi">2</span> <span class="p">;</span> <span class="mi">3</span> <span class="p">];</span>
<span class="n">n</span>      <span class="p">=</span> <span class="p">[</span> <span class="mi">2</span> <span class="p">;</span> <span class="mi">3</span> <span class="p">;</span> <span class="mi">4</span> <span class="p">];</span>
<span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="n">blockDiagIndex</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="n">A</span>      <span class="p">=</span> <span class="nb">sparse</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span> <span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span> <span class="o">.*</span> <span class="n">n</span><span class="p">));</span>
<span class="nb">full</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="nb">spy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.rldecode" title="core.utils.rldecode"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">rldecode</span></code></a>, <a class="reference internal" href="#core.utils.mcolon" title="core.utils.mcolon"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mcolon</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sub2ind</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.buildmex">
<span class="sig-name descname"><span class="pre">buildmex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.buildmex" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper around MEX which abstracts away details of pathname generation.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">buildmex</span> <span class="p">[</span><span class="n">options</span> <span class="p">...]</span> <span class="n">file</span> <span class="p">[</span><span class="n">files</span> <span class="p">...]</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p><a class="reference internal" href="#core.utils.buildmex" title="core.utils.buildmex"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildmex</span></code></a> accepts the same file and option parameters as <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mex</span></code>, with
the additional provision that filenames which do not start with
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">filesep</span></code> are interpreted as pathnames relative to the directory
containing the M file which calls <a class="reference internal" href="#core.utils.buildmex" title="core.utils.buildmex"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildmex</span></code></a>. Absolute pathnames (those
starting with <code class="xref mat mat-func docutils literal notranslate"><span class="pre">filesep</span></code>) are left untouched.</p>
<p>This function has no return values, but a compiled mex-function with
the same name as the caller is produced in the directory containing the
M file which calls <a class="reference internal" href="#core.utils.buildmex" title="core.utils.buildmex"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildmex</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Various</strong> – Same parameters as <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mex</span></code>. See description for more details.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Nothing</strong> – No return values.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>All parameters must be character strings.</p></li>
<li><p>Function <a class="reference internal" href="#core.utils.buildmex" title="core.utils.buildmex"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildmex</span></code></a> requests <code class="xref mat mat-func docutils literal notranslate"><span class="pre">-largeArrayDims</span></code> from <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mex</span></code>.</p></li>
<li><p>Function <a class="reference internal" href="#core.utils.buildmex" title="core.utils.buildmex"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildmex</span></code></a> must be called from an M file only; it cannot be
invoked from the base workspace.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">filesep</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mex</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.cellDims">
<span class="sig-name descname"><span class="pre">cellDims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">ix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.cellDims" title="Permalink to this definition"></a></dt>
<dd><p>cellDims – Compute physical dimensions of all cells in single well</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">]</span> <span class="p">=</span> <span class="n">cellDims</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">ix</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>ix</strong> – Cells for which to compute the physical dimensions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dx, dy, dz – [dx</strong> (<em>k) dy(k</em>) – plane, while dz(k) =
V(k)/dx(k)*dy(k)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.cellDimsCG">
<span class="sig-name descname"><span class="pre">cellDimsCG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">ix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.cellDimsCG" title="Permalink to this definition"></a></dt>
<dd><p>cellDims – Compute physical dimensions of all cells in single well</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">]</span> <span class="p">=</span> <span class="n">cellDims</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">ix</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>ix</strong> – Cells for which to compute the physical dimensions (bounding
boxes).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dx, dy, dz – Size of bounding box for each cell.  In particular,</strong> – [dx(k),dy(k),dz(k)] is Cartesian BB for cell ix(k).</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.cellFlux2faceFlux">
<span class="sig-name descname"><span class="pre">cellFlux2faceFlux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">cellFlux</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.cellFlux2faceFlux" title="Permalink to this definition"></a></dt>
<dd><p>Transform cell-based flux field to face-based.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">faceFlux</span> <span class="p">=</span> <span class="n">cellFlux2faceFlux</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cellFlux</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – grid structure</p></li>
<li><p><strong>cellFlux</strong> – Set of flux vectors in cell-wise ordering.  One column for
each flux vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>faceFlux</strong> – Set of face-wise ordered fluxes.  One column for each of the
input flux vectors.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.faceFlux2cellFlux" title="core.utils.faceFlux2cellFlux"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">faceFlux2cellFlux</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.computeWellIndex">
<span class="sig-name descname"><span class="pre">computeWellIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">rock</span></em>, <em class="sig-param"><span class="pre">radius</span></em>, <em class="sig-param"><span class="pre">cells</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.computeWellIndex" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function for Connection Transmissibility Factors</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dinterpTable">
<span class="sig-name descname"><span class="pre">dinterpTable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">y</span></em>, <em class="sig-param"><span class="pre">xi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dinterpTable" title="Permalink to this definition"></a></dt>
<dd><p>Compute derivative of one-dimensional interpolant, possibly using splines.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">dyi</span> <span class="p">=</span> <span class="n">dinterpTable</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
<span class="n">dyi</span> <span class="p">=</span> <span class="n">dinterpTable</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – Nodes at which underlying function y=y(x) is sampled.</p></li>
<li><p><strong>Y</strong> – Values of the underlying function y=y(x) at the nodes, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">X</span></code>.</p></li>
<li><p><strong>xi</strong> – Evaluation points for new, interpolated, values of the
derivative y’(x).</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘spline’</strong> – Whether or not to use spline interpolation.
Logical.  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">spline=false</span></code> (use linear
interpolation/extrapolation).</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>dyi</strong> – Approximate (interpolated/extrapolated) values of the derivative
of the function y=y(x) at the points <code class="xref mat mat-func docutils literal notranslate"><span class="pre">xi</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.dinterpq1" title="core.utils.dinterpq1"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dinterpq1</span></code></a>, <a class="reference internal" href="#core.utils.interpTable" title="core.utils.interpTable"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">interpTable</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">interp1</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">spline</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dinterpq1">
<span class="sig-name descname"><span class="pre">dinterpq1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">y</span></em>, <em class="sig-param"><span class="pre">xi</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dinterpq1" title="Permalink to this definition"></a></dt>
<dd><p>Compute derivative of piecewise linear interpolant.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">dyi</span> <span class="p">=</span> <span class="n">dintrpq1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – Vector of length at least two containing coordinates of
underlying interval.  The values must either be monotonically
increasing or monotonically decreasing.</p></li>
<li><p><strong>y</strong> – Function values of piecewise linear function at points x.  Must
be a vector containing <code class="xref mat mat-func docutils literal notranslate"><span class="pre">numel(x)</span></code> elements.</p></li>
<li><p><strong>xi</strong> – Points at which to compute derivative values of function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">y(x)</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dyi</strong> – Column vector containing derivative values of function y(x).
One scalar value for each point in the input vector <code class="xref mat mat-func docutils literal notranslate"><span class="pre">xi</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Function dinterpq1 assumes that all input arrays contain only finite
values.  That is, we assume that</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="o">~</span><span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="nb">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">||</span> <span class="n">any</span><span class="p">(</span><span class="nb">isinf</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">||</span> <span class="n">any</span><span class="p">(</span><span class="nb">isinf</span><span class="p">(</span><span class="n">xi</span><span class="p">)))</span>
</pre></div>
</div>
<p>Furthermore dinterpq1 employs linear extrapolation outside the data
points (x,y).</p>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Compute derivatives at xi=[-10, 0.1, pi, 100] of a piecewise linear</span>
<span class="c">% function whose piecewise derivative values are 1:10.</span>
<span class="n">x</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">:</span> <span class="mi">10</span><span class="p">;</span> <span class="n">y</span> <span class="p">=</span> <span class="nb">cumsum</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">dinterpq1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="nb">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">interp1q</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.discspace1">
<span class="sig-name descname"><span class="pre">discspace1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">d1</span></em>, <em class="sig-param"><span class="pre">d2</span></em>, <em class="sig-param"><span class="pre">N</span></em>, <em class="sig-param"><span class="pre">refine</span></em>, <em class="sig-param"><span class="pre">type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.discspace1" title="Permalink to this definition"></a></dt>
<dd><p>Discretize 1D space with options for refinement</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="p">=</span> <span class="n">discspace1</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">no_pts</span><span class="p">)</span>
<span class="n">x</span> <span class="p">=</span> <span class="n">discspace1</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">no_pts</span><span class="p">,</span> <span class="n">refine</span><span class="p">)</span>
<span class="n">x</span> <span class="p">=</span> <span class="n">discspace1</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">no_pts</span><span class="p">,</span> <span class="n">refine</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d1</strong> – Start of interval.</p></li>
<li><p><strong>d2</strong> – End of interval. Function supports d1 &gt; d2 if refine output is
modified accordingly.</p></li>
<li><p><strong>N</strong> – Number of points to discretize distance between d1 and d2. Note
that if the “constant” refinement is used, this number used as a
baseline for refinement, so that the actual number of points will
be larger. For other variants, the number of outputs is exact.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><dl>
<dt><strong>refine</strong> – A N by 2 matrix that contains the start of refinement</dt><dd><p>intervals in the first column and a refinement factor in the
second. For example, for the interval [0, 1], refine could be:
[0.2,  4; % Use factor 1 from 0 to 0.2 (implicit) and 4 until</p>
<blockquote>
<div><p>0.5,  3; % 0.5, where 3 is used as the factor until the next
0.75, 1] % point 0.75, where the default density is used.</p>
</div></blockquote>
</dd>
<dt>type    - Either constant, where each interval is partitioned</dt><dd><p>separately, or a valid interpolation type for interp1.
Default: Linear.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>x</strong> – Partitioned interval.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="nb">figure</span><span class="p">;</span> <span class="nb">hold</span> <span class="n">on</span>
<span class="n">refine</span> <span class="p">=</span> <span class="p">[(</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span> <span class="p">...</span>
          <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span> <span class="p">...</span>
          <span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span> <span class="c">% Refine interval of 2/3*2*pi -&gt; 3/5 *2*pi</span>
<span class="n">x</span> <span class="p">=</span> <span class="n">discspace1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">refine</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&#39;.&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="p">=</span> <span class="n">discspace1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">refine</span><span class="p">,</span> <span class="s">&#39;pchip&#39;</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&#39;o&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With three inputs, this function is identical to linspace.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>linspace</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dispif">
<span class="sig-name descname"><span class="pre">dispif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">bool</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dispif" title="Permalink to this definition"></a></dt>
<dd><p>Produce textual output contingent upon predicate.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">dispif</span><span class="p">(</span><span class="n">bool</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="nb">arg</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">nc</span> <span class="p">=</span> <span class="n">dispif</span><span class="p">(</span><span class="n">bool</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="nb">arg</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bool</strong> – Boolean variable.</p></li>
<li><p><strong>format</strong> – SPRINTF format specification.</p></li>
<li><p><strong>arg</strong> – OPTIONAL arguments to complete ‘format’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nc</strong> – Number of characters printed to output device.  If ‘bool’ is
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">false</span></code>, then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nc=0</span></code>.  Only returned if specifcially
requested.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Function used for making code cleaner where <code class="xref mat mat-func docutils literal notranslate"><span class="pre">verbose</span></code> option is used.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">sprintf</span></code>, <a class="reference internal" href="#core.utils.tocif" title="core.utils.tocif"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tocif</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.evalFunStandalone">
<span class="sig-name descname"><span class="pre">evalFunStandalone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fn</span></em>, <em class="sig-param"><span class="pre">args</span></em>, <em class="sig-param"><span class="pre">startupPath</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.evalFunStandalone" title="Permalink to this definition"></a></dt>
<dd><p>Utility for performing stand-alone function evaluation in new matlab session
Only intended to be used with system-calls from evalFunWrapper</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.evalFunWrapper">
<span class="sig-name descname"><span class="pre">evalFunWrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fn</span></em>, <em class="sig-param"><span class="pre">args</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.evalFunWrapper" title="Permalink to this definition"></a></dt>
<dd><p>Utility to launch (mrst-)function evaluation in seperate matlab session</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">evalFunWrapper</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<dl class="simple">
<dt>This function launches a seperate matlab session and perfoms the evaluation</dt><dd><p>feval(fn, args{:})</p>
</dd>
</dl>
<p>by invoking evalFunStandalone</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> – function handle of non-anonymous function. Corresponding
m-file must be on matlab/mrst-path (see option moduleList).</p></li>
<li><p><strong>args</strong> – list of function arguments. Supported arguments are strings,
function handles, cellstrings and doubles. Numeric arguments
must be scalar or on row form.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>OPTIONAL PARAMETERS</dt><dd><dl class="simple">
<dt>progressFileNm  - If non-empty a file with name progressFileNm will be</dt><dd><p>written before launcing new session. File is deleted
when new session is done computing fn. File name
should include full path.</p>
</dd>
<dt>moduleList      - List of mrst-modules that will be added in new session</dt><dd><p>Default is currently active modules</p>
</dd>
</dl>
<p>pathList        - List of (non-mrst) paths that will be added</p>
<dl class="simple">
<dt>background      - Option indicating if new session is run in background.</dt><dd><p>(default true)</p>
</dd>
<dt>singleCompThread - Option indicating whether new session should be run</dt><dd><p>using single computational thread (default true)</p>
</dd>
<dt>matlabBinary    - Command to start external Matlab-session. Default is</dt><dd><p>fullfile(matlabroot(), ‘bin’, ‘matlab’), e.g., same
Matlab-version as the one currently running.</p>
</dd>
</dl>
<p>matlabOpts      - String of matlab startup options. Default: see below</p>
<dl class="simple">
<dt>exitWhenDone    - Exit/quit new session when computation is done</dt><dd><p>(default true)</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>status</strong> – when run in background, status will be 0.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">evalFunWrapper</span><span class="p">(@</span><span class="nb">arrayfun</span><span class="p">,</span> <span class="p">{@</span><span class="n">why</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">20</span><span class="p">},</span> <span class="s">&#39;exitWhenDone&#39;</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span>
</pre></div>
</div>
<p>SEE ALSO
evalFunStandalone</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.faceFlux2cellFlux">
<span class="sig-name descname"><span class="pre">faceFlux2cellFlux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">faceFlux</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.faceFlux2cellFlux" title="Permalink to this definition"></a></dt>
<dd><p>Transform face-based flux field to cell-based.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">cellFlux</span> <span class="p">=</span> <span class="n">faceFlux2cellFlux</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faceFlux</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure.</p></li>
<li><p><strong>faceFlux</strong> – Set of face-wise ordered fluxes.  One column for each flux
vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cellFlux</strong> – Set of flux vectors in cell-wise ordering.  One column for
each of the input flux vectors.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.cellFlux2faceFlux" title="core.utils.cellFlux2faceFlux"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cellFlux2faceFlux</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.faceFlux2cellVelocity">
<span class="sig-name descname"><span class="pre">faceFlux2cellVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">faceFlux</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.faceFlux2cellVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Transform face-based flux field to one constant velocity per cell.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">veclocity</span> <span class="p">=</span> <span class="n">faceFlux2cellVelocity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faceFlux</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure.</p></li>
<li><p><strong>faceFlux</strong> – Vector of fluxes corresponding to face ordering.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>velocity</strong> – G.cells.num-by-d matrix of cell velocities.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.cellFlux2faceFlux" title="core.utils.cellFlux2faceFlux"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cellFlux2faceFlux</span></code></a>, <a class="reference internal" href="#core.utils.faceFlux2cellFlux" title="core.utils.faceFlux2cellFlux"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">faceFlux2cellFlux</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.findFilesSubfolders">
<span class="sig-name descname"><span class="pre">findFilesSubfolders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">root</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.findFilesSubfolders" title="Permalink to this definition"></a></dt>
<dd><p>Find all files in a directory hierarchy</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">files</span> <span class="p">=</span> <span class="n">findFilesSubFolders</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>root</strong> – Full or relative path to root of directory hierarchy</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>files</strong> – Cell array of strings naming all files beneath ‘root’.  The
pathnames include the ‘root’.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.formatTimeRange">
<span class="sig-name descname"><span class="pre">formatTimeRange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">time</span></em>, <em class="sig-param"><span class="pre">limit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.formatTimeRange" title="Permalink to this definition"></a></dt>
<dd><p>Small utility which returns a human readable string from seconds.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.geomspace">
<span class="sig-name descname"><span class="pre">geomspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">n</span></em>, <em class="sig-param"><span class="pre">x0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.geomspace" title="Permalink to this definition"></a></dt>
<dd><p>Geometrically spaced vector.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="p">=</span> <span class="n">geomspace</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">L0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x1</strong> – Lower and upper bounds on resulting vector.</p></li>
<li><p><strong>x2</strong> – Lower and upper bounds on resulting vector.</p></li>
<li><p><strong>n</strong> – Number of points to generate between <code class="xref mat mat-func docutils literal notranslate"><span class="pre">x1</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">x2</span></code>, inclusive.
Must be at least two (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code> &gt;= 2).</p></li>
<li><p><strong>L0</strong> – Length of first (and shortest) sub-interval.
Must not exceed <code class="xref mat mat-func docutils literal notranslate"><span class="pre">(x2</span> <span class="pre">-</span> <span class="pre">x1)</span> <span class="pre">/</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1)</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x</strong> – n-point row vector from x1 to x2 constructed such that the length
of consecutive sub-intervals (i.e., DIFF(x)) <em>increases</em> by a
constant (geometric) factor.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is based on solving a polynomial equation of degree n-1
(using the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">roots</span></code> function).  This is an unstable process and,
consequently, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code> should not be too big (usually no greater than 100).</p>
<p>Due to round-off errors, x(end) may differ slightly from x2.</p>
<p>These facts mean that geomspace is not a general utility and its use
should be carefully considered in every instance.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">linspace</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">logspace</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">roots</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.getCanonicalPath">
<span class="sig-name descname"><span class="pre">getCanonicalPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">path_string</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.getCanonicalPath" title="Permalink to this definition"></a></dt>
<dd><p>Get absolute (canonical) path of file in MATLAB and Octave</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">canonical_name</span> <span class="p">=</span> <span class="n">getCanonicalPath</span><span class="p">(</span><span class="s">&#39;/some/path&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path_string</strong> – String of potentially non-existent path that may contain
relative indicators in format..</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>path_string</strong> – Best attempt at getting the canonical path.</p></li>
<li><p><strong>present</strong> – Indicator if file is actually present.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.getSortedCellNodes">
<span class="sig-name descname"><span class="pre">getSortedCellNodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.getSortedCellNodes" title="Permalink to this definition"></a></dt>
<dd><p>Construct n x 2 table of cell edges with edges oriented the same
direction around the cell boundary.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.githubDownload">
<span class="sig-name descname"><span class="pre">githubDownload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">repository</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.githubDownload" title="Permalink to this definition"></a></dt>
<dd><p>Download objects from GitHub (.ZIP or collection of files)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">files</span> <span class="p">=</span> <span class="n">githubDownload</span><span class="p">(</span><span class="n">repository</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>repository</strong> – Name of repository from which to construct object URLs.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘Revision’</strong> – Git revision of objects.  String.  Subject to expansion
through the equivalent of ‘rev-parse’.
Default value: Revision = ‘master’.</p></li>
<li><p><strong>‘File’</strong> – Name of file or files to download from GitHub. String or
cell array of strings respectively.
Default value: File = {} (No specific filename).</p></li>
<li><p><strong>‘All’</strong> – Whether or not to download the entire contents of the
GitHub repository (at specified revision).
Logical.  Default value All=false.</p></li>
<li><p><strong>‘Base’</strong> – Base directory in which a subdirectory named after the
repository will be created to host the requisite contents
of the GitHub repository.
String.  Default value: Base = mrstDataDirectory().</p></li>
<li><p><strong>‘Dest’</strong> – Directory into which the downloaded file set will be moved.
Only taken into account if non-empty.
String.  Default value: Dest = ‘’ (leave downloaded files
in original download location).</p></li>
<li><p><strong>‘Pause’</strong> – Amount of time to wait between successive requests to
GitHub web services.  Only relevant when explicit file list
has more than one entry.
Non-negative scalar.  Default value: Pause = 5 sec.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The user must specify either an explicit list of files or option ‘All’.</p>
<p>If option ‘All’ is set, then this takes precedence over any explicit
file list.  In other words, an explicit file list is ignored if option
‘All’ is set.</p>
<p>Using a small value for ‘Pause’ increases the likelihood that the next
request will fail.  Pause should usually be at least two seconds.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>files</strong> – Cell array of strings containing file names, specific to local
computer system, of the objects downloaded from GitHub.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">repo</span>     <span class="p">=</span> <span class="s">&#39;OPM/opm-data&#39;</span><span class="p">;</span>
<span class="n">rev</span>      <span class="p">=</span> <span class="s">&#39;2198d5b&#39;</span><span class="p">;</span>
<span class="n">filebase</span> <span class="p">=</span> <span class="s">&#39;flow_diagnostic_test/eclipse-simulation&#39;</span><span class="p">;</span>
<span class="n">files</span>    <span class="p">=</span> <span class="nb">strcat</span><span class="p">(</span><span class="s">&#39;SIMPLE_SUMMARY.&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="s">&#39;INIT&#39;</span><span class="p">,</span> <span class="s">&#39;UNRST&#39;</span><span class="p">,</span> <span class="s">&#39;UNSMRY&#39;</span> <span class="p">});</span>

<span class="n">files</span> <span class="p">=</span> <span class="n">githubDownload</span><span class="p">(</span><span class="n">repo</span><span class="p">,</span> <span class="s">&#39;Revision&#39;</span><span class="p">,</span> <span class="n">rev</span><span class="p">,</span> <span class="p">...</span>
                       <span class="s">&#39;File&#39;</span><span class="p">,</span> <span class="nb">strcat</span><span class="p">(</span><span class="n">filebase</span><span class="p">,</span> <span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">files</span><span class="p">));</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">websave</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">unzip</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDataDirectory</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.incompHydrostaticPressure">
<span class="sig-name descname"><span class="pre">incompHydrostaticPressure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">contacts</span></em>, <em class="sig-param"><span class="pre">densities</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.incompHydrostaticPressure" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.initVariablesADI">
<span class="sig-name descname"><span class="pre">initVariablesADI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.initVariablesADI" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a set of automatic differentiation variables</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">a</span>            <span class="p">=</span> <span class="n">initVariablesADI</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="p">=</span> <span class="n">initVariablesADI</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>varargin</strong> – <p>Any number of variables in either column vector format or as
scalars. These variables will be instantiate as ADI objects
containing both a .val field and a .jac jacobian. These
variables will start with identity jacobians with regards to
themselves and zero jacobians with regards to the other
variables (implicitly defined by the ordering of input and
output).</p>
<p>These variables can then be used to create more complex
expressions, resulting in automatic compuation of the first
order derivatives leading to easy implementation of
Newton-like nonlinear solvers.</p>
</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">y</span> <span class="p">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">=</span> <span class="n">initVariablesADI</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="n">This</span> <span class="n">gives</span> <span class="n">x</span><span class="p">.</span><span class="n">jac</span> <span class="o">-&gt;</span>  <span class="p">{[</span><span class="mi">1</span><span class="p">]</span>  <span class="p">[</span><span class="mi">0</span><span class="p">]}</span> <span class="nb">and</span> <span class="n">y</span><span class="p">.</span><span class="n">jac</span> <span class="o">-&gt;</span>  <span class="p">{[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">[</span><span class="mi">1</span><span class="p">]}.</span>

<span class="n">If</span> <span class="n">we</span> <span class="n">compute</span> <span class="n">z</span> <span class="p">=</span> <span class="n">x</span><span class="o">.*</span><span class="n">y</span><span class="o">.^</span><span class="mi">2</span> <span class="n">we</span> <span class="k">get</span>

<span class="n">z</span><span class="p">.</span><span class="n">val</span> <span class="p">=</span> <span class="mi">25</span> <span class="p">(</span><span class="n">as</span> <span class="n">is</span> <span class="n">expected</span><span class="p">),</span>
<span class="n">z</span><span class="p">.</span><span class="n">jac</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="p">=</span> <span class="n">d</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span>^<span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span> <span class="p">=</span> <span class="n">y</span>^<span class="mi">2</span> <span class="p">=</span> <span class="mi">5</span>^<span class="mi">2</span> <span class="p">=</span> <span class="mi">25</span>
<span class="n">z</span><span class="p">.</span><span class="n">jac</span><span class="p">{</span><span class="mi">2</span><span class="p">}</span> <span class="p">=</span> <span class="n">d</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span>^<span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">dy</span> <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="o">*</span><span class="mi">5</span> <span class="p">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="n">Note</span> <span class="n">that</span> <span class="n">as</span> <span class="n">this</span> <span class="n">is</span> <span class="n">meant</span> <span class="k">for</span> <span class="n">vector</span> <span class="n">operations</span><span class="p">,</span> <span class="n">the</span>
<span class="n">element</span><span class="o">-</span><span class="n">wise</span> <span class="n">operations</span> <span class="n">should</span> <span class="n">be</span> <span class="n">used</span> <span class="p">(</span><span class="o">.*</span> <span class="n">instead</span> <span class="n">of</span> <span class="o">*</span><span class="p">)</span> <span class="n">even</span> <span class="n">when</span>
<span class="n">dealing</span> <span class="n">with</span> <span class="n">scalars</span><span class="p">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>varargout</strong> – The same variables as inputted, as ADI objects.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ADI</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.interpTable">
<span class="sig-name descname"><span class="pre">interpTable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">X</span></em>, <em class="sig-param"><span class="pre">Y</span></em>, <em class="sig-param"><span class="pre">xi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.interpTable" title="Permalink to this definition"></a></dt>
<dd><p>Interpolate a one-dimensional table, possibly using splines.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">yi</span> <span class="p">=</span> <span class="n">interpTable</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
<span class="n">yi</span> <span class="p">=</span> <span class="n">interpTable</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – Nodes at which underlying function y=y(x) is sampled.</p></li>
<li><p><strong>Y</strong> – Values of the underlying function y=y(x) at the nodes, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">X</span></code>.</p></li>
<li><p><strong>xi</strong> – Evaluation points for new, interpolated, function values.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘spline’</strong> – Whether or not to use spline interpolation.
Logical.  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">spline=false</span></code> (use linear
interpolation/extrapolation).</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>yi</strong> – Approximate (interpolated/extrapolated) values of the function
y=y(x) at the points <code class="xref mat mat-func docutils literal notranslate"><span class="pre">xi</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.dinterpTable" title="core.utils.dinterpTable"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dinterpTable</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">interp1</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">spline</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.interpTableMEX">
<span class="sig-name descname"><span class="pre">interpTableMEX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">X</span></em>, <em class="sig-param"><span class="pre">Y</span></em>, <em class="sig-param"><span class="pre">xi</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.interpTableMEX" title="Permalink to this definition"></a></dt>
<dd><p>Interpolate a one-dimensional table with MEX acceleration</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">yi</span> <span class="p">=</span> <span class="n">interpTable</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
<span class="n">yi</span> <span class="p">=</span> <span class="n">interpTable</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – Nodes at which underlying function y=y(x) is sampled.</p></li>
<li><p><strong>Y</strong> – Values of the underlying function y=y(x) at the nodes, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">X</span></code>.</p></li>
<li><p><strong>xi</strong> – Evaluation points for new, interpolated, function values.</p></li>
<li><p><strong>method</strong> – (OPTIONAL) Choose the interpolation method used:
1 corresponds to a binary search (optimal for a single lookup
in ordered data, default, generally fastest if points are
given on an uneven grid)
2 will use a binning algorithm which can in very particular
cases be faster when a large number of lookups is required.
3 will assume that X is completely uniform in grid size. Only
the first two entries are used. May give wrong results when
assumption is violated - no verification is performed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>yi</strong> – Approximate (interpolated/extrapolated) values of the function
y=y(x) at the points <code class="xref mat mat-func docutils literal notranslate"><span class="pre">xi</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.interpTable" title="core.utils.interpTable"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">interpTable</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine has less functionality and validation of inputs than
interpTable, but can be significantly faster.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.isCoarseGrid">
<span class="sig-name descname"><span class="pre">isCoarseGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.isCoarseGrid" title="Permalink to this definition"></a></dt>
<dd><p>Check if a grid is a coarse grid or a fine grid</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">isCoarse</span> <span class="p">=</span> <span class="n">isCoarsegrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>isCoarse</strong> – Boolean indicating of the grid is a coarse grid made from a
finer grid.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.plotting.plotGrid" title="core.plotting.plotGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">plotGrid</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">generateCoarseGrid</span></code></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mcolon">
<span class="sig-name descname"><span class="pre">mcolon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">lo</span></em>, <em class="sig-param"><span class="pre">hi</span></em>, <em class="sig-param"><span class="pre">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mcolon" title="Permalink to this definition"></a></dt>
<dd><p>Compute vector of consecutive indices from separate lower/upper bounds.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">ind</span> <span class="p">=</span> <span class="n">mcolon</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
<span class="n">ind</span> <span class="p">=</span> <span class="n">mcolon</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lo</strong> – Vector of start values (lower bounds).</p></li>
<li><p><strong>hi</strong> – Vector of end values (upper bounds).</p></li>
<li><p><strong>s</strong> – Vector of strides.
Optional.  Default value: s = ones([numel(lo), 1]) (unit stride).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ind</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[lo(1):hi(1)</span>&#160;&#160;&#160;&#160; <span class="pre">,</span> <span class="pre">lo(2):hi(2)</span>&#160;&#160;&#160;&#160; <span class="pre">,...,</span> <span class="pre">lo(end):hi(end)]</span></code></p></li>
<li><p><strong>ind</strong> – <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[lo(1):s(1):hi(1),</span> <span class="pre">lo(2):s(2):hi(2),...,lo(end):s(end):hi(end)]</span></code></p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">lo</span>  <span class="p">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">];</span> <span class="n">hi</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">];</span>
<span class="n">ind</span> <span class="p">=</span> <span class="n">mcolon</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Note that <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ind</span></code> has type <code class="xref mat mat-func docutils literal notranslate"><span class="pre">double</span></code> irrespective of the type of its input
parameters.</p>
<p><a class="reference internal" href="#core.utils.mcolon" title="core.utils.mcolon"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mcolon</span></code></a> may be implemented in terms of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">arrayfun</span></code> and <code class="xref mat mat-func docutils literal notranslate"><span class="pre">horzcat</span></code>, e.g.,</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ind</span> <span class="p">=</span> <span class="n">arrayfun</span><span class="p">(@</span><span class="n">colon</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="s">&#39;UniformOutput&#39;</span><span class="p">,</span> <span class="n">false</span><span class="p">);</span>
<span class="n">ind</span> <span class="p">=</span> <span class="p">[</span><span class="n">ind</span><span class="p">{:}];</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ind</span> <span class="p">=</span> <span class="n">arrayfun</span><span class="p">(@</span><span class="n">colon</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="s">&#39;UniformOutput&#39;</span><span class="p">,</span> <span class="n">false</span><span class="p">);</span>
<span class="n">ind</span> <span class="p">=</span> <span class="p">[</span><span class="n">ind</span><span class="p">{:}];</span>
</pre></div>
</div>
<p>but the current implementation is faster.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.md5sum_fallback">
<span class="sig-name descname"><span class="pre">md5sum_fallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.md5sum_fallback" title="Permalink to this definition"></a></dt>
<dd><p>Alternative implementation of md5sum for systems without C compiler.
Requires java.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.merge_options">
<span class="sig-name descname"><span class="pre">merge_options</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">prm</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.merge_options" title="Permalink to this definition"></a></dt>
<dd><p>Override default control options.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">prm</span>         <span class="p">=</span> <span class="n">merge_options</span><span class="p">(</span><span class="n">prm</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="p">[</span><span class="n">prm</span><span class="p">,</span> <span class="n">extra</span><span class="p">]</span> <span class="p">=</span> <span class="n">merge_options</span><span class="p">(</span><span class="n">prm</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prm</strong> – Original/default option structure.  The contents of this structure
is problem specific and defined by the caller.</p></li>
<li><p><strong>'pn'/pv</strong> – <p>List of ‘key’/value pairs overriding default options in ‘prm’.</p>
<p>A warning is issued, and no assignment made, if a particular <code class="xref mat mat-func docutils literal notranslate"><span class="pre">key</span></code>
is not already present in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">fieldnames(prm)</span></code>.  The message identifier
of this warning is</p>
<blockquote>
<div><p>[&lt;FUNCTIONNAME&gt;, ‘:Option:Unsupported’]</p>
</div></blockquote>
<p>with &lt;FUNCTIONNAME&gt; being the name of function <a class="reference internal" href="#core.utils.merge_options" title="core.utils.merge_options"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">merge_options</span></code></a>’
caller or the string ‘BASE’ if <a class="reference internal" href="#core.utils.merge_options" title="core.utils.merge_options"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">merge_options</span></code></a> is used directly from
the base workspace (i.e., the Command Window).</p>
<p>Function <a class="reference internal" href="#core.utils.merge_options" title="core.utils.merge_options"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">merge_options</span></code></a> will fail (and call ERROR) if the new
value’s class is different from the class of the existing value.</p>
<p>In the interest of convenience for the typical case of using MRST
interactively from the Command Window, <a class="reference internal" href="#core.utils.merge_options" title="core.utils.merge_options"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">merge_options</span></code></a> matches keys
(option names) using case insensitive search (i.e., using function
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">strcmpi</span></code>).  If multiple option fields match a given name, such as
in the case of several fields differing only by capitalisation, the
<a class="reference internal" href="#core.utils.merge_options" title="core.utils.merge_options"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">merge_options</span></code></a> function resorts to exact and case sensitive string
matching (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">strcmp</span></code>) to disambiguate options.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul>
<li><p><strong>prm</strong> – Modified parameter structure.</p></li>
<li><p><strong>extra</strong> – Cell array of ‘key’/value pairs from the ‘pn’/pv list that were not
matched by any option in the control structure ‘prm’.  This allows
using function <a class="reference internal" href="#core.utils.merge_options" title="core.utils.merge_options"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">merge_options</span></code></a> in an intermediate layer to define a
set of options and to pass other options unchanged on to lower-level
implementation functions–for instance to wrap a pressure solver in
a higher-level structure.</p>
<p>If the caller requests extra output be returned, then no diagnostic
message will be emitted for unsupported/undeclared option pairs in
the input list.</p>
<p>If there are no unsupported options in the input list then ‘extra’
is an empty cell array.</p>
</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the value of a field of the input parameters (‘prm’) is a <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cell</span></code>
array, then the overriding value of that field can be anything.  If the
new value is another <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cell</span></code> array (i.e., if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">iscell</span></code> returns true) it
will simply be assigned.  Otherwise, we wrap the overriding value in a
cell array so that the field value is always a <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cell</span></code> array.</p>
<p>This behaviour allows the user of function <a class="reference internal" href="#core.utils.merge_options" title="core.utils.merge_options"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">merge_options</span></code></a> to implement
uniform support for both single elements and heterogeneous collections
of data in a single option.  That in turn is useful in, for instance, a
visualisation application.</p>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Typical use</span>
<span class="n">prm</span> <span class="p">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="nb">pi</span><span class="p">,</span> <span class="s">&#39;baz&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
<span class="n">prm</span> <span class="p">=</span> <span class="n">merge_options</span><span class="p">(</span><span class="n">prm</span><span class="p">,</span> <span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="s">&#39;FimFoo&#39;</span><span class="p">,</span> <span class="p">@</span><span class="nb">exp</span><span class="p">)</span>

<span class="c">% 2) Heterogeneous collection in a `cell` array</span>
<span class="n">prm</span> <span class="p">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="p">{{</span> <span class="p">(@(</span><span class="n">x</span><span class="p">)</span> <span class="n">x</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span> <span class="p">}})</span> <span class="c">% &#39;f&#39; is cell array of f-handles</span>
<span class="n">prm</span> <span class="p">=</span> <span class="n">merge_options</span><span class="p">(</span><span class="n">prm</span><span class="p">,</span> <span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="p">@</span><span class="nb">exp</span><span class="p">)</span>  <span class="c">% Pass a simple function handle</span>
<span class="nb">fplot</span><span class="p">(</span><span class="n">prm</span><span class="p">.</span><span class="n">f</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>              <span class="c">% Reference cell array result</span>

<span class="c">% 3) Heterogeneous collection in a `cell` array</span>
<span class="n">prm</span> <span class="p">=</span> <span class="nb">struct</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="p">{{</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">}})</span>   <span class="c">% &#39;d&#39; is cell array of data points</span>

<span class="c">% Pass multiple data sets</span>
<span class="n">prm</span> <span class="p">=</span> <span class="n">merge_options</span><span class="p">(</span><span class="n">prm</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nb">ones</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span> <span class="p">})</span>

<span class="c">% Plot &quot;last&quot; data set</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">prm</span><span class="p">.</span><span class="n">d</span><span class="p">{</span><span class="k">end</span><span class="p">},</span> <span class="s">&#39;.-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fieldnames</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">warning</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">strcmpi</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">strcmp</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.merge_options_relaxed">
<span class="sig-name descname"><span class="pre">merge_options_relaxed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">opt</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.merge_options_relaxed" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>A less general version of merge_options focused on specific choices:</dt><dd><ul class="simple">
<li><p>Arguments must match the names of fields exactly</p></li>
<li><p>No type checking</p></li>
<li><p>Errors for unsupported fields</p></li>
</ul>
</dd>
</dl>
<p>INTENTIONALLY UNDERDOCUMENTED, SUBJECT TO CHANGE.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.moduleGUI">
<span class="sig-name descname"><span class="pre">moduleGUI</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.moduleGUI" title="Permalink to this definition"></a></dt>
<dd><p>Interactive user interface for activation/deactivation of known mrst modules</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">moduleGUI</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>No input or output arguments. <a class="reference internal" href="#core.utils.moduleGUI" title="core.utils.moduleGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">moduleGUI</span></code></a> launches an interactive user
interface for activation and de-activation of models. In addition, some
rudimentary features for listing files by right-clicking a module is
included.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.mrstModule" title="core.utils.mrstModule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstModule</span></code></a>, <a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstConfigureMETISLocations">
<span class="sig-name descname"><span class="pre">mrstConfigureMETISLocations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstConfigureMETISLocations" title="Permalink to this definition"></a></dt>
<dd><p>Configure Installed Location of METIS Library and Associate Header Files</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">mrstConfigureMETISLocations</span><span class="p">(</span><span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="s">&#39;pv1&#39;</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">cfg</span> <span class="p">=</span> <span class="n">mrstConfigureMETISLocations</span><span class="p">()</span>
<span class="n">cfg</span> <span class="p">=</span> <span class="n">mrstConfigureMETISLocations</span><span class="p">(</span><span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="s">&#39;pv1&#39;</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>include</strong> – Configure include directory.  Directory is expected to
contain the &lt;metis.h&gt; header directly.  Option name can be
abbreviated to ‘inc’ or ‘i’ (case insensitively)-mostly for
the case of interactive configuration in the Command Window.</p></li>
<li><p><strong>library</strong> – Configure library directory.  Option name can be abbreviated
to ‘lib’ or ‘l’ (ell, case insensitively)-mostly for the
case of interactive configuration in the Command Window.</p></li>
<li><p><strong>binary</strong> – Configure dynamic link directory-needed for DLLs on Windows.
Option name can be abbreviated to ‘bin’ or ‘dll’ (case
insensitively)-mostly for the case of interactive
configuration in the Command Window.</p></li>
<li><p><strong>libmetis</strong> – Configure METIS library name.  Typically just ‘metis’, but
can be overridden if the installed version has some kind of
name decoration (e.g., to distinguish debug/profile/release).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If at all possible, we recommend linking to a static version of the
METIS library since this reduces the risk of conflicting with any
internal METIS DLL (SO) used by MATLAB.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>cfg</strong> – METIS configuration structure.  Contains the following fields
* bindir   - METIS dynamic link library
* incdir   - METIS include directory (MEX -I)
* libdir   - METIS library directory (MEX -L)
* libmetis - METIS library name (MEX -l)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>mrstDefaultMexFlags, buildmex, mex.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstDebug">
<span class="sig-name descname"><span class="pre">mrstDebug</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstDebug" title="Permalink to this definition"></a></dt>
<dd><p>Globally control default settings for MRST debugging information.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Either</span> <span class="n">of</span> <span class="n">the</span> <span class="n">modes</span>
  <span class="mi">1</span><span class="p">)</span>     <span class="n">mrstDebug</span> <span class="nb">arg</span>
  <span class="mi">2</span><span class="p">)</span> <span class="n">d</span> <span class="p">=</span> <span class="n">mrstDebug</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function provides a centralised facility for individual MRST
function to query debugging support default setting.  Specifically, if
a function provides debugging support (e.g., additional state checks)
in the form of a debugging option, then the function is encouraged to
initialise the debugging flag with the output of this function.
Debugging output may then be subsequently overridden on an individual,
per-function basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> – <p>Control mode for debugging support. OPTIONAL.  Must be one of
- String, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'off',</span> <span class="pre">'on'}</span></code>, for globally disabling or enabling</p>
<blockquote>
<div><p>MRST debugging support.  Actual effects depends on specific
setting in individual functions and may usually be controlled
more targetly.  The default state is ‘off’.</p>
</div></blockquote>
<ul class="simple">
<li><p>String, ‘reset’, for restoring debugging setting to the
default state: mrstDebug off</p></li>
<li><p>Logical, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">{false,</span> <span class="pre">true}</span></code>, for disabling or enabling MRST
debugging support.</p></li>
<li><p>Numeric (Real) scalar value.  Specifically set debugging
level.  A debugging level exceeding zero enables debugging.
Whether or not higher values produce more output is at the
discretion of individual MRST functions.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – A numeric scalar value.  D==0 turns default state of debugging
support off, while d&gt;0 signifies different levels of debugging
support.  Individual callers of ‘mrstDebug’ (typically other
MRST functions) must support a Boolean on/off state, but may,
optionally, support a notion of debugging levels where higher
levels signify more invasive (and expensive) checks.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Demonstrate &#39;String&#39; form (Command and Function syntax).</span>
<span class="n">mrstDebug</span>  <span class="n">on</span>    <span class="c">% Enable debugging support.</span>
<span class="n">mrstDebug</span><span class="p">(</span><span class="s">&#39;off&#39;</span><span class="p">)</span> <span class="c">% Disable debugging (default state).</span>
<span class="n">mrstDebug</span> <span class="nb">reset</span>  <span class="c">% Restore debugging defaults (off).</span>

<span class="c">% 2) Demonstrate &#39;Logical&#39; form of mrstDebug function.</span>
<span class="c">%    (only Function syntax supported in this case).</span>
<span class="n">mrstDebug</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>  <span class="c">% Enable debugging.</span>
<span class="n">mrstDebug</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="c">% Disable debugging (default state).</span>

<span class="c">% 3) Demonstrate &#39;Numeric&#39; form of mrstDebug function.</span>
<span class="c">%    (only Function syntax supported in this case).</span>
<span class="n">mrstDebug</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c">% Enable debugging.</span>
<span class="n">mrstDebug</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c">% Disable debugging.</span>
<span class="n">mrstDebug</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="c">% Set debugging level to 2.</span>

<span class="c">% 4) Retrieve current debugging setting.</span>
<span class="c">%    (Only function syntax supported in this case).</span>
<span class="n">d</span> <span class="p">=</span> <span class="n">mrstDebug</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstDefaultMexFlags">
<span class="sig-name descname"><span class="pre">mrstDefaultMexFlags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstDefaultMexFlags" title="Permalink to this definition"></a></dt>
<dd><p>Define Common Compiler and Linker Flags/Libraries for MRST’s MEX Functions</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">CXXFLAGS</span>               <span class="p">=</span> <span class="n">mrstDefaultMexFlags</span><span class="p">()</span>
<span class="n">CXXFLAGS</span>               <span class="p">=</span> <span class="n">mrstDefaultMexFlags</span><span class="p">(</span><span class="n">defines</span><span class="p">)</span>
<span class="p">[</span><span class="n">CXXFLAGS</span><span class="p">,</span> <span class="n">LINK</span><span class="p">]</span>       <span class="p">=</span> <span class="n">mrstDefaultMexFlags</span><span class="p">(...)</span>
<span class="p">[</span><span class="n">CXXFLAGS</span><span class="p">,</span> <span class="n">LINK</span><span class="p">,</span> <span class="n">LIBS</span><span class="p">]</span> <span class="p">=</span> <span class="n">mrstDefaultMexFlags</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>defines</strong> – Character vector, or cell-array of character vectors, of
user-specified preprocessor symbols that will be included in
the list of compiler flags and passed on to the compiler as
‘#define’-d symbols.  OPTIONAL.  No additional preprocessor
symbols defined if this parameter is not specified.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>CXXFLAGS</strong> – Compiler flags, including flags to enable OpenMP if
available in the primary toolchain.  Assumed to be forwarded
on to a C++ compiler.  Cell-array of character vectors.</p></li>
<li><p><strong>LINK</strong> – Additional flags to pass on to the toolchain linker.
Typically includes the path to MATLAB’s binary/DLL/DSO
directory for the current architecture (COMPUTER(‘arch’)).
Cell-array of character vectors.</p></li>
<li><p><strong>LIBS</strong> – Additional run-time libraries that are typically needed in
MRST’s MEX functions.  Includes references to MATLAB’s
built-in LAPACK and BLAS implementations (Intel’s MKL) and
typically also an OpenMP runtime support library.
Cell-array of character vectors.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function assumes that the MRST MEX function in turn is implemented
in the C++ language.</p>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Define set of compiler/linker/library flags for a MEX function whose</span>
<span class="c">% implementation can optionally use OpenMP and the AMGCL package if</span>
<span class="c">% activated at compile time through preprocessor symbols.</span>

<span class="p">[</span><span class="n">CXXFLAGS</span><span class="p">,</span> <span class="n">LINK</span><span class="p">,</span> <span class="n">LIBS</span><span class="p">]</span> <span class="p">=</span> <span class="p">...</span>
    <span class="n">mrstDefaultMexFlags</span><span class="p">({</span><span class="s">&#39;USE_OPENMP&#39;</span><span class="p">,</span> <span class="s">&#39;USE_AMGCL&#39;</span><span class="p">})</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.buildmex" title="core.utils.buildmex"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">buildmex</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mex.getCompilerConfigurations</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">computer</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstExamples">
<span class="sig-name descname"><span class="pre">mrstExamples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstExamples" title="Permalink to this definition"></a></dt>
<dd><p>Discover Example M-Files Pertaining to One or More MRST Modules</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">mrstExamples</span> <span class="p">[</span><span class="n">module</span> <span class="n">list</span><span class="p">]</span>
 <span class="n">mrstExamples</span> <span class="nb">all</span>

<span class="n">exList</span> <span class="p">=</span> <span class="n">mrstExamples</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>varargin</strong> – <p>Sequence of strings that are treated as names of registered
MRST modules (see functions <a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a> and <a class="reference internal" href="#core.utils.mrstModule" title="core.utils.mrstModule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstModule</span></code></a>).  The
special module name ‘core’, although not a module in a strict
sense, represents those examples that are available in the base
MRST package–i.e., without activating any modules at all.</p>
<p>Alternatively, the single string ‘all’ can be given to list the
examples in all registered modules including the base MRST
package.</p>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>exList</strong> – A cell array of same length as the number of input arguments,
where each entry itself is a list (cell array of strings) of
the paths to the examples of the corresponding module.  For
instance, if called as</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">exList</span> <span class="p">=</span> <span class="n">mrstExamples</span><span class="p">(</span><span class="s">&#39;ad-blackoil&#39;</span><span class="p">,</span> <span class="s">&#39;diagnostics&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">exList{1}</span></code> will be a cell array of the examples relating
to module <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-blackoil</span></code> while <code class="xref mat mat-func docutils literal notranslate"><span class="pre">exList{2}</span></code> is a cell array of
the examples of module <code class="xref mat mat-func docutils literal notranslate"><span class="pre">diagnostics</span></code>.</p>
<p>If called using the special string ‘all’, then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">exList</span></code>
contains one element for each known module and one additional
element, specifically <code class="xref mat mat-func docutils literal notranslate"><span class="pre">exList{1}</span></code>, corresponding to the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">core</span></code>
(i.e., base) MRST package.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If no output argument is given, the routine instead prints clickable
editor links of all examples to the command window.</p>
<p>Examples are defined as all M files found in the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">examples</span></code> directory
of a module–excluding any M files in a subdirectory called <code class="xref mat mat-func docutils literal notranslate"><span class="pre">utils</span></code>.
Subdirectories of the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">examples</span></code> directory other than <code class="xref mat mat-func docutils literal notranslate"><span class="pre">utils</span></code> are
searched recursively.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.mrstModule" title="core.utils.mrstModule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstModule</span></code></a>, <a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstExtraDirs">
<span class="sig-name descname"><span class="pre">mrstExtraDirs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstExtraDirs" title="Permalink to this definition"></a></dt>
<dd><p>Get List of Directories Added to MATLAB’s Search PATH by MRST</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="p">=</span> <span class="n">mrstExtraDirs</span><span class="p">()</span>
<span class="n">p</span> <span class="p">=</span> <span class="n">mrstExtraDirs</span><span class="p">(</span><span class="n">search</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>search</strong> – <p>String or cell-array of strings containing partial paths that
will be matched against the full list of MRST’s extra
directories.  Only those directories that match at least one
of the search strings will be returned.  Nested cell-array
structure is not preserved.</p>
<p>OPTIONAL: If empty or not present, all of MRST’s extra
directories will be returned.</p>
<p>String matching is aware of platform conventions.  We use case
insensitive matching on Microsoft Windows, and case sensistive
matching on Unix-like systems.</p>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Cell array of strings with each element being a path to a directory
added by activating MRST or through the MRST module system.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Show all MRST directories</span>
<span class="nb">strvcat</span><span class="p">(</span><span class="n">mrstExtraDirs</span><span class="p">())</span>

<span class="c">% 2) Show all MRST directories that match the string (partial path)</span>
<span class="c">%       FULLFILE(&#39;dataset_manager&#39;, &#39;datasets&#39;)</span>
<span class="nb">strvcat</span><span class="p">(</span><span class="n">mrstExtraDirs</span><span class="p">(</span><span class="nb">fullfile</span><span class="p">(</span><span class="s">&#39;dataset_manager&#39;</span><span class="p">,</span> <span class="s">&#39;datasets&#39;</span><span class="p">)))</span>

<span class="c">% 3) Show all MRST directories that match either of the strings</span>
<span class="c">%       &#39;wells_and_bc&#39;, &#39;testgrids&#39;</span>
<span class="c">%</span>
<span class="c">% a) As separate string arguments.</span>
<span class="nb">strvcat</span><span class="p">(</span><span class="n">mrstExtraDirs</span><span class="p">(</span><span class="s">&#39;wells_and_bc&#39;</span><span class="p">,</span> <span class="s">&#39;testgrids&#39;</span><span class="p">))</span>

<span class="c">% b) As a single cell-array of strings.</span>
<span class="nb">strvcat</span><span class="p">(</span><span class="n">mrstExtraDirs</span><span class="p">({</span><span class="s">&#39;wells_and_bc&#39;</span><span class="p">,</span> <span class="s">&#39;testgrids&#39;</span><span class="p">}))</span>

<span class="c">% c) As a single cell-array with nested cell-arrays of strings.</span>
<span class="nb">strvcat</span><span class="p">(</span><span class="n">mrstExtraDirs</span><span class="p">({</span><span class="s">&#39;wells_and_bc&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;testgrids&#39;</span><span class="p">}}))</span>

<span class="c">% d) As a mix of strings and multiply nested cell-arrays of strings.</span>
<span class="nb">strvcat</span><span class="p">(</span><span class="n">mrstExtraDirs</span><span class="p">(</span><span class="s">&#39;wells_and_bc&#39;</span><span class="p">,</span> <span class="p">{{{</span><span class="s">&#39;testgrids&#39;</span><span class="p">}}}))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ROOTDIR, mrstPath, mrstModule, addpath.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstIsLiveEditorDir">
<span class="sig-name descname"><span class="pre">mrstIsLiveEditorDir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dirname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstIsLiveEditorDir" title="Permalink to this definition"></a></dt>
<dd><p>Detect if Script is Run From Live Editor or in Cell Mode</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">tf</span> <span class="p">=</span> <span class="n">mrstIsLiveEditorDir</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dirname</strong> – <p>Directory name.  Character vector or string if availble in
the current version of MATLAB.  Usually derived from a
statement of the form:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">dirname</span> <span class="p">=</span> <span class="n">fileparts</span><span class="p">(</span><span class="n">mfilename</span><span class="p">(</span><span class="s">&#39;fullpath&#39;</span><span class="p">))</span>
</pre></div>
</div>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tf</strong> – Logical flag identifying if the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dirname</span></code> is likely to be a Live
Editor directory or if the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dirname</span></code> is the containing directory
of a script that is run interactively in Cell Mode.  TRUE in case
of live editor directory or empty <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dirname</span></code>, FALSE otherwise.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fileparts</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mfilename</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstModule">
<span class="sig-name descname"><span class="pre">mrstModule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstModule" title="Permalink to this definition"></a></dt>
<dd><p>Query or modify list of activated add-on MRST modules</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Either</span> <span class="n">of</span> <span class="n">the</span> <span class="n">modes</span>
   <span class="mi">1</span><span class="p">)</span> <span class="n">mrstModule</span> <span class="o">&lt;</span><span class="n">command</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">module</span> <span class="n">list</span><span class="p">]</span>
   <span class="mi">2</span><span class="p">)</span> <span class="n">modules</span> <span class="p">=</span> <span class="n">mrstModule</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>command</strong> – <p><em>Mode 1 only</em>: One of the explicit verbs ‘add’, ‘clear’,
‘list’ or ‘reset’. The semantics of the command verbs
are as follows:</p>
<blockquote>
<div><ul>
<li><p>add - Activate specified modules from the
[module list].  Modules already activated are
moved to the beginning of MATLAB’s search path
and remain active.</p></li>
<li><p>clear - Deactivate all modules.  An explicit
module list, if present, is ignored.</p></li>
<li><p>list - Display list of currently active modules
in command window.  An explicit module list, if
present, is ignored.</p></li>
<li><p>reset - Convenience verb.  Equivalent to the
verb sequence:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">mrstModule</span> <span class="n">clear</span>
<span class="n">mrstModule</span> <span class="n">add</span> <span class="p">[</span><span class="n">module</span> <span class="n">list</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>gui - Launch user interface for loading and
unloading modules. Equivialent to calling
<a class="reference internal" href="#core.utils.moduleGUI" title="core.utils.moduleGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">moduleGUI</span></code></a> directly.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>module_list</strong> – <em>Mode 1 only</em>: A sequence of strings naming individual
add-on modules for MRST.  The mapping of module names
to system paths is performed by function <a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>modules</strong> – <em>Mode 2 only</em>: List, represented as a cell array of
strings, of the currently active add-on modules.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mrstModule</span> <span class="n">add</span> <span class="n">deckformat</span> <span class="n">ad</span><span class="o">-</span><span class="n">core</span> <span class="n">spe10</span>

<span class="n">mrstModule</span> <span class="n">list</span>
<span class="n">mrstModule</span> <span class="n">clear</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstNargInCheck">
<span class="sig-name descname"><span class="pre">mrstNargInCheck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">low</span></em>, <em class="sig-param"><span class="pre">high</span></em>, <em class="sig-param"><span class="pre">nargIn</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstNargInCheck" title="Permalink to this definition"></a></dt>
<dd><p>Check number of input arguments to function</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mrstNargInCheck</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">nargIn</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Fails execution (calls <code class="xref mat mat-func docutils literal notranslate"><span class="pre">error</span></code>) unless actual number of input arguments
to calling function is between lower and upper limits inclusive.  This
function should usually not be called within a loop as it is
implemented in terms of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dbstack</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>low</strong> – Minumum number of input arguments needed by calling function.
If empty (i.e., if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(low))</span></code>, this limit is not checked.</p></li>
<li><p><strong>high</strong> – Maximum number of input arguments allowed by calling function.
If empty (i.e., if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">isempty(high))</span></code>, this limit is not checked.</p></li>
<li><p><strong>nargIn</strong> – Actual number of input arguments.  Must be scalar, integral
and non-negative.  Should be <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nargin</span></code> unless there are special
circumstances.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nargin</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nargchk</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">narginchk</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">error</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dbstack</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstPath">
<span class="sig-name descname"><span class="pre">mrstPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstPath" title="Permalink to this definition"></a></dt>
<dd><p>Establish and maintain mapping from module names to system directory paths</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Either</span> <span class="n">of</span> <span class="n">the</span> <span class="n">modes</span>
   <span class="mi">1</span><span class="p">)</span> <span class="n">mrstPath</span> <span class="n">register</span> <span class="n">list</span>
   <span class="mi">2</span><span class="p">)</span> <span class="n">mrstPath</span> <span class="o">&lt;</span><span class="n">command</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">module</span> <span class="n">list</span><span class="p">]</span>
   <span class="mi">3</span><span class="p">)</span> <span class="n">mrstPath</span> <span class="p">[</span><span class="n">search</span><span class="p">]</span> <span class="n">module</span> <span class="n">list</span>
      <span class="n">paths</span> <span class="p">=</span> <span class="n">mrstPath</span><span class="p">(</span><span class="s">&#39;search&#39;</span><span class="p">,</span> <span class="n">module</span> <span class="n">list</span><span class="p">)</span>
      <span class="n">paths</span> <span class="p">=</span> <span class="n">mrstPath</span><span class="p">(</span><span class="n">module</span> <span class="n">list</span><span class="p">)</span>
      <span class="n">paths</span> <span class="p">=</span> <span class="n">mrstPath</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p><a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a> manages the mapping between the local file system and the
abstract modules used by the <a class="reference internal" href="#core.utils.mrstModule" title="core.utils.mrstModule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstModule</span></code></a> function.  This function can
add and remove module mappings and query the file-system mapping of
existing modules.  For this reason, a number of different calling
syntaxes are available:</p>
<dl>
<dt>Mode 1)</dt><dd><p>Register (insert) new mappings of module names to system paths
(directories) into the current list.  In this case, the ‘list’ must
contain an even number of strings, the odd numbered ones being
interpreted as module names and the even numbered interpreted as
directories.  The directories must exist (i.e., function ISDIR must
return TRUE) to register a mapping.</p>
<p>The pathname resolution algorithm is as follows (note: DIRARG is one
of the directory arguments in the above list while MODNAME is the
corresponding module name):</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">ISDIR</span><span class="p">(</span><span class="n">fullfile</span><span class="p">(</span><span class="n">pwd</span><span class="p">,</span> <span class="n">DIRARG</span><span class="p">)),</span>

   <span class="n">register</span> <span class="n">MODNAME</span> <span class="n">fullfile</span><span class="p">(</span><span class="n">pwd</span><span class="p">,</span> <span class="n">DIRARG</span><span class="p">)</span>

<span class="k">elseif</span> <span class="n">ISDIR</span><span class="p">(</span><span class="n">fullfile</span><span class="p">(</span><span class="n">ROOTDIR</span><span class="p">,</span> <span class="n">DIRARG</span><span class="p">)),</span>

   <span class="n">register</span> <span class="n">MODNAME</span> <span class="n">fullfile</span><span class="p">(</span><span class="n">ROOTDIR</span><span class="p">,</span> <span class="n">DIRARG</span><span class="p">)</span>

<span class="k">elseif</span> <span class="n">DIRARG</span> <span class="n">is</span> <span class="n">a</span> <span class="n">subdirectory</span> <span class="n">of</span> <span class="n">a</span> <span class="n">any</span> <span class="n">entry</span> <span class="n">in</span> <span class="n">PATH</span>

   <span class="n">register</span> <span class="n">MODNAME</span> <span class="n">fullfile</span><span class="p">(</span><span class="n">PATH</span> <span class="n">entry</span><span class="p">,</span> <span class="n">DIRARG</span><span class="p">)</span>

<span class="k">elseif</span> <span class="n">isdir</span><span class="p">(</span><span class="n">DIRARG</span><span class="p">)</span>
   <span class="c">% Assume DIRARG is an absolute pathname</span>
   <span class="n">register</span> <span class="n">MODNAME</span> <span class="n">DIRARG</span>

<span class="k">else</span>
   <span class="c">% DIRARG is not a directory, skip it</span>
<span class="k">end</span>
</pre></div>
</div>
</dd>
<dt>Mode 2)</dt><dd><dl>
<dt>&lt;Command&gt; -</dt><dd><p>One of the explicit verbs ‘addroot’, ‘clear’, ‘list’, ‘remove’
‘reregister’ or ‘reset’.  The semantics of the command verbs are
as follows:</p>
<blockquote>
<div><ul>
<li><p>addroot - Register a module root directory.  The input is
interpreted as a list of directories in which the immediate
subdirectories will be treated as individual modules and
entered into the module mapping as if manually registered
using ‘register’.</p>
<p>EXCEPTION: Immediate subdirectories named</p>
<blockquote>
<div><ul class="simple">
<li><p>data</p></li>
<li><p>deprecated</p></li>
<li><p>experimental</p></li>
</ul>
</div></blockquote>
<p>(subject to platform specific conventions) WILL NOT be put
into the module mapping when using ‘addroot’.  Modules with
these names must be manually entered using the ‘register’
verb.</p>
</li>
<li><p>clear - Deactivate all modules.  An explicit module list, if
present, is ignored.</p></li>
<li><p>list - Display list of currently registered modules in command
window.  An explicit module list, if present, is ignored.</p></li>
<li><p>remove - Deregister selected modules.  List interpreted as
module names.  No action if empty.  Unknown modules ignored.</p></li>
<li><p>reregister - Convenience verb to reestablish certain module
mappings.  Equivalent to the verb sequence:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">mrstPath</span><span class="p">(</span><span class="s">&#39;remove&#39;</span><span class="p">,</span> <span class="n">list</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">})</span>
<span class="n">mrstPath</span> <span class="n">register</span> <span class="n">list</span>
</pre></div>
</div>
</li>
<li><p>reset - Convenience verb.  Equivalent to the verb sequence:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">mrstPath</span> <span class="n">clear</span>
<span class="n">mrstPath</span> <span class="n">register</span> <span class="p">[</span><span class="n">list</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>Mode 3)</dt><dd><p>Query module register.  Input is list of modules for which to
retrieve the current module directory.</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>varargin</strong> – A variable number of arguments and interpretation. Please
see the description for possible calling syntaxes.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul>
<li><p><strong>Nothing</strong> – If called in modes 1) and 2)</p></li>
<li><p><strong>modules</strong> – In mode 3) List, represented as a cell array of strings
(character vectors), of the currently active add-on
modules.  If called without output arguments, function
‘mrstPath’ will display the known mapping of the requested
modules (all modules if module list is empty) in the
Command Window.</p>
<p>If called with a single output argument and no input
arguments, then the output will be a cell array of strings
(character vectors) containing the currently registered
modules.</p>
<p>NOTE: The return value will, as a special case, be a
character vector rather than a cell array of character
vectors if function <a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a> is called with a single
input module name and a single output parameter, e.g., as:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">pth</span> <span class="p">=</span> <span class="n">mrstPath</span><span class="p">(</span><span class="s">&#39;search&#39;</span><span class="p">,</span> <span class="s">&#39;deckformat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Callers needing the “cell array of strings” semantics must
be prepared to use <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ischar</span></code> on the return value and behave
accordingly.</p>
</li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.ROOTDIR" title="core.utils.ROOTDIR"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ROOTDIR</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">isdir</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">filesep</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">fullfile</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstPlatform">
<span class="sig-name descname"><span class="pre">mrstPlatform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstPlatform" title="Permalink to this definition"></a></dt>
<dd><p>Get information about platform-dependent settings for current session</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="p">=</span> <span class="n">mrstPlatform</span><span class="p">();</span>
<span class="n">isOctave</span> <span class="p">=</span> <span class="n">mrstPlatform</span><span class="p">(</span><span class="s">&#39;octave&#39;</span><span class="p">);</span>
<span class="n">isDesktop</span> <span class="p">=</span> <span class="n">mrstPlatform</span><span class="p">(</span><span class="s">&#39;desktop&#39;</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> – May be omitted to get full platform struct. Otherwise, the name
of a specific setting to query.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Either all features as a struct, or a specific setting, dependent
if a input argument is given. The possible features are:</p>
<blockquote>
<div><p>‘platform’  - Name of the platform (MATLAB or Octave)
‘version’   - Version string from ver() output.
‘major’     - Numerical value of major version
‘minor’     - Numerical value of minor version
‘octave’    - Boolean indicating if platform is Octave
‘matlab’    - Boolean indicating if platform is MATLAB
‘os’        - ‘linux/unix’, ‘windows’ or ‘macos’
‘desktop’   - If MATLAB/Octave is running in Desktop mode
‘gui’,      - If GUIs are supported (= QT backend for Oct)
‘jvm’,      - Availability of Java
‘richtext’  - Command line supports rich text.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstSettings">
<span class="sig-name descname"><span class="pre">mrstSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">verb</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstSettings" title="Permalink to this definition"></a></dt>
<dd><p>Configure persistent settings for MRST for advanced functionality</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">useMEX</span> <span class="p">=</span> <span class="n">mrstSettings</span><span class="p">(</span><span class="s">&#39;get&#39;</span><span class="p">,</span> <span class="s">&#39;useMEX&#39;</span><span class="p">)</span>
<span class="n">mrstSettings</span><span class="p">(</span><span class="s">&#39;set&#39;</span><span class="p">,</span> <span class="s">&#39;useMEX&#39;</span><span class="p">,</span> <span class="n">useMEX</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verb</strong> – <p>Must be one of:
‘get’   - Get the value of a setting. Second input should be a</p>
<blockquote>
<div><p>string, with the name of a valid setting.</p>
</div></blockquote>
<dl class="simple">
<dt>’set’   - Set the value of a setting. The second input is the</dt><dd><p>new value.</p>
</dd>
</dl>
<p>’setup’ - Perform a full setup of all possible settings.</p>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – If verb is ‘get’, the value of the settings. If called with no
input arguments, the output will be a struct of all current
settings. Other input arguments will result in an error.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Equal to list</span>
<span class="n">mrstSettings</span><span class="p">()</span>
<span class="c">% List current settings</span>
<span class="n">mrstSettings</span><span class="p">(</span><span class="s">&#39;list&#39;</span><span class="p">)</span>
<span class="c">% Reset and do set up</span>
<span class="n">mrstSettings</span><span class="p">(</span><span class="s">&#39;setup&#39;</span><span class="p">,</span> <span class="s">&#39;reset-no-check&#39;</span><span class="p">)</span>
<span class="c">% Reset settings (after prompt) and do setup</span>
<span class="n">mrstSettings</span><span class="p">(</span><span class="s">&#39;setup&#39;</span><span class="p">,</span> <span class="s">&#39;reset&#39;</span><span class="p">)</span>
<span class="c">% Perform setup wizard</span>
<span class="n">mrstSettings</span><span class="p">(</span><span class="s">&#39;setup&#39;</span><span class="p">)</span>
<span class="c">% Set option</span>
<span class="n">mrstSettings</span><span class="p">(</span><span class="s">&#39;set&#39;</span><span class="p">,</span> <span class="s">&#39;useMEX&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
<span class="c">% Query a setting</span>
<span class="n">useMEX</span> <span class="p">=</span> <span class="n">mrstSettings</span><span class="p">(</span><span class="s">&#39;get&#39;</span><span class="p">,</span> <span class="s">&#39;useMEX&#39;</span><span class="p">);</span>
<span class="c">% Query setting and output extra info</span>
<span class="p">[</span><span class="n">useMEX</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="p">=</span> <span class="n">mrstSettings</span><span class="p">(</span><span class="s">&#39;get&#39;</span><span class="p">,</span> <span class="s">&#39;useMEX&#39;</span><span class="p">);</span>
<span class="nb">disp</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstStartupMessage">
<span class="sig-name descname"><span class="pre">mrstStartupMessage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstStartupMessage" title="Permalink to this definition"></a></dt>
<dd><p>Print a welcome message with helpful commands for new MRST users</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mrstStartupMessage</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Display the welcome message in the command window, indicating that MRST
is activated and ready for use. Some helpful links functions are also
provided to help new users getting started.</p>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mrstStartupMessage</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#core.utils.mrstStartupMessage" title="core.utils.mrstStartupMessage"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstStartupMessage</span></code></a> is normally automatically run during the startup
process. Seeing the output from <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstStartupMesssage</span></code> indicates that
MRST was successfully loaded and is ready for use.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">startup</span></code>, <a class="reference internal" href="#core.utils.mrstExamples" title="core.utils.mrstExamples"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstExamples</span></code></a>, <a class="reference internal" href="#core.utils.mrstModule" title="core.utils.mrstModule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstModule</span></code></a>, <a class="reference internal" href="#core.utils.mrstPath" title="core.utils.mrstPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstPath</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstVerbose">
<span class="sig-name descname"><span class="pre">mrstVerbose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstVerbose" title="Permalink to this definition"></a></dt>
<dd><p>Globally control default settings for MRST verbose information.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Either</span> <span class="n">of</span> <span class="n">the</span> <span class="n">modes</span>
  <span class="mi">1</span><span class="p">)</span>     <span class="n">mrstVerbose</span> <span class="nb">arg</span>
  <span class="mi">2</span><span class="p">)</span> <span class="n">v</span> <span class="p">=</span> <span class="n">mrstVerbose</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function provides a centralised facility for individual MRST
functions to query verbosity default settings.  Specifically, if a
function provides verbose output (i.e., additional reporting during
computational process) in the form of a ‘verbose’ option, then the
function is encouraged to initialise the verbose flag with the output
of this function. Verbose output may then be subsequently overridden on
an individual, per-function basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> – <p>(Mode 1 only) Control mode for verbose output.  Must be one of
the following possibilities:</p>
<blockquote>
<div><ul class="simple">
<li><p>String, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">{'off',</span> <span class="pre">'on'}</span></code>, for globally disabling or enabling
MRST verbose output.  Actual effects depends on specific
setting in individual functions and may usually be controlled
more targetly.  The default state is ‘off’.</p></li>
<li><p>String, ‘reset’, for restoring verbose output setting to the
default state: mrstVerbose off</p></li>
<li><p>Logical, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">{false,</span> <span class="pre">true}</span></code>, for disabling or enabling MRST
verbose output.</p></li>
<li><p>Numeric (Real) scalar value.  Specifically set verbosity
level.  A verbosity level exceeding zero enables verbose
output. Whether or not higher values produce more output is
at the discretion of individual MRST functions.</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v</strong> – (Mode 2 only) A numeric scalar value. <code class="xref mat mat-func docutils literal notranslate"><span class="pre">V==0</span></code> turns default state
of verbose output off, while <code class="xref mat mat-func docutils literal notranslate"><span class="pre">v&gt;0</span></code> signifies different levels of
verbose output.  Individual callers of ‘mrstVerbose’ (typically
other MRST functions) must support a Boolean on/off state, but
may, optionally, support a notion of verbosity levels where
higher levels signify more extensive output.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Demonstrate &#39;String&#39; form (Command and Function syntax).</span>
<span class="n">mrstVerbose</span>  <span class="n">on</span>    <span class="c">% Enable verbose output.</span>
<span class="n">mrstVerbose</span><span class="p">(</span><span class="s">&#39;off&#39;</span><span class="p">)</span> <span class="c">% Disable verbose ouput (default state).</span>
<span class="n">mrstVerbose</span> <span class="nb">reset</span>  <span class="c">% Restore verbosity defaults (off).</span>

<span class="c">% 2) Demonstrate &#39;Logical&#39; form of mrstVerbose function.</span>
<span class="c">%    (only Function syntax supported in this case).</span>
<span class="n">mrstVerbose</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>  <span class="c">% Enable verbose output.</span>
<span class="n">mrstVerbose</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="c">% Disable verbose output (default state).</span>

<span class="c">% 3) Demonstrate &#39;Numeric&#39; form of mrstVerbose function.</span>
<span class="c">%    (only Function syntax supported in this case).</span>
<span class="n">mrstVerbose</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c">% Enable verbose output.</span>
<span class="n">mrstVerbose</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c">% Disable verbose output.</span>
<span class="n">mrstVerbose</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="c">% Set verbose output level to 2.</span>

<span class="c">% 4) Retrieve current verbosity setting.</span>
<span class="c">%    (Only function syntax supported in this case).</span>
<span class="n">v</span> <span class="p">=</span> <span class="n">mrstVerbose</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.mrstWebSave">
<span class="sig-name descname"><span class="pre">mrstWebSave</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.mrstWebSave" title="Permalink to this definition"></a></dt>
<dd><p>Get Call-Back for Downloading Online Resources Specified by URLs</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">downloadFcn</span> <span class="p">=</span> <span class="n">mrstWebSave</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>downloadFcn</strong> – Call-Back function (function handle) for downloading
online resources specified through a URL.  In recent
versions of MATLAB this is just function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">websave</span></code>. We
wrap function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">urlwrite</span></code> as a backwards compatbility
measure in earlier versions of MATLAB.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is mainly intended to support an encompassing download
manager such as function <a class="reference internal" href="#core.utils.githubDownload" title="core.utils.githubDownload"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">githubDownload</span></code></a>.</p>
<p>The call-back function supports the following syntax</p>
<blockquote>
<div><p>file = downloadFcn(file, url)
file = downloadFcn(file, url, ‘p1’, v1, …)</p>
</div></blockquote>
<p>in which the parameters are interpreted as follows</p>
<blockquote>
<div><p>file - Name of local file into which contents of remote resource
will be saved.</p>
<p>url  - Uniform resource locator of remote resource (file contents).</p>
<p>‘pn’/pv - List of key/value pairs that will be passed through to the
underlying GET request of the URL.  Numeric arguments converted to
strings using function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">num2str</span></code>.</p>
</div></blockquote>
<p>and the return value is</p>
<blockquote>
<div><p>file - Unmodified input file name if successful, empty in case of
download failure.</p>
</div></blockquote>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.githubDownload" title="core.utils.githubDownload"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">githubDownload</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.msgid">
<span class="sig-name descname"><span class="pre">msgid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.msgid" title="Permalink to this definition"></a></dt>
<dd><p>Construct Error/Warning message ID by prepending function name.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="p">=</span> <span class="n">msgid</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>s</strong> – A string of the form <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[</span></code> suitable as an
ERROR or WARNING-type message identifier.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong> – The same string, though with the name of the function calling
<a class="reference internal" href="#core.utils.msgid" title="core.utils.msgid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msgid</span></code></a> prepended to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">s</span></code> (or the string ‘BASE’ if function <a class="reference internal" href="#core.utils.msgid" title="core.utils.msgid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msgid</span></code></a>
is called from the base workspace).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">error</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">warning</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.multiEig">
<span class="sig-name descname"><span class="pre">multiEig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.multiEig" title="Permalink to this definition"></a></dt>
<dd><p>Solve sequence of general (unsymmetric) eigenvalue problems using LAPACK</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">d</span>        <span class="p">=</span> <span class="n">multiEig</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span>

<span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>    <span class="p">=</span> <span class="n">multiEig</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span> <span class="p">=</span> <span class="n">multiEig</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> – Array (type <code class="xref mat mat-func docutils literal notranslate"><span class="pre">double</span></code>) containing the elements/entries of a sequence
of coefficient matrices–ordered consequtively.  Each matrix is
expected to be square and fairly small.</p></li>
<li><p><strong>sz</strong> – Sequence of matrix block sizes.  The number of matrix blocks
contained in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">A</span></code> is implicitly assumed to be <code class="xref mat mat-func docutils literal notranslate"><span class="pre">numel(rsz)</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>d</strong> – Array (type <code class="xref mat mat-func docutils literal notranslate"><span class="pre">double</span></code>, possibly complex) containing the eigenvalues of
the individual eigenvalue problems.</p></li>
<li><p><strong>v</strong> – Array (type <code class="xref mat mat-func docutils literal notranslate"><span class="pre">double</span></code>) of right eigenvectors.  Optional.  Only returned
if requested.</p></li>
<li><p><strong>w</strong> – Array (type <code class="xref mat mat-func docutils literal notranslate"><span class="pre">double</span></code>) of left eigenvectors.  Optional.  Only returned
if requested.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The output in the single return value case is algorithmically equivalent
to the loop</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">pA</span> <span class="p">=</span> <span class="n">cumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">sz</span> <span class="o">.^</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">pd</span> <span class="p">=</span> <span class="n">cumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">sz</span><span class="p">]);</span>
<span class="n">d</span>  <span class="p">=</span> <span class="nb">zeros</span><span class="p">([</span><span class="n">pd</span><span class="p">(</span><span class="k">end</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>

<span class="k">for</span> <span class="nb">i</span> <span class="p">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="nb">numel</span><span class="p">(</span><span class="n">sz</span><span class="p">),</span>
   <span class="n">iA</span> <span class="p">=</span> <span class="n">pA</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">pA</span><span class="p">(</span><span class="nb">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">id</span> <span class="p">=</span> <span class="n">pd</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">pd</span><span class="p">(</span><span class="nb">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

   <span class="n">d</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">=</span> <span class="n">eig</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">iA</span><span class="p">),</span> <span class="p">[</span><span class="n">sz</span><span class="p">(</span><span class="nb">i</span><span class="p">),</span> <span class="n">sz</span><span class="p">(</span><span class="nb">i</span><span class="p">)]),</span> <span class="s">&#39;vector&#39;</span><span class="p">);</span>
<span class="k">end</span>
</pre></div>
</div>
<p>except for round-off errors.  Rank deficient matrices are supported.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.multiSymmEig">
<span class="sig-name descname"><span class="pre">multiSymmEig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.multiSymmEig" title="Permalink to this definition"></a></dt>
<dd><p>Solve sequence of symmetric eigenvalue problems using LAPACK</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">d</span>     <span class="p">=</span> <span class="n">multiSymmEig</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span>

<span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="p">=</span> <span class="n">multiSymmEig</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> – Array (type <code class="xref mat mat-func docutils literal notranslate"><span class="pre">double</span></code>) containing the elements/entries of a sequence
of coefficient matrices–ordered consequtively.  Each matrix is
expected to be square, symmetric and fairly small.</p></li>
<li><p><strong>sz</strong> – Sequence of matrix block sizes.  The number of matrix blocks
contained in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">A</span></code> is implicitly assumed to be <code class="xref mat mat-func docutils literal notranslate"><span class="pre">numel(rsz)</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>d</strong> – Array (type <code class="xref mat mat-func docutils literal notranslate"><span class="pre">double</span></code>) containing the eigenvalues of the individual
eigenvalue problems.</p></li>
<li><p><strong>v</strong> – Array (type <code class="xref mat mat-func docutils literal notranslate"><span class="pre">double</span></code>) of eigenvectors.  Optional.  Only returned if
specifically requested.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The output in the single return value case is algorithmically equivalent
to the loop</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">pA</span> <span class="p">=</span> <span class="n">cumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">sz</span> <span class="o">.^</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">pd</span> <span class="p">=</span> <span class="n">cumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">sz</span><span class="p">]);</span>
<span class="n">d</span>  <span class="p">=</span> <span class="nb">zeros</span><span class="p">([</span><span class="n">pd</span><span class="p">(</span><span class="k">end</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>

<span class="k">for</span> <span class="nb">i</span> <span class="p">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="nb">numel</span><span class="p">(</span><span class="n">sz</span><span class="p">),</span>
   <span class="n">iA</span> <span class="p">=</span> <span class="n">pA</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">pA</span><span class="p">(</span><span class="nb">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">id</span> <span class="p">=</span> <span class="n">pd</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="p">:</span> <span class="n">pd</span><span class="p">(</span><span class="nb">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

   <span class="n">d</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">=</span> <span class="n">eig</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">iA</span><span class="p">),</span> <span class="p">[</span><span class="n">sz</span><span class="p">(</span><span class="nb">i</span><span class="p">),</span> <span class="n">sz</span><span class="p">(</span><span class="nb">i</span><span class="p">)]),</span> <span class="s">&#39;vector&#39;</span><span class="p">);</span>
<span class="k">end</span>
</pre></div>
</div>
<p>except for round-off errors.  Rank deficient matrices are supported.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.propertynames">
<span class="sig-name descname"><span class="pre">propertynames</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.propertynames" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.reduceToDouble">
<span class="sig-name descname"><span class="pre">reduceToDouble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.reduceToDouble" title="Permalink to this definition"></a></dt>
<dd><p>Reduce ADI variable to double.</p>
<p>This standalone version only exists to provide the interface for doubles.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.require">
<span class="sig-name descname"><span class="pre">require</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.require" title="Permalink to this definition"></a></dt>
<dd><p>Announce and enforce module dependency.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">require</span> <span class="n">modulename</span>
<span class="n">require</span><span class="p">(</span><span class="s">&#39;modulename&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>modulename</strong> – string.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will throw an error if the module does not exist, or
exists, but is not loaded.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.mrstModule" title="core.utils.mrstModule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstModule</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.rldecode">
<span class="sig-name descname"><span class="pre">rldecode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">n</span></em>, <em class="sig-param"><span class="pre">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.rldecode" title="Permalink to this definition"></a></dt>
<dd><p>Decompress run length encoding of array <code class="xref mat mat-func docutils literal notranslate"><span class="pre">A</span></code> along dimension <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dim</span></code>.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="p">=</span> <span class="n">rldecode</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
<span class="n">B</span> <span class="p">=</span> <span class="n">rldecode</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="c">% dim assumed to be 1</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> – encoded array</p></li>
<li><p><strong>n</strong> – repetition of each layer along dimension <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dim</span></code>. <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code> can be
either a scalar or one repetition number for each layer.</p></li>
<li><p><strong>dim</strong> – dimension of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">A</span></code> where run length encoding is done.
dim &gt; 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>B</strong> – uncompressed <code class="xref mat mat-func docutils literal notranslate"><span class="pre">A</span></code></p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Numerical example:</span>
<span class="n">A</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">;</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">;</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="p">=</span> <span class="n">rlencode</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">C</span> <span class="p">=</span> <span class="n">rldecode</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c">% 2) Retrive &#39;first&#39; column of G.cells.faces (see grid_structure):</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">cellNo</span>  <span class="p">=</span> <span class="n">rldecode</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">,</span> <span class="nb">double</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">numFaces</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="p">.</span><span class="o">&#39;</span><span class="p">;</span>
<span class="nb">disp</span><span class="p">([</span><span class="s">&#39;CellFace nr. 10 belongs to cell nr: &#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">cellNo</span><span class="p">(</span><span class="mi">10</span><span class="p">))]);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.rlencode" title="core.utils.rlencode"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">rlencode</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.rlencode">
<span class="sig-name descname"><span class="pre">rlencode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.rlencode" title="Permalink to this definition"></a></dt>
<dd><p>Compute run length encoding of array A along dimension dim.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="p">=</span> <span class="n">rlencode</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="p">=</span> <span class="n">rlencode</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> – Array.  Numeric or cell array of string (“cellstring”).</p></li>
<li><p><strong>dim</strong> – dimension of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">A</span></code> where run length encoding is done.
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">dim</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dim</span> <span class="pre">&lt;=</span> <span class="pre">ndims(A)</span></code>.
OPTIONAL.  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dim=1</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>A</strong> – Compressed <code class="xref mat mat-func docutils literal notranslate"><span class="pre">A</span></code> where repeated layers are removed.</p></li>
<li><p><strong>n</strong> – repetition count of repeated layers in original <code class="xref mat mat-func docutils literal notranslate"><span class="pre">A</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Regular numeric matrix</span>
<span class="n">A</span>      <span class="p">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">;</span> <span class="p">...</span>
           <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">;</span> <span class="p">...</span>
           <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">;</span> <span class="p">...</span>
           <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span> <span class="p">;</span> <span class="p">...</span>
           <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">;</span> <span class="p">...</span>
           <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">];</span>

<span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="p">=</span> <span class="n">rlencode</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nb">assert</span> <span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">;</span> <span class="p">...</span>
                     <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">;</span> <span class="p">...</span>
                     <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span> <span class="p">;</span> <span class="p">...</span>
                     <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">]))</span>

<span class="nb">assert</span> <span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="p">.</span><span class="o">&#39;</span><span class="p">))</span>

<span class="c">% 2) Cell array of string</span>
<span class="n">S</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&#39;aaaa&#39;</span> <span class="p">;</span> <span class="s">&#39;aaaa&#39;</span> <span class="p">;</span> <span class="s">&#39;bb&#39;</span> <span class="p">;</span> <span class="s">&#39;cccc&#39;</span> <span class="p">;</span> <span class="s">&#39;cccc&#39;</span> <span class="p">;</span> <span class="s">&#39;d&#39;</span><span class="p">;</span> <span class="s">&#39;d&#39;</span><span class="p">;</span> <span class="s">&#39;d&#39;</span> <span class="p">;</span> <span class="s">&#39;d&#39;</span> <span class="p">};</span>
<span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="p">=</span> <span class="n">rlencode</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>

<span class="nb">assert</span> <span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">{</span> <span class="s">&#39;aaaa&#39;</span> <span class="p">;</span> <span class="s">&#39;bb&#39;</span><span class="p">;</span> <span class="s">&#39;cccc&#39;</span><span class="p">;</span> <span class="s">&#39;d&#39;</span> <span class="p">}))</span>
<span class="nb">assert</span> <span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">4</span> <span class="p">]))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.rldecode" title="core.utils.rldecode"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">rldecode</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.subsetMinus">
<span class="sig-name descname"><span class="pre">subsetMinus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">subs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.subsetMinus" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.subsetPlus">
<span class="sig-name descname"><span class="pre">subsetPlus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">v</span></em>, <em class="sig-param"><span class="pre">subs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.subsetPlus" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.ternaryAxis">
<span class="sig-name descname"><span class="pre">ternaryAxis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ternaryAxis" title="Permalink to this definition"></a></dt>
<dd><p>Create a ternary axis and mappings to ternary space</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">mapx</span><span class="p">,</span> <span class="n">mapy</span><span class="p">]</span> <span class="p">=</span> <span class="n">ternaryAxis</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>‘tick’</strong> – Tick points to be displayed on the axis (vector from 0 to 1)</p></li>
<li><p><strong>‘names’</strong> – Names of the x, y, z coordinates (to be plotted on axis)</p></li>
<li><p><strong>‘isox’,’ixoy’,’isoz’</strong> – Booleans indicating if isolines are to be drawn
for x, y and z axes. Isolines are drawn at the
same positions as the ticks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>mapx</strong> – Mapping on the form f(x, y, z) -&gt; X where X is the new
coordinates inside the ternary diagram.</p></li>
<li><p><strong>mapy</strong> – Mapping on the form g(x, y, z) -&gt; Y where Y is the new
coordinates inside the ternary diagram.</p></li>
</ul>
</dd>
</dl>
<p>EXAMPLE:
figure;
[mapx, mapy] = ternaryAxis();
x = 0.7*(0:0.1:1);
y = 0.3*(0:0.1:1).^2;
z = 1 - x - y;
plot(mapx(x, y, z), mapy(x, y, z), ‘k’, ‘linewidth’, 2)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.tetrahedralAxis" title="core.utils.tetrahedralAxis"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tetrahedralAxis</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.tetrahedralAxis">
<span class="sig-name descname"><span class="pre">tetrahedralAxis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.tetrahedralAxis" title="Permalink to this definition"></a></dt>
<dd><p>Create a ternary axis and mappings to ternary space</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">mapx</span><span class="p">,</span> <span class="n">mapy</span><span class="p">]</span> <span class="p">=</span> <span class="n">ternaryAxis</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>‘tick’</strong> – Tick points to be displayed on the axis (vector from 0 to 1)</p></li>
<li><p><strong>‘names’</strong> – Names of the x, y, z coordinates (to be plotted on axis)</p></li>
<li><p><strong>‘isox’,’ixoy’,’isoz’</strong> – Booleans indicating if isolines are to be drawn
for x, y and z axes. Isolines are drawn at the
same positions as the ticks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>mapx</strong> – Mapping on the form f(x, y, z) -&gt; X where X is the new
coordinates inside the ternary diagram.</p></li>
<li><p><strong>mapy</strong> – Mapping on the form g(x, y, z) -&gt; Y where Y is the new
coordinates inside the ternary diagram.</p></li>
</ul>
</dd>
</dl>
<p>EXAMPLE:
figure;
[mapx, mapy] = ternaryAxis();
x = 0.7*(0:0.1:1);
y = 0.3*(0:0.1:1).^2;
z = 1 - x - y;
plot(mapx(x, y, z), mapy(x, y, z), ‘k’, ‘linewidth’, 2)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.ternaryAxis" title="core.utils.ternaryAxis"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ternaryAxis</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.ticif">
<span class="sig-name descname"><span class="pre">ticif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">bool</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.ticif" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate function TIC if input is true.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">ticif</span><span class="p">(</span><span class="n">bool</span><span class="p">)</span>

<span class="n">tstart</span> <span class="p">=</span> <span class="n">ticif</span><span class="p">(</span><span class="n">bool</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bool</strong> – Boolean variable (true/false).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tstart</strong> – Save start time to output argument.  The numeric value of
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">tstart</span></code> is only useful as an input argument for a subsequent
call to functions <code class="xref mat mat-func docutils literal notranslate"><span class="pre">toc</span></code> or <a class="reference internal" href="#core.utils.tocif" title="core.utils.tocif"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tocif</span></code></a>.</p>
<p>If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">bool</span></code> is <code class="xref mat mat-func docutils literal notranslate"><span class="pre">false</span></code>, then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">tstart</span></code> is the emtpy array (<code class="xref mat mat-func docutils literal notranslate"><span class="pre">[]</span></code>).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Function used for making code cleaner where verbose option is used.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tic</span></code>, <a class="reference internal" href="#core.utils.tocif" title="core.utils.tocif"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tocif</span></code></a>, <a class="reference internal" href="#core.utils.dispif" title="core.utils.dispif"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dispif</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.tocif">
<span class="sig-name descname"><span class="pre">tocif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">bool</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.tocif" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate function TOC if input is true.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">tocif</span><span class="p">(</span><span class="n">bool</span><span class="p">)</span>
<span class="n">tocif</span><span class="p">(</span><span class="n">bool</span><span class="p">,</span> <span class="n">tstart</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bool</strong> – Boolean variable (true/false).</p></li>
<li><p><strong>tstart</strong> – Saved start time as defined by functions <code class="xref mat mat-func docutils literal notranslate"><span class="pre">tic</span></code> or <a class="reference internal" href="#core.utils.ticif" title="core.utils.ticif"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ticif</span></code></a>.  In
this case, function <a class="reference internal" href="#core.utils.tocif" title="core.utils.tocif"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tocif</span></code></a> measures the elapsed time since
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">tstart</span></code>.  Otherwise, the global <code class="xref mat mat-func docutils literal notranslate"><span class="pre">tic</span></code>/<code class="xref mat mat-func docutils literal notranslate"><span class="pre">toc</span></code> timer object is
used.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Function used for making code cleaner where verbose option is used.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">toc</span></code>, <a class="reference internal" href="#core.utils.ticif" title="core.utils.ticif"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ticif</span></code></a>, <a class="reference internal" href="#core.utils.dispif" title="core.utils.dispif"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dispif</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.uniqueStable">
<span class="sig-name descname"><span class="pre">uniqueStable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.uniqueStable" title="Permalink to this definition"></a></dt>
<dd><p>Support <code class="xref mat mat-func docutils literal notranslate"><span class="pre">unique(A,</span> <span class="pre">'stable')</span></code> in all versions of MATLAB</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ic</span><span class="p">]</span> <span class="p">=</span> <span class="n">uniqueStable</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ic</span><span class="p">]</span> <span class="p">=</span> <span class="n">uniqueStable</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;rows&#39;</span><span class="p">)</span>
<span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ic</span><span class="p">]</span> <span class="p">=</span> <span class="n">uniqueStable</span><span class="p">(...,</span> <span class="s">&#39;use_fallback&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This is a pure MATLAB compatibility implementation of</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">unique</span><span class="p">(</span><span class="n">A</span><span class="p">,</span>         <span class="s">&#39;stable&#39;</span><span class="p">)</span>
<span class="n">unique</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s">&#39;rows&#39;</span><span class="p">,</span> <span class="s">&#39;stable&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>for MATLABs prior to release R2012a (MATLAB 7.14).  In versions 7.14
and later, this simply forwards the parameters to the built-in version
of function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">unique</span></code>.</p>
<p>Function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">unique</span></code>’s ‘stable’ option returns the unique values in the
input in the same order as they appear in the input.  Without ‘stable’,
the unique elements are returned in sorted order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Numeric array.  The fall-back implementation does not support
cellstrings.</p></li>
<li><p><strong>'rows'</strong> – Exact string ‘rows’ indicating that we should compute unique
rows of ‘a’ rather than merely unique single elements.</p></li>
<li><p><strong>'use_fallback'</strong> – Exact string ‘use_fallback’.  This is mainly intended for
testing and development purposes.  The option bypasses the
MATLAB version check logic and forces the use of the fall-back
implementation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>c</strong> – Unique elements (or rows) from input array ‘a’, in order of
appearance in the input array.</p></li>
<li><p><strong>ia</strong> – Index into input ‘a’ such that ALL(ALL(c == a(ia, :)))</p></li>
<li><p><strong>ic</strong> – Index into output ‘c’ such that ALL(ALL(c(ic, :) == a)).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function uses <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sortrows</span></code>.</p>
</div>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% 1) Unique elements in order of appearance</span>
<span class="n">a</span> <span class="p">=</span> <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span> <span class="p">;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">;</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span> <span class="p">];</span>

<span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ic</span><span class="p">]</span> <span class="p">=</span> <span class="n">uniqueStable</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="nb">assert</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="p">[</span> <span class="mi">3</span> <span class="p">;</span> <span class="mi">1</span> <span class="p">;</span> <span class="mi">2</span> <span class="p">;</span> <span class="mi">4</span> <span class="p">]),</span> <span class="p">...</span>
        <span class="s">&#39;Stable sort regression in &#39;&#39;uniqueStable&#39;&#39;.&#39;</span><span class="p">)</span>
<span class="nb">assert</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">a</span><span class="p">(</span><span class="n">ia</span><span class="p">)),</span> <span class="s">&#39;&#39;&#39;IA&#39;&#39; Regression in &#39;&#39;uniqueStable&#39;&#39;.&#39;</span><span class="p">)</span>
<span class="nb">assert</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">ic</span><span class="p">),</span> <span class="nb">size</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">==</span> <span class="n">a</span><span class="p">)),</span> <span class="p">...</span>
        <span class="s">&#39;&#39;&#39;IC&#39;&#39; Regression in &#39;&#39;uniqueStable&#39;&#39;.&#39;</span><span class="p">)</span>

<span class="c">% 2) Unique matrix rows in order of appearance</span>
<span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ic</span><span class="p">]</span> <span class="p">=</span> <span class="n">uniqueStable</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;rows&#39;</span><span class="p">);</span>
<span class="nb">assert</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">c</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span> <span class="mi">3</span> <span class="p">;</span> <span class="mi">1</span> <span class="p">;</span> <span class="mi">2</span> <span class="p">;</span> <span class="mi">1</span> <span class="p">]),</span> <span class="p">...</span>
        <span class="s">&#39;Stable sort regression in &#39;&#39;uniqueStable/rows&#39;&#39;.&#39;</span><span class="p">)</span>
<span class="nb">assert</span> <span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="p">...</span>
        <span class="s">&#39;Stable sort regression ((2,2)==4) in &#39;&#39;uniqueStable/rows&#39;&#39;.&#39;</span><span class="p">)</span>
<span class="nb">assert</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">a</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="p">:))),</span> <span class="p">...</span>
        <span class="s">&#39;&#39;&#39;IA&#39;&#39; Regression in &#39;&#39;uniqueStable/rows&#39;&#39;.&#39;</span><span class="p">)</span>
<span class="nb">assert</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="p">:)</span> <span class="o">==</span> <span class="n">a</span><span class="p">)),</span> <span class="p">...</span>
        <span class="s">&#39;&#39;&#39;IC&#39;&#39; Regression in &#39;&#39;uniqueStable/rows&#39;&#39;.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">unique</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sortrows</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.value">
<span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.value" title="Permalink to this definition"></a></dt>
<dd><p>Remove AD state and compact 1 by n cell arrays to matrices</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="p">=</span> <span class="n">value</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Removes AD variables, and if the input is a cell array with a single
row and multiple columns, will combine them into a single matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> – Value to be converted.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v</strong> – Value with no AD status.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>double2ADI, double2GenericAD, ADI, GenericAD</p>
</div>
</dd></dl>

<span class="target" id="module-core.utils.gridtools"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.gridtools.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.gridtools.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>GRIDTOOLS</dt><dd><p>Functions that collect common operations on the MRST grid structure</p>
</dd>
<dt>Files</dt><dd><p>addBoundingBoxFields            - Add minimal bounding box for each cell/face
checkGrid                       - Apply Basic Consistency Checks to MRST Grid Geometry
compareGrids                    - Determine if two grid structures are the same.
computeVerticalGridIntersection - Compute polygons generated by an intersection of a piecewise linear
connectedCells                  - Compute connected components of grid cell subsets.
convertHorizonsToGrid           - Build corner-point grid based on a series of horizons
createAugmentedGrid             - Extend grid with mappings needed for the virtual element solver
createGridMappings              - Add preliminary mappings to be used in <a class="reference internal" href="#core.utils.gridtools.createAugmentedGrid" title="core.utils.gridtools.createAugmentedGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">createAugmentedGrid</span></code></a>
findEnclosingCell               - Find cell(s) containing points. The cells must be convex.
getCellNoFaces                  - Get a list over all half faces, accounting for possible NNC
getConnectivityMatrix           - Derive global, undirected connectivity matrix from neighbourship relation.
getFacesCloseToSegment          - Get index to faces that lie “in the vicinity” of the line segment seg.
getNeighbourship                - Retrieve neighbourship relation (“graph”) from grid
gridAddHelpers                  - Add helpers to existing grid structure for cleaner code structure.
gridCellFaces                   - Find faces corresponding to a set of cells
gridCellNo                      - Construct map from half-faces to cells or cell subset
gridCellNodes                   - Extract nodes per cell in a particular set of cells
gridFaceNodes                   - Find nodes corresponding to a set of faces
gridLogicalIndices              - Given grid G and optional subset of cells, find logical indices.
indirectionSub                  - Look-up in index map of the type G.cells.facePos, G.faces.nodePos, etc
makePlanarGrid                  - Construct 2D surface grid from faces of 3D grid.
neighboursByNodes               - Derive neighbourship from common node (vertex) relationship
refineGrdeclLayers              - Refine a GRDECL structure in the vertical direction
removeNodes                     - {
sampleFromBox                   - Sample from data on a uniform Cartesian grid that covers the bounding box
sortEdges                       - Sort edges in G.faces.edges counter-clockwise to face orientation
sortGrid                        - Permute nodes, faces and cells to sorted form
sortHorizons                    - Undocumented Utility Function
transform3Dto2Dgrid             - Transforms a 3D grid into a 2D grid.
translateGrid                   - Move all grid coordinates according to particular translation
volumeByGaussGreens             - Compute cell volume by means of Gauss-Greens’ formula</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.addBoundingBoxFields">
<span class="sig-name descname"><span class="pre">addBoundingBoxFields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.addBoundingBoxFields" title="Permalink to this definition"></a></dt>
<dd><p>Add minimal bounding box for each cell/face
Useful for quickly picking subset of candidate cells/faces before more
costly geometry is invoked</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>computeVerticalGridIntersection, computeTraversedCells,
addBoundingBoxFields</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.boundaryFaceIndices">
<span class="sig-name descname"><span class="pre">boundaryFaceIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">direction</span></em>, <em class="sig-param"><span class="pre">i1</span></em>, <em class="sig-param"><span class="pre">i2</span></em>, <em class="sig-param"><span class="pre">i3</span></em>, <em class="sig-param"><span class="pre">caller</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.boundaryFaceIndices" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve face indices belonging to subset of global outer faces.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">ix</span> <span class="p">=</span> <span class="n">boundaryFaceIndices</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i3</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>side</strong> – <p>Global side from which to extract face indices.  String.  Must
(case insensitively) match one of six alias groups:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>{‘West’ , ‘XMin’, ‘Left’  }</p></li>
<li><p>{‘East’ , ‘XMax’, ‘Right’ }</p></li>
<li><p>{‘South’, ‘YMin’, ‘Back’  }</p></li>
<li><p>{‘North’, ‘YMax’, ‘Front’ }</p></li>
<li><p>{‘Upper’, ‘ZMin’, ‘Top’   }</p></li>
<li><p>{‘Lower’, ‘ZMax’, ‘Bottom’}</p></li>
</ol>
</div></blockquote>
<p>These groups correspond to the cardinal directions mentioned as
the first alternative in each group.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i1,i2</strong> – Index ranges for local (in-plane) axes one and two,
respectively.  An empty index range ([]) is interpreted as
covering the entire corresponding local axis of ‘side’ in the
grid ‘G’.  The local axes on a ‘side’ in ‘G’ are ordered
according to ‘X’ before ‘Y’, and ‘Y’ before ‘Z’.</p></li>
<li><p><strong>i3</strong> – Index range for global axis perpendicular to ‘side’.  The
primary purpose of this parameter is to exclude faces <em>within</em>
a reservoir from being added to the return value ‘ix’.  Such
faces typically occur in faulted reservoirs where a given face
may be considered external by virtue of being connected to a
single reservoir cell only.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>ix</strong> – Required face indices.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.params.wells_and_bc.fluxside" title="core.params.wells_and_bc.fluxside"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fluxside</span></code></a>, <a class="reference internal" href="#core.params.wells_and_bc.pside" title="core.params.wells_and_bc.pside"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pside</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.checkGrid">
<span class="sig-name descname"><span class="pre">checkGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.checkGrid" title="Permalink to this definition"></a></dt>
<dd><p>Apply Basic Consistency Checks to MRST Grid Geometry</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">status</span> <span class="p">=</span> <span class="n">checkGrid</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – MRST Grid Structure with associate geometry.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>status</strong> – Whether or not the geometry of the input grid satisfies basic
consistency checks such as normals not pointing in opposite
directions from the centroid vectors and all cells having
positive bulk volumes and all interfaces having positive
areas.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.compareGrids">
<span class="sig-name descname"><span class="pre">compareGrids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G1</span></em>, <em class="sig-param"><span class="pre">G2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.compareGrids" title="Permalink to this definition"></a></dt>
<dd><p>Determine if two grid structures are the same.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">compareGrids</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">G2</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function considers two grids to be the same if all fundamental
grid_structure fields have the same size and values, and in the same
order within each field, in both grids.</p>
<p>Otherwise, if the grids contain equally sized and valued fundamental
fields, but the values differ in internal ordering, then the grids are
topologically equivalent but differently represented internally.</p>
<p>Otherwise, the grids are not equivalent in any sense.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G1</strong> – Two grid structures as defined in ‘grid_structure’.</p></li>
<li><p><strong>G2</strong> – Two grid structures as defined in ‘grid_structure’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Nothing</strong> – Diagnostic messages are printed to standard output stream.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Function <a class="reference internal" href="#core.utils.gridtools.compareGrids" title="core.utils.gridtools.compareGrids"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">compareGrids</span></code></a> is mainly a grid processing debugging tool.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.computeGridSlicePolygons">
<span class="sig-name descname"><span class="pre">computeGridSlicePolygons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">coord</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.computeGridSlicePolygons" title="Permalink to this definition"></a></dt>
<dd><p>Compute polygons generated by intersection of grid and plane(s). The two
modes are:
1) Single coord: optional argument ‘normal’ is used to determine plane.</p>
<blockquote>
<div><p>Intersection can furter be restricted by optional input parameters
‘radius’ and ‘axis’</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>Multiple coord: optional argument ‘cutDir’ is used to determine plane.
Slices grid along segment(s) defined be coord. Slice width can be
controlled by optional argumet ‘radius’</p></li>
</ol>
<p>vertical s</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="nb">poly</span> <span class="p">=</span> <span class="n">computeVerticalGridIntersection</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">segments</span><span class="p">)</span>
</pre></div>
</div>
<p>DESCRIPTION:</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure with geometry and preferably ‘bbox’-field included
for G.faces (see addBoundingBoxFields)</p></li>
<li><p><strong>coords</strong> – <p>Nx3 matrix. Any N&gt;0 number of coords.
If N ==1, a single cut-plane is defined by point and optional
parameter ‘normal’.
If N &gt;= 2, N-1 connected planar slices are produced where slice k
is the set of coords given by</p>
<blockquote>
<div><p>s*coords(k,:) + (1-s)*coords(k+1,:) + t*cutDir</p>
</div></blockquote>
<p>with 0&lt;=s&lt;=1. Slicing direction must be given by optional
parameter ‘cutDir’.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>‘faceIx’</strong> – Consider only subset of faces.
Default: 1:G.faces.num</p></li>
<li><p><strong>‘cellIx’</strong> – Consider only subset of faces as given by subset of cells.
Default: 1:G.cells.num</p></li>
<li><p><strong>‘cutDir’</strong> – 3x1 vector (or ‘x’,’y’,’z’) giving “slicing” direction.
If N==1, this input is ignored. For canonical directions, a
slight performance gain is obtained by e.g., setting
cutDir = ‘x’ rather than cutDir = [1 0 0]’
Default: ‘z’ (or determined from cut-plane)</p></li>
<li><p><strong>‘normal’</strong> – 3x1 vector (or ‘x’,’y’,’z’) giving normal direction to
cut-plane. If N&gt;=2, this input is ignored. For canonical
directions, a slight performance gain is obtained by e.g.,
setting cutDir = ‘x’ rather than cutDir = [1 0 0]’
Default: ‘x’ (or determined from coords and cutDir)</p></li>
<li><p><strong>‘radius’</strong> –</p>
<dl class="simple">
<dt>If N == 1:</dt><dd><p>1xd vector d = 1 or 3. Restricts slice(s) to ellipse. In
particular:
d == 1: restrict to ball with given radius
d == 3: restrict to ellipsoid with given radii</p>
</dd>
<dt>If N &gt;= 1:</dt><dd><p>scalar giving half width of slice</p>
</dd>
</dl>
<p>Default: empty (no restriction)</p>
</li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>‘axis’<span class="classifier">3x3 matrix where each column give principal axis of</span></dt><dd><p>ellipsoid
Deafault: eye(3)</p>
</dd>
</dl>
<p>EXAMPLE:</p>
<p>G  = addBoundingBoxFields(computeGeometry(cartGrid([20 20 10])));
poly = computeGridSlicePolygons(G, [15*sin((0:.1:2))’, .5*cos(0:.1:2)’, (0:.1:2)’], ‘cutDir’, [0 0 1]);
patch(‘Faces’, poly.nodes, ‘Vertices’, poly.coords3D, ‘FaceColor’, ‘y’)
view(3)</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.computeVerticalGridIntersection">
<span class="sig-name descname"><span class="pre">computeVerticalGridIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">segments</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.computeVerticalGridIntersection" title="Permalink to this definition"></a></dt>
<dd><p>Compute polygons generated by an intersection of a piecewise linear
vertical surface and grid structure</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="nb">poly</span> <span class="p">=</span> <span class="n">computeVerticalGridIntersection</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">segments</span><span class="p">)</span>
</pre></div>
</div>
<p>DESCRIPTION:</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure with geometry and preferably ‘bbox’-field included
for G.faces (see addBoundingBoxFields)</p></li>
<li><p><strong>segemts</strong> – x-y line segments (nx2) defining the piecewise linear intersection
surface. If size(segments, 2) = 3, segments(:, 1:2) is used</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>polygons</strong> – struct containing details of all traversed grid cells:
nodes    - matrix where row k contains indices to nodes (vertices)</p>
<blockquote>
<div><p>for polygon k</p>
</div></blockquote>
<p>coords3D - node coordinates
coords2D - 2D node coordinates where first coordinate is</p>
<blockquote>
<div><p>along length of segmnents, and second is z-coordinate</p>
</div></blockquote>
<dl class="simple">
<dt>cellIx   - index vector where entry k points to grid-cell</dt><dd><p>being cut by k-th polygon.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span>    <span class="p">=</span> <span class="n">addBoundingBoxFields</span><span class="p">(</span><span class="n">computeGeometry</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">20</span> <span class="mi">20</span> <span class="mi">10</span><span class="p">])))</span>
<span class="nb">poly</span> <span class="p">=</span> <span class="n">computeVerticalGridIntersection</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">15</span><span class="o">*</span><span class="p">[</span><span class="nb">sin</span><span class="p">((</span><span class="mi">0</span><span class="p">:.</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">))</span><span class="o">&#39;</span><span class="p">,</span> <span class="p">.</span><span class="mi">5</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="mi">0</span><span class="p">:.</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">)</span><span class="o">&#39;</span><span class="p">]);</span>
<span class="nb">patch</span><span class="p">(</span><span class="s">&#39;Faces&#39;</span><span class="p">,</span> <span class="nb">poly</span><span class="p">.</span><span class="n">nodes</span><span class="p">,</span> <span class="s">&#39;Vertices&#39;</span><span class="p">,</span> <span class="nb">poly</span><span class="p">.</span><span class="n">coords3D</span><span class="p">,</span> <span class="s">&#39;FaceColor&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">)</span>
<span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.connectedCells">
<span class="sig-name descname"><span class="pre">connectedCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.connectedCells" title="Permalink to this definition"></a></dt>
<dd><p>Compute connected components of grid cell subsets.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="p">=</span> <span class="n">connectedCells</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>c</strong> – Cell subset.  List (array) of grid cell indices, or logical mask
into the cells of ‘G’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong> – Connected component set.  An n-element <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cell</span></code> array, one element for
each component, of grid cells.  Specifically, s{i} contains the
grid cell indices of component ‘i’.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dmperm</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.convertHorizonsToGrid">
<span class="sig-name descname"><span class="pre">convertHorizonsToGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">horizons</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.convertHorizonsToGrid" title="Permalink to this definition"></a></dt>
<dd><p>Build corner-point grid based on a series of horizons</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">convertHorizonsToGrid</span><span class="p">(</span><span class="n">horizons</span><span class="p">)</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">convertHorizonsToGrid</span><span class="p">(</span><span class="n">horizons</span><span class="p">,</span> <span class="s">&#39;pn&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>horizons</strong> – A cell array of structures describing the surfaces that make
up the individual horizons. There must at least be two such
horizons. The structure should contain three fields (x,y,z)
that give the coordinates of the respective horizons. The x
and y coordinates are assumed to lie on a rectilinear grid
(i.e., what MATLAB refers to as a meshgrid), but the number
of mesh points need not be the same in the different surfaces.</p></li>
<li><p><strong>'dims'</strong> – A 2-vector <code class="xref mat mat-func docutils literal notranslate"><span class="pre">[nx,</span> <span class="pre">ny]</span></code> giving the number of cells in each
spatial direction inside the iterpolation area. If this
optional parameter is not specified, the number of cells in
the interpolation region will be the same as the maximum of
mesh points found in each spatial direction for all the input
horizons.</p></li>
<li><p><strong>'layers'</strong> – A vector specifying the number of grid layers to be inserted
in between each pair of horizon surfaces</p></li>
<li><p><strong>'repairFunction'</strong> – Function handle to repair inter-layer collisions. Can
be e.g. &#64;max or &#64;min to take either the top or bottom
layer for a segment.</p></li>
<li><p><strong>'method'</strong> – Method to use for interpolating between points. Can use any
of the choices available for griddedInterpolant. Defaults to
linear.</p></li>
<li><p><strong>'extrapMethod'</strong> – Extrapolation method. Defaults to ‘none’.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Description:</p>
<p>The function uses ‘interp2’ to interpolate between pairs of horizons.
The interpolation region is set to be the minimum rectangle that
contains the areal bounding boxes of all the horizons, inside which the
routine will interpolate on a Cartesian grid of size dims(1) x dims(2).
The output grid, however, will only contain cells that are contained
inside the maximum areal rectangle that fits inside all the individual
areal bounding boxes</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – A GRDECL structure suitable for passing to function
<a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">peaks</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
<span class="n">horizons</span> <span class="p">=</span> <span class="p">{</span><span class="nb">struct</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">&#39;z&#39;</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="nb">struct</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">&#39;z&#39;</span><span class="p">,</span><span class="n">z</span><span class="o">+</span><span class="mi">5</span><span class="p">)};</span>
<span class="n">grdecl</span>   <span class="p">=</span> <span class="n">convertHorizonsToGrid</span><span class="p">(</span><span class="n">horizons</span><span class="p">,</span><span class="s">&#39;layers&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">G</span>        <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">);</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="nb">axis</span> <span class="n">tight</span>

<span class="n">horizons</span> <span class="p">=</span> <span class="p">{</span><span class="nb">struct</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">&#39;z&#39;</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="nb">struct</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;z&#39;</span><span class="p">,</span><span class="n">z</span><span class="o">+</span><span class="mi">10</span><span class="p">)};</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">processGRDECL</span><span class="p">(</span><span class="n">convertHorizonsToGrid</span><span class="p">(</span><span class="n">horizons</span><span class="p">,</span><span class="s">&#39;dims&#39;</span><span class="p">,[</span><span class="mi">20</span> <span class="mi">20</span><span class="p">]));</span>
<span class="nb">figure</span><span class="p">,</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="nb">view</span><span class="p">(</span><span class="o">-</span><span class="mi">140</span><span class="p">,</span><span class="mi">30</span><span class="p">);</span> <span class="nb">axis</span> <span class="n">tight</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.testgrids.makeModel3" title="core.gridprocessing.testgrids.makeModel3"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makeModel3</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.createAugmentedGrid">
<span class="sig-name descname"><span class="pre">createAugmentedGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.createAugmentedGrid" title="Permalink to this definition"></a></dt>
<dd><p>Extend grid with mappings needed for the virtual element solver</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>G<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">createAugmentedGrid</span><span class="p">(</span>G<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>The grid structure as described by <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a> lacks some
mappings and structures that are needed for the assembly of the VEM
method. Those are added by calling the function <a class="reference internal" href="#core.utils.gridtools.createAugmentedGrid" title="core.utils.gridtools.createAugmentedGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">createAugmentedGrid</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure as described by <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid structure as described by <a class="reference internal" href="#core.gridprocessing.extended_grid_structure" title="core.gridprocessing.extended_grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">extended_grid_structure</span></code></a> (call the
function extended_grid_structure to display the documentation).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method assumes that the edges are sorted. The sorting rule can be
found found the documentation displayed by calling
<a class="reference internal" href="#core.gridprocessing.extended_grid_structure" title="core.gridprocessing.extended_grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">extended_grid_structure</span></code></a>. The function <a class="reference internal" href="#core.utils.gridtools.sortEdges" title="core.utils.gridtools.sortEdges"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">sortEdges</span></code></a> outputs a grid for
which the edges are guaranted to be sorted.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.createGridMappings">
<span class="sig-name descname"><span class="pre">createGridMappings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.createGridMappings" title="Permalink to this definition"></a></dt>
<dd><p>Add preliminary mappings to be used in <a class="reference internal" href="#core.utils.gridtools.createAugmentedGrid" title="core.utils.gridtools.createAugmentedGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">createAugmentedGrid</span></code></a></p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>w<span class="w">  </span><span class="p">=</span><span class="w"> </span><span class="nf">createGridMappings</span><span class="p">(</span>g<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>DESCRIPTION:
Create preliminary structures which is used to conveniently set up the
grid mapping, see <a class="reference internal" href="#core.gridprocessing.extended_grid_structure" title="core.gridprocessing.extended_grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">extended_grid_structure</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>w</strong> – preliminary structure to be used in <a class="reference internal" href="#core.utils.gridtools.createAugmentedGrid" title="core.utils.gridtools.createAugmentedGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">createAugmentedGrid</span></code></a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.gridtools.createAugmentedGrid" title="core.utils.gridtools.createAugmentedGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">createAugmentedGrid</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.findEnclosingCell">
<span class="sig-name descname"><span class="pre">findEnclosingCell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">pt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.findEnclosingCell" title="Permalink to this definition"></a></dt>
<dd><p>Find cell(s) containing points. The cells must be convex.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="p">=</span> <span class="n">findEnclosingCell</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Valid grid structure with normals, face and cell centroids. The
cells must be convex.</p></li>
<li><p><strong>pt</strong> – Set of point coordinates, represented as an n-by-dim array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>c</strong> – Set of grid cells. Specifically, c(k), k=1:n, contains pt(k,:). If
a point lies on the boundary between two cells, the function
returns the smallest index. c(k) is zero if the point is not
found.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.pebi" title="core.gridprocessing.pebi"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">pebi</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.getCellNoFaces">
<span class="sig-name descname"><span class="pre">getCellNoFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.getCellNoFaces" title="Permalink to this definition"></a></dt>
<dd><p>Get a list over all half faces, accounting for possible NNC</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">cellNo</span><span class="p">,</span> <span class="n">cellFaces</span><span class="p">,</span> <span class="n">isNNC</span><span class="p">]</span> <span class="p">=</span> <span class="n">getCellNoFaces</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This utility function is used to produce a listing of all half faces
in a grid along with the respective cells they belong to. While
relatively trivial for most grids, this function specifically accounts
for non-neighboring connections / NNC.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure with optional .nnc.cells field.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>cellNo</strong> – A list of length number of geometric half-faces + 2* no. nnc
connections where each entry corresponds to the cell index of
that half face.</p></li>
<li><p><strong>cellFaces</strong> – A list of length number of geometric half-faces + 2* number
of nnc connections where each entry is the connection index.
For the first entries, this is simply the face number.
Otherwise, it is the entry of the NNC connection.</p></li>
<li><p><strong>isNNC</strong> – A list with the same length as cellNo / cellFaces,
containing a boolean indicating if that specific connection
originates from a geometric face or a NNC connection</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.rldecode" title="core.utils.rldecode"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">rldecode</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.getConnectivityMatrix">
<span class="sig-name descname"><span class="pre">getConnectivityMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">N</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.getConnectivityMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Derive global, undirected connectivity matrix from neighbourship relation.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="p">=</span> <span class="n">getConnectivityMatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">A</span> <span class="p">=</span> <span class="n">getConnectivityMatrix</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">incDiag</span><span class="p">)</span>
<span class="n">A</span> <span class="p">=</span> <span class="n">getConnectivityMatrix</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">incDiag</span><span class="p">,</span> <span class="n">nRows</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> – Neighbourship relation as defined by function
<a class="reference internal" href="#core.utils.gridtools.getNeighbourship" title="core.utils.gridtools.getNeighbourship"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getNeighbourship</span></code></a>.  Must consist entirely of internal
connections (i.e., no boundary connections must be included).</p></li>
<li><p><strong>incDiag</strong> – Flag to indicate whether or not to include the “self”
connections (i.e., the diagonal entries) in the connectivity
matrix.  LOGICAL.  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">incDiag</span> <span class="pre">=</span> <span class="pre">false</span></code> (don’t
include “self” connections, in which case the resulting
matrix is the same as the graph’s adjacency matrix).</p></li>
<li><p><strong>nRows</strong> – Size (number of rows) of the resulting connectivity matrix.
Used to create the diagonal entries of the connectivity
matrix when <code class="xref mat mat-func docutils literal notranslate"><span class="pre">incDiag</span></code> is <code class="xref mat mat-func docutils literal notranslate"><span class="pre">true</span></code>.  Scalar integer.  Default
value: nRows = -1 (determine matrix size from maximum index
in the neighbourship relation, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">N</span></code>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>A</strong> – Undirected connectivity matrix that represents all cell’s
neighbourship relations (edges).</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Compute and plot the connectivity (&quot;graph&quot;) matrix resulting from the</span>
<span class="c">% (internal) geometrical connections in a Cartesian grid.  Include the</span>
<span class="c">% diagonal entries of the connectivity matrix.</span>
<span class="c">%</span>
<span class="p">[</span><span class="n">incBdry</span><span class="p">,</span> <span class="n">incDiag</span><span class="p">]</span> <span class="p">=</span> <span class="nb">deal</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">60</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">85</span><span class="p">]);</span>
<span class="n">N</span> <span class="p">=</span> <span class="n">getNeighbourship</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s">&#39;Geometrical&#39;</span><span class="p">,</span> <span class="n">incBdry</span><span class="p">);</span>
<span class="n">A</span> <span class="p">=</span> <span class="n">getConnectivityMatrix</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">incDiag</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span><span class="p">);</span>
<span class="nb">spy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.gridtools.getNeighbourship" title="core.utils.gridtools.getNeighbourship"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getNeighbourship</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.getFacesCloseToSegment">
<span class="sig-name descname"><span class="pre">getFacesCloseToSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">seg</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.getFacesCloseToSegment" title="Permalink to this definition"></a></dt>
<dd><p>Get index to faces that lie “in the vicinity” of the line segment seg.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="nb">fix</span> <span class="p">=</span>  <span class="n">getFacesCloseToSegment</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">)</span>
</pre></div>
</div>
<p>DESCRIPTION:
With default options, returned face-list will contain all but most likely
<em>not</em> only the faces actually intersected by the segment. Function is useful
for quickly obtaining a small subset for subsequent more accurate and costly
intersecion evaluatioins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure with geometry and preferably ‘bbox’-field included
for G.faces (see addBoundingBoxFields)</p></li>
<li><p><strong>seg</strong> – Segment given as two points (2x3). If more than two points (nx3),
line of best fit is computed with search radius expanded
according to maximal point-line distance. If point dimension
is 2, computations are perfomed in xy.</p></li>
</ul>
</dd>
</dl>
<p>OPTIONAL PARAMETERS:</p>
<p>‘faceIx’  : consider only subset of grids faces (default all)
‘fac’     : “Closeness”-factor. Default is 2/3 which is sufficient to</p>
<blockquote>
<div><p>gurantee that output includes all faces intersected by segment</p>
</div></blockquote>
<dl class="simple">
<dt>‘projVec’<span class="classifier">project points to a plane orthogonal to projVec. E.g., if</span></dt><dd><p>projVec = [0 0 1], fix will be faces that are ‘close’ to seg
in the xy-plane (disrgarding the z-coordinate). Default:
empty.</p>
</dd>
<dt>RETURNS</dt><dd><p>fix      : resulting index of grid faces</p>
</dd>
<dt>SEE ALSO</dt><dd><p>computeTraversedCells, computeVerticalGridIntersection</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.getNeighbourship">
<span class="sig-name descname"><span class="pre">getNeighbourship</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.getNeighbourship" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve neighbourship relation (“graph”) from grid</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">N</span>         <span class="p">=</span> <span class="n">getNeighbourship</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
 <span class="n">N</span>         <span class="p">=</span> <span class="n">getNeighbourship</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
 <span class="n">N</span>         <span class="p">=</span> <span class="n">getNeighbourship</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">incBdry</span><span class="p">)</span>

<span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">isnnc</span><span class="p">]</span> <span class="p">=</span> <span class="n">getNeighbourship</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – MRST grid as defined by <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p></li>
<li><p><strong>kind</strong> – <p>What kind of neighbourship relation to extract.  String.  The
following options are supported:</p>
<blockquote>
<div><ul>
<li><p>’Geometrical’:
Extract geometrical neighbourship relations.  The
geometric connections correspond to physical,
geometric interfaces and are the ones listed in
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.neighbors</span></code>.</p></li>
<li><p>’Topological’:
Extract topological neighbourship relations.  In
addition to the geometrical relations of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Geometrical</span></code>
these possibly include non-neighbouring connections
resulting from pinch-out processing or explicit NNC
lists in an ECLIPSE input deck.</p>
<blockquote>
<div><p>Additional connections will only be defined if the
grid <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> contains an <code class="xref mat mat-func docutils literal notranslate"><span class="pre">nnc</span></code> sub-structure.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>incBdry</strong> – Flag to indicate whether or not to include boundary
connections.  A boundary connection is a connection in which
one of the connecting cells is the outside (i.e., cell zero).
LOGICAL scalar.  Default value: incBdry = FALSE (do NOT
include boundary connections).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul>
<li><p><strong>N</strong> – Neighbourship relation.  An m-by-2 array of cell indices that
form the connections, geometrical or otherwise.  This array has
similar interpretation to the field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.neighbors</span></code>, but
may contain additional connections if kind=’Topological’.</p></li>
<li><p><strong>isnnc</strong> – An m-by-1 LOGICAL array indicating whether or not the
corresponding connection (row) of N is a geometrical connection
(i.e., a geometric interface from the grid <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code>).</p>
<p>Specifically, isnnc(i) is TRUE if N(i,:) comes from a
non-neighbouring (i.e., non-geometrical) connection.</p>
</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the neighbourship relation is later to be used to compute the graph
adjacency matrix using function <a class="reference internal" href="#core.utils.gridtools.getConnectivityMatrix" title="core.utils.gridtools.getConnectivityMatrix"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getConnectivityMatrix</span></code></a>, then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">incBdry</span></code>
must be <code class="xref mat mat-func docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processPINCH" title="core.gridprocessing.processPINCH"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processPINCH</span></code></a>, <a class="reference internal" href="#core.utils.gridtools.getConnectivityMatrix" title="core.utils.gridtools.getConnectivityMatrix"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getConnectivityMatrix</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.gridAddHelpers">
<span class="sig-name descname"><span class="pre">gridAddHelpers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.gridAddHelpers" title="Permalink to this definition"></a></dt>
<dd><p>Add helpers to existing grid structure for cleaner code structure.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">gridAddHelpers</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid structure with added fields:</p>
<ul class="simple">
<li><p>plot contains handles to plotting functions</p></li>
<li><p>helpers contains various helper functions commonly used
when plotting/debugging grid structures.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.gridCellFaces">
<span class="sig-name descname"><span class="pre">gridCellFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">c</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.gridCellFaces" title="Permalink to this definition"></a></dt>
<dd><p>Find faces corresponding to a set of cells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">cf</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="p">=</span> <span class="n">gridCellFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure</p></li>
<li><p><strong>c</strong> – Cells where the fine faces are desired</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>p</strong> – indirectionmap into <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code>. The faces of cell <code class="xref mat mat-func docutils literal notranslate"><span class="pre">c(i)</span></code> is found at
positions <code class="xref mat mat-func docutils literal notranslate"><span class="pre">p(i):p(i+1)-1</span></code> in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p><strong>cf</strong> – cell face positions in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.gridCellNo">
<span class="sig-name descname"><span class="pre">gridCellNo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.gridCellNo" title="Permalink to this definition"></a></dt>
<dd><p>Construct map from half-faces to cells or cell subset</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">cellno</span> <span class="p">=</span> <span class="n">gridCellNo</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">cellno</span> <span class="p">=</span> <span class="n">gridCellNo</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure.</p></li>
<li><p><strong>c</strong> – <p>Cells for which to construct mapping.  Array of numeric cell
indices in the range 1:G.cells.num .</p>
<p>OPTIONAL.  If unspecified, function <a class="reference internal" href="#core.utils.gridtools.gridCellNo" title="core.utils.gridtools.gridCellNo"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">gridCellNo</span></code></a> will behave as
if</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="p">=</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">cells</span><span class="p">.</span><span class="n">num</span>
</pre></div>
</div>
<p>In other words the map will be constructed for all grid cells.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cellno</strong> – Map from half-faces to cell or cell subset indices.  The
expression:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">c</span><span class="p">(</span><span class="n">cellno</span><span class="p">(</span><span class="n">hf</span><span class="p">))</span>
</pre></div>
</div>
<p>derives the cell in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> to which half-face <code class="xref mat mat-func docutils literal notranslate"><span class="pre">hf</span></code> belongs.  This, in
turn, means that if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">c</span></code> is unspecified, then <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cellno(hf)</span></code> is that
cell directly.  The half-face <code class="xref mat mat-func docutils literal notranslate"><span class="pre">hf</span></code> must be relative to the cell
subset identified by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">c</span></code> or global if <code class="xref mat mat-func docutils literal notranslate"><span class="pre">c</span></code> is not specified.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.gridCellNodes">
<span class="sig-name descname"><span class="pre">gridCellNodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">c</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.gridCellNodes" title="Permalink to this definition"></a></dt>
<dd><p>Extract nodes per cell in a particular set of cells</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="p">=</span> <span class="n">gridCellNodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="p">=</span> <span class="n">gridCellNodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure.</p></li>
<li><p><strong>c</strong> – Cells for which to extract unique nodes.  Array of numeric
cell indices.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘unique’</strong> – Whether or not to compute <em>unique</em> nodes per cell. Boolean
flag (Logical).  Default value: unique = true (do compute
uniuqe nodes without repetitions per cell).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Computing unique nodes (i.e., setting option ‘unique’ to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">true</span></code>)
increases the computational complexity of function <a class="reference internal" href="#core.utils.gridtools.gridCellNodes" title="core.utils.gridtools.gridCellNodes"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">gridCellNodes</span></code></a>
because this leads to invoking function <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sortrows</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Nodes per cell.  Unique nodes if option <code class="xref mat mat-func docutils literal notranslate"><span class="pre">unique</span></code> is <code class="xref mat mat-func docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
<li><p><strong>pos</strong> – Indirection map into n.  The nodes of cell <code class="xref mat mat-func docutils literal notranslate"><span class="pre">c(i)</span></code> are in positions
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">p(i)</span> <span class="pre">:</span> <span class="pre">p(i+1)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">pu</span><span class="p">]</span> <span class="p">=</span> <span class="n">gridCellNodes</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">pn</span><span class="p">]</span> <span class="p">=</span> <span class="n">gridCellNodes</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;unique&#39;</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">sortrows</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.gridFaceNodes">
<span class="sig-name descname"><span class="pre">gridFaceNodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.gridFaceNodes" title="Permalink to this definition"></a></dt>
<dd><p>Find nodes corresponding to a set of faces</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="p">=</span> <span class="n">gridFaceNodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure</p></li>
<li><p><strong>c</strong> – Cells where the fine nodes are desired</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>pos</strong> – indirection map into <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code>. The nodes of face <code class="xref mat mat-func docutils literal notranslate"><span class="pre">f(i)</span></code> is found at
positions <code class="xref mat mat-func docutils literal notranslate"><span class="pre">p(i):p(i+1)-1</span></code> in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p><strong>n</strong> – node positions in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.gridLogicalIndices">
<span class="sig-name descname"><span class="pre">gridLogicalIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.gridLogicalIndices" title="Permalink to this definition"></a></dt>
<dd><p>Given grid G and optional subset of cells, find logical indices.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">ijk</span> <span class="p">=</span> <span class="n">gridLogicalIndices</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">ijk</span> <span class="p">=</span> <span class="n">gridLogicalIndices</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="p">=</span> <span class="n">gridLogicalIndices</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>c</strong> – cells for which logical indices are to be computed. Defaults to
all cells <code class="xref mat mat-func docutils literal notranslate"><span class="pre">1:G.cells.num</span></code>;</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ijk</strong> – If one output paramter is requested: Cell array of size
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">numel(G.cartDims)</span></code> where <code class="xref mat mat-func docutils literal notranslate"><span class="pre">ijk{1}</span></code> contains logical indices
corresponding to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.cartDims(1)</span></code> and so on.</p></li>
<li><p><strong>i,j,k</strong> – If multiple outputs are requested: Corresponding to logical
indices for different <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartDims</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="n">ijk</span> <span class="p">=</span> <span class="n">gridLogicalIndices</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.indirectionSub">
<span class="sig-name descname"><span class="pre">indirectionSub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">i</span></em>, <em class="sig-param"><span class="pre">valuePos</span></em>, <em class="sig-param"><span class="pre">values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.indirectionSub" title="Permalink to this definition"></a></dt>
<dd><p>Look-up in index map of the type G.cells.facePos, G.faces.nodePos, etc</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="p">=</span> <span class="n">indirectionSub</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">valuePos</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – Indices where we want values, for instance a list of
cells if valuePos is G.cells.facePos.</p></li>
<li><p><strong>valuePos</strong> – Mapping from i to values.</p></li>
<li><p><strong>values</strong> – The actual values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>v</strong> – The set of values corresonding to i.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.makeLayeredHorizonGrid">
<span class="sig-name descname"><span class="pre">makeLayeredHorizonGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G2D</span></em>, <em class="sig-param"><span class="pre">horizons</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.makeLayeredHorizonGrid" title="Permalink to this definition"></a></dt>
<dd><p>Build 3D grid that adapts to a set of horizons from a 2D grid by making a
layered grid and interpolating z coordinates between horizons</p>
<blockquote>
<div><dl>
<dt>SYNOPSIS:</dt><dd><p>G = makeLayeredHorizonGrid(G2D, horizons)
G = makeLayeredHorizonGrid(G2D, horizons, ‘pn’, pv)</p>
</dd>
<dt>PARAMETERS:</dt><dd><p>G        - A 2D grid to be extruded to 3D
horizons - A cell array of structures describing the surfaces that make</p>
<blockquote>
<div><p>up the individual horizons. There must at least be two such
horizons. The structure should contain three fields (x,y,z)
that give the coordinates of the respective horizons. The x
and y coordinates are assumed to lie on a rectilinear grid
(i.e., what MATLAB refers to as a meshgrid), but the number
of mesh points need not be the same in the different surfaces.</p>
</div></blockquote>
<dl class="simple">
<dt>‘layers’ - A vector specifying the number of grid layers to be inserted</dt><dd><p>in between each pair of horizon surfaces</p>
</dd>
<dt>‘repairFunction’  - Function handle to repair inter-layer collisions.</dt><dd><p>Can be e.g. &#64;max or &#64;min to take either the top or
bottom layer for a segment.</p>
</dd>
<dt>‘repairFunction2’ - Function handle to repair inter-layer collisions.</dt><dd><p>Can be e.g. &#64;max or &#64;min to take either the top or
bottom layer for a segment.</p>
</dd>
<dt>‘method’ - Method to use for interpolating between points. Can use any</dt><dd><p>of the choices available for griddedInterpolant. Defaults to
linear.</p>
</dd>
</dl>
<p>‘extrapMethod’ - Extrapolation method. Defaults to ‘none’.</p>
</dd>
</dl>
<p>DESCRIPTION:</p>
<dl>
<dt>RETURNS:</dt><dd><p>G - A valid MRST grid structure</p>
</dd>
<dt>EXAMPLES:</dt><dd><p>[y,x,z]  = peaks(30);
horizons = {struct(‘x’,x,’y’,y,’z’,z),struct(‘x’,x,’y’,y,’z’,z+5)};
G2D      = tensorGrid(x(:,1), y(1,:)’);
G        = makeLayeredHorizonGrid(G2D, horizons,’layers’, 2);
figure, plotGrid(G); view(3); axis tight</p>
<p>horizons = {struct(‘x’,x,’y’,y,’z’,z),struct(‘x’,x,’y’,2*y+1,’z’,z+10)};
mrstModule add upr
G2D = pebiGrid2D(6/25, [6,6], ‘polyBdr’, [-3,-3; 3,-3; 3,3; -3,3]);
G   = makeLayeredHorizonGrid(G2D, horizons,’layers’, 2);
figure, plotGrid(G); view(-140,30); axis tight</p>
</dd>
<dt>SEE ALSO:</dt><dd><p><a class="reference internal" href="#core.utils.gridtools.convertHorizonsToGrid" title="core.utils.gridtools.convertHorizonsToGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertHorizonsToGrid</span></code></a></p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.makePlanarGrid">
<span class="sig-name descname"><span class="pre">makePlanarGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">H</span></em>, <em class="sig-param"><span class="pre">faces</span></em>, <em class="sig-param"><span class="pre">sgn</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.makePlanarGrid" title="Permalink to this definition"></a></dt>
<dd><p>Construct 2D surface grid from faces of 3D grid.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="p">=</span> <span class="n">makePlanarGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">sgn</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Valid grid definition containing connectivity, cell
geometry, face geometry and unique nodes.</p></li>
<li><p><strong>faces</strong> – List of faces in original 3D grid G that are cells in g.</p></li>
<li><p><strong>sgn</strong> – Sign of face in 3D grid associated with each cell in g.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>g</strong> – Valid 2D grid.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">makePlanarGrid</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">36</span><span class="p">)</span><span class="o">&#39;</span><span class="p">,</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="n">plotGrid</span><span class="p">(</span><span class="n">G</span><span class="p">);</span> <span class="n">plotGrid</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="s">&#39;facecolor&#39;</span><span class="p">,</span><span class="s">&#39;none&#39;</span><span class="p">);</span><span class="nb">view</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All node coordinates in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">H.nodes</span></code> are copied to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.nodes</span></code>, and
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.nodes</span></code> refer to this numbering of nodes.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.gridtools.makePlanarGrid" title="core.utils.gridtools.makePlanarGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">makePlanarGrid</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.neighboursByNodes">
<span class="sig-name descname"><span class="pre">neighboursByNodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.neighboursByNodes" title="Permalink to this definition"></a></dt>
<dd><p>Derive neighbourship from common node (vertex) relationship</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="p">=</span> <span class="n">neighboursByNodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>N</strong> – A neighbourship relation (m-by-2 array of inter-cell connections
(i.e., cell pairs)).  Two cells are defined to be neighbours (and
entered into the neighbourship relation) if they share a common
node.  The neighbourship relation is not symmetric and does not
include self-connections.</p>
<p>Use the statement</p>
<blockquote>
<div><p>Adj = getConnectivityMatrix(N, true, G.cells.num)</p>
</div></blockquote>
<p>to convert the neighbourship relation <code class="xref mat mat-func docutils literal notranslate"><span class="pre">N</span></code> into an undirected
adjacency matrix (neighbourhood), <code class="xref mat mat-func docutils literal notranslate"><span class="pre">Adj</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function uses <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sortrows</span></code> and is potentially <em>very</em> expensive in
terms of memory use.  As an example, the statement</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="p">=</span> <span class="n">neighboursByNodes</span><span class="p">(</span><span class="n">cartGrid</span><span class="p">([</span><span class="mi">60</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">85</span><span class="p">]))</span>
</pre></div>
</div>
<p>requires about 6.5 GB of RAM and takes in the order of 20 seconds on a
workstation from the autumn of 2009.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.gridtools.getConnectivityMatrix" title="core.utils.gridtools.getConnectivityMatrix"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getConnectivityMatrix</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">sortrows</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.refineGrdeclLayers">
<span class="sig-name descname"><span class="pre">refineGrdeclLayers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">layers</span></em>, <em class="sig-param"><span class="pre">ref</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.refineGrdeclLayers" title="Permalink to this definition"></a></dt>
<dd><p>Refine a GRDECL structure in the vertical direction</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>ngrdecl<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">refineGrdeclLayers</span><span class="p">(</span>grdecl, layers, ref<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Refine corner-point grid in vertical direction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grdecl</strong> – Grid in Eclipse format</p></li>
<li><p><strong>layers</strong> – Refine vertical layers from layers(1) to layers(2)</p></li>
<li><p><strong>ref</strong> – Vertical refinement factor for each cell</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ngrdecl</strong> – Refined grid in eclipse format.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.refineGrdecl" title="core.gridprocessing.refineGrdecl"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">refineGrdecl</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.sampleFromBox">
<span class="sig-name descname"><span class="pre">sampleFromBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">c</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.sampleFromBox" title="Permalink to this definition"></a></dt>
<dd><p>Sample from data on a uniform Cartesian grid that covers the bounding box</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="p">=</span> <span class="n">sampleFromBox</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="n">q</span> <span class="p">=</span> <span class="n">sampleFromBox</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – grid structure</p></li>
<li><p><strong>p</strong> – input array to sample from. The array is assumed to be values
on a uniform Cartesian grid covers the bounding box of grid <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code>.
The values should be given as a Nx by Ny matrix where Nx and Ny
is the number of values in the x and y direction, respectively.</p></li>
<li><p><strong>c</strong> – array specifying a subset of cells in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code> in which values will be
sampled</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>q</strong> – output vector sampled at the centroids of grid cells in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.searchForBoundaryFaces">
<span class="sig-name descname"><span class="pre">searchForBoundaryFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">direction</span></em>, <em class="sig-param"><span class="pre">i1</span></em>, <em class="sig-param"><span class="pre">i2</span></em>, <em class="sig-param"><span class="pre">i3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.searchForBoundaryFaces" title="Permalink to this definition"></a></dt>
<dd><p>Search for boundary faces within (a subset of) a logically Cartesian grid</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">ix</span> <span class="p">=</span> <span class="n">searchForBoundaryFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>
<span class="n">ix</span> <span class="p">=</span> <span class="n">searchForBoundaryFaces</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i3</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>side</strong> – <p>Global side from which to extract face indices.  String.  Must
(case insensitively) match one of six alias groups:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>{‘West’ , ‘XMin’, ‘Left’  }</p></li>
<li><p>{‘East’ , ‘XMax’, ‘Right’ }</p></li>
<li><p>{‘South’, ‘YMin’, ‘Back’  }</p></li>
<li><p>{‘North’, ‘YMax’, ‘Front’ }</p></li>
<li><p>{‘Upper’, ‘ZMin’, ‘Top’   }</p></li>
<li><p>{‘Lower’, ‘ZMax’, ‘Bottom’}</p></li>
</ol>
</div></blockquote>
<p>These groups correspond to the cardinal directions mentioned as
the first alternative in each group.</p>
</p></li>
<li><p><strong>i1</strong> – Index ranges in which one is to look for boundary faces in
the three axial directions</p></li>
<li><p><strong>i2</strong> – Index ranges in which one is to look for boundary faces in
the three axial directions</p></li>
<li><p><strong>i3</strong> – Index ranges in which one is to look for boundary faces in
the three axial directions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ix</strong> – Required face indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.sortEdges">
<span class="sig-name descname"><span class="pre">sortEdges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.sortEdges" title="Permalink to this definition"></a></dt>
<dd><p>Sort edges in G.faces.edges counter-clockwise to face orientation</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>G<span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">sortEdges</span><span class="p">(</span>G<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Each face has an orientation. A face indexed by <code class="xref mat mat-func docutils literal notranslate"><span class="pre">i</span></code> is oriented from
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.neighbors(i,</span> <span class="pre">1)</span></code> to <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.neighbors(i,</span> <span class="pre">2)</span></code>. The edges
should be ordered in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">G.faces.edges</span></code> (see <a class="reference internal" href="#core.gridprocessing.extended_grid_structure" title="core.gridprocessing.extended_grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">extended_grid_structure</span></code></a>)
counter-clock-wise with respect to the face orientation. The function
<a class="reference internal" href="#core.utils.gridtools.sortEdges" title="core.utils.gridtools.sortEdges"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">sortEdges</span></code></a> guarantes that this ordering is satisfied. Such check has
only to be done in 2D because the 3D <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a> standard always
guarantees that it holds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid structure with sorted edges.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.extended_grid_structure" title="core.gridprocessing.extended_grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">extended_grid_structure</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.sortGrid">
<span class="sig-name descname"><span class="pre">sortGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.sortGrid" title="Permalink to this definition"></a></dt>
<dd><p>Permute nodes, faces and cells to sorted form</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">sortGrid</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure as described by grid_structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Modified grid structure with nodes in natural order, sorted
z-, y- and x-components, faces sorted by corner node numbers
and cells sorted by face numbers.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that the ordering of faces and cells is NOT the natural ordering
as generated by <a class="reference internal" href="#core.gridprocessing.cartGrid" title="core.gridprocessing.cartGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartGrid</span></code></a> and <a class="reference internal" href="#core.gridprocessing.tensorGrid" title="core.gridprocessing.tensorGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">tensorGrid</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.gridtools.compareGrids" title="core.utils.gridtools.compareGrids"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">compareGrids</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.sortHorizons">
<span class="sig-name descname"><span class="pre">sortHorizons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">horizons</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.sortHorizons" title="Permalink to this definition"></a></dt>
<dd><p>Undocumented Utility Function</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.transform3Dto2Dgrid">
<span class="sig-name descname"><span class="pre">transform3Dto2Dgrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.transform3Dto2Dgrid" title="Permalink to this definition"></a></dt>
<dd><p>Transforms a 3D grid into a 2D grid.
3D grid must be constant in either x-, y- or z-direction.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.translateGrid">
<span class="sig-name descname"><span class="pre">translateGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">dx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.translateGrid" title="Permalink to this definition"></a></dt>
<dd><p>Move all grid coordinates according to particular translation</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">translateGrid</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – MRST grid as outlined in <a class="reference internal" href="#core.gridprocessing.grid_structure" title="core.gridprocessing.grid_structure"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">grid_structure</span></code></a>.</p></li>
<li><p><strong>dx</strong> – User-specified constant translation vector.  Must be a single
vector that will applied to all grid coordinates (i.e., nodes and
centroids).  Number of vector components must be equal to the
number of vertex coordinates (i.e., <code class="xref mat mat-func docutils literal notranslate"><span class="pre">size(G.nodes.coords,</span> <span class="pre">2)</span></code>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Updated grid structure.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.gridtools.volumeByGaussGreens">
<span class="sig-name descname"><span class="pre">volumeByGaussGreens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.gridtools.volumeByGaussGreens" title="Permalink to this definition"></a></dt>
<dd><p>Compute cell volume by means of Gauss-Greens’ formula</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="p">=</span> <span class="n">volumeByGaussGreens</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>V</strong> – G.cells.num-by-1 array of cell volumes computed by means of
Gauss-Greens formula.  This is a useful consistency check when
developing new grid processing tools.  In most cases, this value
should not deviate too much from the ‘G.cells.volumes’ value
computed by the ‘computeGeometry’ function.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.computeGeometry" title="core.gridprocessing.computeGeometry"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">computeGeometry</span></code></a>.</p>
</div>
</dd></dl>

<span class="target" id="module-core.utils.inout"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.inout.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.inout.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>INOUT</dt><dd><p>Low-level input routines for ECLIPSE deck.</p>
</dd>
<dt>Files</dt><dd><p>cacheDir          - Define platform-dependent directory for temporary files.
convertInputUnits - Convert input data to MRST’s strict SI conventions
readCache         - Read cached variables associated with given file into caller’s workspace.
writeCache        - Write callers workspace to matfile in directory ./.cache/
writeGRDECL       - Write a GRDECL structure out to permanent file on disk.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.cacheDir">
<span class="sig-name descname"><span class="pre">cacheDir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.cacheDir" title="Permalink to this definition"></a></dt>
<dd><p>Define platform-dependent directory for temporary files.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.convertInputUnits">
<span class="sig-name descname"><span class="pre">convertInputUnits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">u</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.convertInputUnits" title="Permalink to this definition"></a></dt>
<dd><p>Convert input data to MRST’s strict SI conventions</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">convertInputUnits</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grdecl</strong> – Input data structure as defined by function ‘readGRDECL’.</p></li>
<li><p><strong>u</strong> – Input unit convention data structure as defined by function
‘getUnitSystem’.  It is the caller’s responsibility to request
a unit system that is compatible with the actual data
represented by ‘grdecl’.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>exclude</strong> – A cell array of keywords to exclude.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – Input data structure whos fields have values in consistent
units of measurements (e.g., permeability measured in m²,
lengths/depths measured in meters &amp;c).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, <a class="reference internal" href="#core.utils.units.getUnitSystem" title="core.utils.units.getUnitSystem"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getUnitSystem</span></code></a>, <a class="reference internal" href="#core.utils.units.convertFrom" title="core.utils.units.convertFrom"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertFrom</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.readCache">
<span class="sig-name descname"><span class="pre">readCache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.readCache" title="Permalink to this definition"></a></dt>
<dd><p>Read cached variables associated with given file into caller’s workspace.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">success</span> <span class="p">=</span> <span class="n">readCache</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="n">success</span> <span class="p">=</span> <span class="n">readCache</span><span class="p">({</span><span class="n">variable1</span><span class="p">,</span> <span class="p">...})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file</strong> – Name (string) of file with which to associate a cache.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>success</strong> – Whether or not cache reading succeeded.  If successful,
the cached variables are loaded directly into the caller’s
workspace.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.writeCache" title="core.utils.inout.writeCache"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">writeCache</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.readSimData">
<span class="sig-name descname"><span class="pre">readSimData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">caseName</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.readSimData" title="Permalink to this definition"></a></dt>
<dd><p>Read SAM simulator grid input files.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">readSimData</span><span class="p">(</span><span class="n">caseName</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>caseName</strong> – <p>Simulation case base name.  String assumed to contain the
(relative) base name of a simulation case.</p>
<p>The grid of a simulation case is defined by three input
files:</p>
<blockquote>
<div><p>Geometry: [caseName, ‘-geom.dat’]
Topology: [caseName, ‘-topo.dat’]
IJK-map:  [caseName, ‘-map.dat’]</p>
</div></blockquote>
<p>If the ‘-map.dat’ is not present the cell IJK map is
not read, and the G.cell.indexMap field will be empty.</p>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid structure as detailed in grid_structure.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% Assume that the input files for case &#39;example&#39; are stored in</span>
<span class="c">% directory &#39;data&#39; in the parent directory of the current working</span>
<span class="c">% directory (CD).  Assume furthermore that maximum extents of the</span>
<span class="c">% cell logical cartesian indices are 60, 220, and 85, respectively.</span>
<span class="c">% Then the case grid may be input as</span>

   <span class="n">caseName</span> <span class="p">=</span> <span class="p">[</span><span class="s">&#39;..&#39;</span><span class="p">,</span> <span class="nb">filesep</span><span class="p">,</span> <span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="nb">filesep</span><span class="p">,</span> <span class="s">&#39;example&#39;</span><span class="p">];</span>
   <span class="n">G</span> <span class="p">=</span> <span class="n">readSimData</span><span class="p">(</span><span class="n">caseName</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.cartGrid" title="core.gridprocessing.cartGrid"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartGrid</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">filesep</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">fopen</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">fscanf</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">textscan</span></code>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.readSimRock">
<span class="sig-name descname"><span class="pre">readSimRock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">casename</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.readSimRock" title="Permalink to this definition"></a></dt>
<dd><p>Read SAM simulator ROCK input files.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">rock</span> <span class="p">=</span> <span class="n">readSimRock</span><span class="p">(</span><span class="n">casename</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>casename</strong> – <p>Simulation case base name.  String assumed to contain the
(relative) base name of a simulation case.</p>
<p>The rock parameters of a simulation case is defined by two
input files:</p>
<blockquote>
<div><p>Permeability: [caseName, ‘-perm.dat’]
Porosity:     [caseName, ‘-poro.dat’]</p>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>rock</strong> – MRST rock structure.  Permeabilities measured in units of m^2
(standard SI units).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.readSimData" title="core.utils.inout.readSimData"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readSimData</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.writeCache">
<span class="sig-name descname"><span class="pre">writeCache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.writeCache" title="Permalink to this definition"></a></dt>
<dd><p>Write callers workspace to matfile in directory ./.cache/</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">writeCache</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="n">writeCache</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;var1&#39;</span><span class="p">,</span> <span class="s">&#39;var2&#39;</span><span class="p">,</span> <span class="p">...})</span>
<span class="n">writeCache</span><span class="p">({</span><span class="n">arg1</span><span class="p">,</span> <span class="p">...},</span> <span class="p">{</span><span class="s">&#39;var1&#39;</span><span class="p">,</span> <span class="s">&#39;var2&#39;</span><span class="p">,</span> <span class="p">...})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>workspace.</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">All</span> <span class="pre">variables</span> <span class="pre">in</span> <span class="pre">callers</span></code></span>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>none</strong></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.readCache" title="core.utils.inout.readCache"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readCache</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.writeGRDECL">
<span class="sig-name descname"><span class="pre">writeGRDECL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">filename</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.writeGRDECL" title="Permalink to this definition"></a></dt>
<dd><p>Write a GRDECL structure out to permanent file on disk.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">writeGRDECL</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grdecl</strong> – A corner-point GRDECL structure which may be passed to
function ‘processGRDECL’ in order to construct a grid
structure.</p></li>
<li><p><strong>file</strong> – Name of output file.  String.  This name is passed directly to
function ‘fopen’ using mode ‘wt’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Nothing.</strong></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fopen</span></code>, <a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.writeSimData">
<span class="sig-name descname"><span class="pre">writeSimData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.writeSimData" title="Permalink to this definition"></a></dt>
<dd><p>Write SAM simulator grid input files.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">writeSimData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">caseName</span><span class="p">)</span>
<span class="n">writeSimData</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">caseName</span><span class="p">,</span> <span class="s">&#39;src&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="s">&#39;rock&#39;</span><span class="p">,</span> <span class="n">rock</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid structure as detailed in grid_structure</p></li>
<li><p><strong>caseName</strong> – <p>Simulation case base name.  String assumed to contain a
(relative) base name.</p>
<dl class="simple">
<dt>files:</dt><dd><p>Geometry: [caseName, ‘-geom.dat’]
Topology: [caseName, ‘-topo.dat’]
%IJK-map:  [caseName, ‘-map.dat’]</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Nothing</strong></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fopen</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">fprintf</span></code>.</p>
</div>
</dd></dl>

<span class="target" id="module-core.utils.inout.eclipse.deckinput_simple"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.inout.eclipse.deckinput_simple.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.inout.eclipse.deckinput_simple.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>DECKINPUT-SIMPLE</dt><dd><p>Simplified input of grid-related data keywords in ECLIPSE format</p>
</dd>
<dt>Files</dt><dd><p>applyOperatorSimple - Apply ECLIPSE/FrontSim operator to input array.
cutGrdecl           - Extract logically Cartesian subset of a corner-point description
readDefaultedKW     - Read data, possibly containing default designators, for a single keyword.
readDefaultedRecord - Read data, possibly containing default designators, for a single record.
readGRDECL          - Read subset of ECLIPSE GRID file</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.eclipse.deckinput_simple.applyOperatorSimple">
<span class="sig-name descname"><span class="pre">applyOperatorSimple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">sect</span></em>, <em class="sig-param"><span class="pre">fid</span></em>, <em class="sig-param"><span class="pre">cartDims</span></em>, <em class="sig-param"><span class="pre">box</span></em>, <em class="sig-param"><span class="pre">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.eclipse.deckinput_simple.applyOperatorSimple" title="Permalink to this definition"></a></dt>
<dd><p>Apply ECLIPSE/FrontSim operator to input array.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">sect</span> <span class="p">=</span> <span class="n">applyOperatorSimple</span><span class="p">(</span><span class="n">sect</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">cartDims</span><span class="p">,</span> <span class="nb">box</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sect</strong> – Structure array representing the current deck section.</p></li>
<li><p><strong>fid</strong> – Valid file identifier (as obtained using FOPEN) to file
containing array operator description.  FTELL(fid) is assumed to
be at the start of the description (i.e., after the keyword
which prompted the reading of this table).</p></li>
<li><p><strong>cartDims</strong> – Cartesian grid dimensions.  A three element vector of integers
specifying the number of cells in the ‘X’, ‘Y’, and ‘Z’
directions, respectively.  Typically corresponds to the ‘DIMENS’
keyword of the input deck.</p></li>
<li><p><strong>box</strong> – Current input box.  Presently assumed to equal ‘cartDims’.</p></li>
<li><p><strong>kw</strong> – Operator keyword.  Must be one of
ADD      – Add constant value to existing array.
COPY     – Copy values from existing array to other array.
EQUALS   – Assign constant value to array.
MAXVALUE – Array elements must not exceed specific value.
MINVALUE – Array elements must not be less than given value.
MULTIPLY – Multiply existing array by constant value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sect</strong> – Updated deck section structure array.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="deckformat.html#deckformat.deckinput.readGRID" title="deckformat.deckinput.readGRID"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRID</span></code></a>, <a class="reference internal" href="deckformat.html#deckformat.deckinput.readEDIT" title="deckformat.deckinput.readEDIT"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readEDIT</span></code></a>, <a class="reference internal" href="deckformat.html#deckformat.deckinput.readPROPS" title="deckformat.deckinput.readPROPS"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readPROPS</span></code></a>, <a class="reference internal" href="deckformat.html#deckformat.deckinput.readREGIONS" title="deckformat.deckinput.readREGIONS"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readREGIONS</span></code></a>, <a class="reference internal" href="deckformat.html#deckformat.deckinput.readSOLUTION" title="deckformat.deckinput.readSOLUTION"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readSOLUTION</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.eclipse.deckinput_simple.cutGrdecl">
<span class="sig-name descname"><span class="pre">cutGrdecl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">grdecl</span></em>, <em class="sig-param"><span class="pre">ind</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.eclipse.deckinput_simple.cutGrdecl" title="Permalink to this definition"></a></dt>
<dd><p>Extract logically Cartesian subset of a corner-point description</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span> <span class="p">=</span> <span class="n">cutGrdecl</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
<span class="n">grdecl</span> <span class="p">=</span> <span class="n">cutGrdecl</span><span class="p">(</span><span class="n">grdecl</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grdecl</strong> – Corner-point description as defined by, e.g., function
‘readGRDECL’.</p></li>
<li><p><strong>ind</strong> – Upper and lower bounds, represented as a 3-by-2 integer array
with the first column being lower bounds and the second
column being upper bounds, on the logically Cartesian subset.
Interpreted in tensor product reference of uncompressed cells.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>OPTIONAL ARGUMENTS:</dt><dd><dl class="simple">
<dt>‘lefthanded_numbering’ - Whether or not the corner-point description</dt><dd><p>assumes a left-handed coordinate system.
Default value: lefthanded_numbering = false
(assume right-handed coordinate system).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>grdecl</strong> – Corner-point description corresponding to the uncompressed
subset of cell indices represented by ‘ind’.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, <a class="reference internal" href="#core.gridprocessing.testgrids.simpleGrdecl" title="core.gridprocessing.testgrids.simpleGrdecl"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">simpleGrdecl</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.eclipse.deckinput_simple.readDefaultedKW">
<span class="sig-name descname"><span class="pre">readDefaultedKW</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fid</span></em>, <em class="sig-param"><span class="pre">template</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.eclipse.deckinput_simple.readDefaultedKW" title="Permalink to this definition"></a></dt>
<dd><p>Read data, possibly containing default designators, for a single keyword.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="p">=</span> <span class="n">readDefaultedKW</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
<span class="n">data</span> <span class="p">=</span> <span class="n">readDefaultedKW</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fid</strong> – Valid file identifier as obtained from FOPEN.</p></li>
<li><p><strong>template</strong> – <p>An n-element CELL array constituting a template for the next
record.  Assumed to contain ‘n’ copies of a default value.
The typical default is the string ‘NaN’, but any value may
be used as ‘readDefaultedRecord’ does not inspect this value
in any way.</p>
<p>To conveniently generate an n-element CELL array, each
element of which contains the string ‘NaN’, issue a
statement of the form:</p>
<blockquote>
<div><p>template(1 : n) = { ‘NaN’ }</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>‘NRec’</strong> – Maximum number of records to input.  Integer.
Default value: Inf whence input will terminate upon detecting
an empty input record (usually consisting only of a slash
character).</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>data</strong> – Keyword data.  An m-by-n CELL array, the rows of which
corresponds to the individual records while the columns
represent the individual fields.  Default field values are
derived from the input ‘template’.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is the caller’s responsibility to supply default values in the input
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">template</span></code> which can be reliably distinguished from all (expected) data
for any given keyword.</p>
<p>Data reading terminates when the input reader detects an empty record.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readDefaultedRecord" title="core.utils.inout.eclipse.deckinput_simple.readDefaultedRecord"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readDefaultedRecord</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.eclipse.deckinput_simple.readDefaultedRecord">
<span class="sig-name descname"><span class="pre">readDefaultedRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fid</span></em>, <em class="sig-param"><span class="pre">rec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.eclipse.deckinput_simple.readDefaultedRecord" title="Permalink to this definition"></a></dt>
<dd><p>Read data, possibly containing default designators, for a single record.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">rec</span> <span class="p">=</span> <span class="n">readDefaultedRecord</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Reads a single record, containing a specific number of fields, whilst
replacing input default value designators of the form ‘n*’ (where ‘n’
is an integer) with ‘n’ copies of a user-supplied default value.</p>
<p>Function ‘readDefaultedRecord’ supports early record termination (i.e.,
the terminator character ‘/’ occurring before all fields have been
input) in which case any trailing fields will be assigned the default
value supplied by the caller.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fid</strong> – Valid file identifier as obtained from FOPEN.</p></li>
<li><p><strong>template</strong> – <p>An n-element CELL array constituting a template for the next
record.  Assumed to contain ‘n’ copies of a default value.
The typical default is the string ‘NaN’, but any value may
be used as ‘readDefaultedRecord’ does not inspect this value
in any way.</p>
<p>To conveniently generate an n-element CELL array, each
element of which contains the string ‘NaN’, issue a
statement of the form:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="p">(</span><span class="mi">1</span> <span class="p">:</span> <span class="n">n</span><span class="p">)</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&#39;NaN&#39;</span> <span class="p">}</span>
</pre></div>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>rec</strong> – Fully, or partially, filled ‘template’ CELL array.  Any
non-defaulted input data will be entered, in <em>STRING</em> form, into
the corresponding ‘rec’ element whilst leaving defaulted data in
its input ‘template’ form.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is the caller’s responsibility to supply default values in the input
‘template’ which can be reliably distinguished from all (expected) data
for any given keyword record.  Moreover, an all-default return value
(i.e., rec = template) typically constitutes the end of the keyword
data.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readDefaultedKW" title="core.utils.inout.eclipse.deckinput_simple.readDefaultedKW"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readDefaultedKW</span></code></a>, <a class="reference internal" href="deckformat.html#deckformat.deckinput.readWellKW" title="deckformat.deckinput.readWellKW"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readWellKW</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.inout.eclipse.deckinput_simple.readGRDECL">
<span class="sig-name descname"><span class="pre">readGRDECL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fn</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="Permalink to this definition"></a></dt>
<dd><p>Read subset of ECLIPSE GRID file</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span>         <span class="p">=</span> <span class="n">readGRDECL</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="n">grdecl</span>         <span class="p">=</span> <span class="n">readGRDECL</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">[</span><span class="n">grdecl</span><span class="p">,</span><span class="n">unrec</span><span class="p">]</span> <span class="p">=</span> <span class="n">readGRDECL</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fn</strong> – String holding name of (readable) GRDECL specification.
Note: The GRDECL specification is assumed to be a physical
(seekable) file on disk, not to be read in through (e.g.) a
POSIX pipe.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>‘verbose’</strong> – Emit messages to screen while processing.
Default value: FALSE.</p></li>
<li><p><strong>‘keywords’</strong> – Cell array of strings that should be recognized
outside the predefined set of keywords. NB! Are
interpreted as one value per cell. Default value: {}</p></li>
<li><p><strong>‘missing_include</strong> – Callback function through which to handle missing
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">INCLUDE</span></code> files.  Must support the syntax</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">missing_include</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="s">&#39;%s&#39;</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p>with ‘id’ being a message ID and ‘msg’ being a
string (diagnostic message).</p>
<p>Default value: missing_include = &#64;error (end input
reading with an error/failure if we encounter a
missing <code class="xref mat mat-func docutils literal notranslate"><span class="pre">INCLUDE</span></code> file).</p>
<p>Other possible values are &#64;warning (report warning),
&#64;(varargin) [] (ignore everything) and similar.</p>
</li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul>
<li><p><strong>grdecl</strong> – Output structure containing the known, though mostly
unprocessed, fields of the GRDECL specification, i.e., the
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">GRID</span></code> section of an ECLIPSE input deck.</p>
<p>With the exception of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">SPECGRID</span></code> whose first three arguments
(grid cell dimensions NX, NY, NZ) are stored in <code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl</span></code>
structure field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">cartDims</span></code>, all currently recognized keywords
are stored in equally named <code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl</span></code> structure fields.
Specifically, GRDECL keyword <code class="xref mat mat-func docutils literal notranslate"><span class="pre">COORD</span></code> is stored <code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl</span></code>
structure field <code class="xref mat mat-func docutils literal notranslate"><span class="pre">COORD</span></code> and so forth.</p>
<p>The pillar description <code class="xref mat mat-func docutils literal notranslate"><span class="pre">COORD</span></code> is stored in a 6*nPillar
array (number of pillars, nPillar == (NX+1)*(NY+1)) of
bottom/top coordinate pairs.  Specifically,</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">grdecl</span><span class="p">.</span><span class="n">COORD</span><span class="p">((</span><span class="nb">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">))</span> <span class="o">--</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span><span class="o">-</span><span class="n">coordinates</span> <span class="n">of</span>
                               <span class="n">pillar</span> <span class="s">&#39;i&#39;</span> <span class="n">top</span> <span class="n">point</span><span class="p">.</span>
<span class="n">grdecl</span><span class="p">.</span><span class="n">COORD</span><span class="p">((</span><span class="nb">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span><span class="o">+</span><span class="p">(</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">))</span> <span class="o">--</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span><span class="o">-</span><span class="n">coordinates</span> <span class="n">of</span>
                               <span class="n">pillar</span> <span class="s">&#39;i&#39;</span> <span class="n">bottom</span> <span class="n">point</span><span class="p">.</span>
</pre></div>
</div>
<p>The currently recognized keywords are:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="s">&#39;ACTNUM&#39;</span><span class="p">,</span> <span class="s">&#39;COORD&#39;</span><span class="p">,</span> <span class="s">&#39;DXV&#39;</span><span class="p">,</span> <span class="s">&#39;DYV&#39;</span><span class="p">,</span> <span class="s">&#39;DZV&#39;</span><span class="p">,</span> <span class="s">&#39;DEPTHZ&#39;</span><span class="p">,</span>
<span class="s">&#39;DIMENS&#39;</span><span class="p">,</span> <span class="s">&#39;INCLUDE&#39;</span><span class="p">,</span> <span class="s">&#39;MULTX&#39;</span><span class="p">,</span> <span class="s">&#39;MULTX-&#39;</span><span class="p">,</span> <span class="s">&#39;MULTY&#39;</span><span class="p">,</span> <span class="s">&#39;MULTY-&#39;</span><span class="p">,</span>
<span class="s">&#39;MULTZ&#39;</span><span class="p">,</span> <span class="s">&#39;MULTZ-&#39;</span><span class="p">,</span> <span class="s">&#39;NOGRAV&#39;</span><span class="p">,</span> <span class="s">&#39;NTG&#39;</span><span class="p">,</span> <span class="s">&#39;PERMX&#39;</span><span class="p">,</span> <span class="s">&#39;PERMXY&#39;</span><span class="p">,</span>
<span class="s">&#39;PERMXZ&#39;</span><span class="p">,</span> <span class="s">&#39;PERMY&#39;</span><span class="p">,</span> <span class="s">&#39;PERMYX&#39;</span><span class="p">,</span> <span class="s">&#39;PERMYZ&#39;</span><span class="p">,</span> <span class="s">&#39;PERMZ&#39;</span><span class="p">,</span> <span class="s">&#39;PERMZX&#39;</span><span class="p">,</span>
<span class="s">&#39;PERMZY&#39;</span><span class="p">,</span> <span class="s">&#39;PORO&#39;</span><span class="p">,</span> <span class="s">&#39;ROCKTYPE&#39;</span><span class="p">,</span> <span class="s">&#39;SATNUM&#39;</span><span class="p">,</span> <span class="s">&#39;ZCORN&#39;</span>
</pre></div>
</div>
</li>
<li><p><strong>unrec</strong> – Cell array with unrecognized keywords.  For convenience and
greater transparency, this data is also provided as the field
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">UnhandledKeywords</span></code> of <code class="xref mat mat-func docutils literal notranslate"><span class="pre">grdecl</span></code> itself.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.gridprocessing.processGRDECL" title="core.gridprocessing.processGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">processGRDECL</span></code></a>.</p>
</div>
</dd></dl>

<span class="target" id="module-core.utils.paper_manager.papers"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.paper_manager.papers.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.paper_manager.papers.Contents" title="Permalink to this definition"></a></dt>
<dd><p>PAPERS</p>
<dl class="simple">
<dt>Files</dt><dd><p>paper_ad_blackoilminstate       -
paper_adjoint_msmfem            -
paper_adjoint_nonlincons        -
paper_agglom_flow               -
paper_agglom_nuc                -
paper_co2_calibrateSleipner     -
paper_co2_fieldCase             -
paper_co2_optimalRatesPlacement -
paper_co2_parameterUncertainty  -
paper_co2_ranking               -
paper_co2_sharpInterface        -
paper_co2_spillPoint            -
paper_co2_toolchain             -
paper_co2_trapCap               -
paper_co2_VEmodel               -
paper_co2_workflow              -
paper_diagnostics_spej          -
paper_eor_fibopolymer_ecmorxv   -
paper_mim_flt                   -
paper_MRST_book                 -
paper_MRST_comg                 -
paper_MRST_ecmorxii             -
paper_MRSTAD                    -
paper_ms_fmsrsb                 -
paper_ms_msfvm                  -
paper_ms_msrsb                  -
paper_ms_msrsb_bo               -
paper_ms_msrsb_polymer          -
paper_ms_mstpfa                 -
paper_msmfe_cmplx               -
paper_msmfe_comp                -
paper_msmfe_dnr                 -
paper_msmfe_hier                -
paper_msmfe_slb                 -
paper_msmfe_valid               -
paper_msmfem                    -
paper_optim_upsc                -</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-core.utils.paper_manager"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.paper_manager.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.paper_manager.Contents" title="Permalink to this definition"></a></dt>
<dd><p>PAPER_MANAGER</p>
<dl class="simple">
<dt>Files</dt><dd><p>createPaperStruct  - Create a structure containing information about a document that uses MRST
getAvailablePapers - Get structures for all papers known to MRST
mrstReferencesGUI  - Draw a panel for exploring relevant papers for MRST</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.paper_manager.createPaperStruct">
<span class="sig-name descname"><span class="pre">createPaperStruct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em>, <em class="sig-param"><span class="pre">title</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.paper_manager.createPaperStruct" title="Permalink to this definition"></a></dt>
<dd><p>Create a structure containing information about a document that uses MRST</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">paper</span> <span class="p">=</span> <span class="n">createPaperStruct</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nb">title</span><span class="p">)</span>
<span class="n">paper</span> <span class="p">=</span> <span class="n">createPaperStruct</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="nb">title</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong> – A short string ID for the paper that can be used to
programmatically refer to the same id over multiple revisions.</p></li>
<li><p><strong>title</strong> – A string containing the title of the paper.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>‘authors’</strong> – A string containing the names of the authors.</p></li>
<li><p><strong>‘published’</strong> – Publication avenue (name of conference, journal name with
issue number, thesis, …)</p></li>
<li><p><strong>‘url’</strong> – URL to the official site of a published paper. Typically,
this is a webpage on the publisher’s website where a the
paper can be viewed.</p></li>
<li><p><strong>‘fileurl’</strong> – URL to a direct download of a preprint of the paper, if
available from the copyright holders.</p></li>
<li><p><strong>‘year’</strong> – Double indicating the publication year.</p></li>
<li><p><strong>‘modules’</strong> – Cell array of the names modules where the paper is
relevant as documentation or background information.</p></li>
<li><p><strong>‘doi’</strong> – Digital object identifier for the publication.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>paper</strong> – Structure with defaulted values for keywords not specified.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.paper_manager.getAvailablePapers" title="core.utils.paper_manager.getAvailablePapers"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getAvailablePapers</span></code></a>, <a class="reference internal" href="#core.utils.paper_manager.mrstReferencesGUI" title="core.utils.paper_manager.mrstReferencesGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstReferencesGUI</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.paper_manager.getAvailablePapers">
<span class="sig-name descname"><span class="pre">getAvailablePapers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.paper_manager.getAvailablePapers" title="Permalink to this definition"></a></dt>
<dd><p>Get structures for all papers known to MRST</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">papers</span> <span class="p">=</span> <span class="n">getAvailablePapers</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Get structures (as defined by createPaperStruct) for all known papers.
Papers are known to MRST if they are found as functions named ‘paper_*’
in the ‘papers’ subdirectory of the directory hosting function
getAvailablePapers.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>papers</strong> – List of all papers known to MRST, as an array of structures.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.paper_manager.createPaperStruct" title="core.utils.paper_manager.createPaperStruct"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">createPaperStruct</span></code></a>, <a class="reference internal" href="#core.utils.explore.mrstExploreModules" title="core.utils.explore.mrstExploreModules"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstExploreModules</span></code></a>, <a class="reference internal" href="#core.utils.paper_manager.mrstReferencesGUI" title="core.utils.paper_manager.mrstReferencesGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstReferencesGUI</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.paper_manager.mrstReferencesGUI">
<span class="sig-name descname"><span class="pre">mrstReferencesGUI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">modules</span></em>, <em class="sig-param"><span class="pre">parent</span></em>, <em class="sig-param"><span class="pre">pos</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.paper_manager.mrstReferencesGUI" title="Permalink to this definition"></a></dt>
<dd><p>Draw a panel for exploring relevant papers for MRST</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mrstReferencesGUI</span><span class="p">();</span>
<span class="c">% Embed in an existing user interface</span>
<span class="n">mrstReferencesGUI</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="mi">25</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Create a panel for exploring publications that use MRST.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>modules</strong> – A cell array containing a list of modules for which
publications are to be requested. If “modules” is empty, or
not given, it will default to all known publications.</p></li>
<li><p><strong>parent</strong> – Handle to a UI component where reference GUI should be added.
If not given, this function will default to a brand new
figure.</p></li>
<li><p><strong>pos</strong> – Position argument for embedding in parent. Defaults to
[0, 0, 1, 1], filling the entire surface of the parent.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>panel</strong> – Handle to the panel that has been added to the workspace.</p></li>
<li><p><strong>parent</strong> – Handle to the parent, or the figure that was created if no
parent was given.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that all arguments are optional. Passing no input arguments</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.explore.mrstExploreModules" title="core.utils.explore.mrstExploreModules"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstExploreModules</span></code></a>, <a class="reference internal" href="#core.utils.paper_manager.getAvailablePapers" title="core.utils.paper_manager.getAvailablePapers"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getAvailablePapers</span></code></a></p>
</div>
</dd></dl>

<span class="target" id="module-core.utils.equil"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.equil.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.equil.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>EQUIL</dt><dd><p>Simplified implementation of hydrostatic equilibrium for model initialisation</p>
</dd>
<dt>Files</dt><dd><p>simpleEquilibrium      - Routine for creating simple initial equilibriums
test_simpleEquilibrium - Small test for the simple equilibrium routine</p>
</dd>
</dl>
</dd></dl>

<dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.equil.test_simpleEquilibrium">
<span class="sig-name descname"><span class="pre">test_simpleEquilibrium</span></span><a class="headerlink" href="#core.utils.equil.test_simpleEquilibrium" title="Permalink to this definition"></a></dt>
<dd><p>Small test for the simple equilibrium routine</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.equil.simpleEquilibrium">
<span class="sig-name descname"><span class="pre">simpleEquilibrium</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">contacts</span></em>, <em class="sig-param"><span class="pre">vector</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.equil.simpleEquilibrium" title="Permalink to this definition"></a></dt>
<dd><p>Routine for creating simple initial equilibriums</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="p">=</span> <span class="n">simpleEquilibrium</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">contacts</span><span class="p">)</span>
<span class="n">s</span> <span class="p">=</span> <span class="n">simpleEquilibrium</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">contacts</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This routine generates cell-wise values that are distributed according
to a list of different contacts. The most common usage of this routine
is to create initial saturations where the problem is at hydrostatic
equilibrium, i.e. the initial phases are distributed according to
density.</p>
<p>As the underlying algorithm makes certain simplifications without
taking fluid physics into account, it should be used with care and only
for problems with relatively structured grids and no capillary
pressure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – The grid structure for which the properties are to be
calculated. Note that we require the grid to have geometry
information computed by a call to computeGeometry before usage.</p></li>
<li><p><strong>contacts</strong> – A list of up to N contacts. Each contact represents the
interface between two properties and N contacts must be given
for N + 1 properties. Each contact is given as the distance
along the vector (third argument) where the contact occurs. If
no third argument is given, the contacts will be assumed to be
along the z-coordinate, which is also the default gravity
direction in MRST.</p></li>
<li><p><strong>vector</strong> – <p>Optional argument. Two modes are supported:
If given as a vector, this vector will be the direction that
the contacts are parametrized along. For instance, the default
[0, 0, 1] interprets the contacts along the z-direction of the
grid. If [1, 0, 1] is given, contacts are interpreted along
the 45 degree angle between the x and z axes.</p>
<p>If a single value is given, it is interpreted as a index into
the cell centroids, i.e. vector = 2 will use the second column
of the cell coordinates.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong> – A G.cell.num x (N + 1) matrix of properties, distributed
according to the contacts. It will not necessarily be
guaranteed to be the true equilibrium of the grid is not
Cartesian or the fluids physics include capillary forces.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">cartGrid</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">computeGeometry</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>

<span class="c">% First contact at .37, second at .8 for a total of three phases present</span>
<span class="n">contacts</span> <span class="p">=</span> <span class="p">[.</span><span class="mi">37</span><span class="p">,</span> <span class="p">.</span><span class="mi">8</span><span class="p">];</span>

<span class="c">% Compute equilibrium saturations</span>
<span class="n">s</span> <span class="p">=</span> <span class="n">simpleEquilibrium</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">contacts</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">initEclipseState</span></code>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">test_simpleEquilibrium</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-explorer">
<h3>Module explorer<a class="headerlink" href="#module-explorer" title="Permalink to this headline"></a></h3>
<p>The modules in MRST can be explored interactively, making it easy to access
examples and relevant documentation.</p>
<span class="target" id="module-core.utils.explore"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.explore.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.explore.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>EXPLORE</dt><dd><p>Interactive interface for exploring MRST examples and research papers</p>
</dd>
<dt>Files</dt><dd><p>mrstExploreModules - Interactively explore MRST modules and corresponding examples
mrstSplitText      - Split example introduction (help text) into header and paragraphs
normaliseTextBox   - Remove explicit line breaks from string for presentation in GUI text box</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.explore.mrstExploreModules">
<span class="sig-name descname"><span class="pre">mrstExploreModules</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.explore.mrstExploreModules" title="Permalink to this definition"></a></dt>
<dd><p>Interactively explore MRST modules and corresponding examples</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mrstExploreModules</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Launches an interactive graphical user interface for examining MRST
modules, their examples and relevant papers.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Figure handle for the window (if requested).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.paper_manager.mrstReferencesGUI" title="core.utils.paper_manager.mrstReferencesGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstReferencesGUI</span></code></a>, <a class="reference internal" href="#core.utils.moduleGUI" title="core.utils.moduleGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">moduleGUI</span></code></a>, <a class="reference internal" href="#core.utils.mrstModule" title="core.utils.mrstModule"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstModule</span></code></a>, <a class="reference internal" href="#core.utils.mrstExamples" title="core.utils.mrstExamples"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstExamples</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.explore.mrstSplitText">
<span class="sig-name descname"><span class="pre">mrstSplitText</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">intro</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.explore.mrstSplitText" title="Permalink to this definition"></a></dt>
<dd><p>Split example introduction (help text) into header and paragraphs</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="p">=</span> <span class="n">mrstSplitText</span><span class="p">(</span><span class="n">intro</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>intro</strong> – <p>Introductory text of example, typically obtained through the
expression</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="s">&#39;ExampleName&#39;</span><span class="p">)</span>
</pre></div>
</div>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>h</strong> – Cell array of strings.  The H1 line is the first element and the
remaining elements represent one paragraph each of the input text,
in order of appearance.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is mainly intended to support the MRST module explorer
GUI, <a class="reference internal" href="#core.utils.explore.mrstExploreModules" title="core.utils.explore.mrstExploreModules"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstExploreModules</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">help</span></code>, <a class="reference internal" href="#core.utils.explore.mrstExploreModules" title="core.utils.explore.mrstExploreModules"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstExploreModules</span></code></a>, <a class="reference internal" href="#core.utils.explore.normaliseTextBox" title="core.utils.explore.normaliseTextBox"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">normaliseTextBox</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.explore.normaliseTextBox">
<span class="sig-name descname"><span class="pre">normaliseTextBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.explore.normaliseTextBox" title="Permalink to this definition"></a></dt>
<dd><p>Remove explicit line breaks from string for presentation in GUI text box</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="p">=</span> <span class="n">normaliseTextBox</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>s</strong> – String or cell array of strings, possibly containing explicit line
breaks and/or words separated by multiple spaces.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong> – String or cell array of strings (depending on input) without
explicit line breaks and with words separated by single space only.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="dataset-manager">
<h3>Dataset manager<a class="headerlink" href="#dataset-manager" title="Permalink to this headline"></a></h3>
<p>A large number of publicly available test datasets are available in MRST. The
dataset manager makes it straightforward to download and work with test cases,
provided by SINTEF and other institutions.</p>
<span class="target" id="module-core.utils.dataset_manager"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.dataset_manager.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>DATASET_MANAGER</dt><dd><p>Support routines for managing collection of external datasets</p>
</dd>
<dt>Files</dt><dd><p>downloadDataset      - Download a dataset given by name, subject to availability
getAvailableDatasets - Get a list of structures indicating possible and present datasets in MRST
getDatasetPath       - Get the path of a dataset (optionally: try to download it if missing)
modelDownloadExample - Listing data directory</p>
</dd>
</dl>
</dd></dl>

<dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.modelDownloadExample">
<span class="sig-name descname"><span class="pre">modelDownloadExample</span></span><a class="headerlink" href="#core.utils.dataset_manager.modelDownloadExample" title="Permalink to this definition"></a></dt>
<dd><p>Listing data directory</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.downloadDataset">
<span class="sig-name descname"><span class="pre">downloadDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">askFirst</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dataset_manager.downloadDataset" title="Permalink to this definition"></a></dt>
<dd><p>Download a dataset given by name, subject to availability</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">pth</span><span class="p">,</span> <span class="n">ok</span><span class="p">]</span> <span class="p">=</span> <span class="n">downloadDataset</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="p">[</span><span class="n">pth</span><span class="p">,</span> <span class="n">ok</span><span class="p">]</span> <span class="p">=</span> <span class="n">downloadDataset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">askFirst</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>Download a dataset if available.  If the dataset is not publicly
available due to technical or license related reasons, instructions
for manual download (if any) along with the dataset website will be
printed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – Name (string) of the dataset to download.  Must be one of
the names returned by function <a class="reference internal" href="#core.utils.dataset_manager.getAvailableDatasets" title="core.utils.dataset_manager.getAvailableDatasets"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getAvailableDatasets</span></code></a>.</p></li>
<li><p><strong>askFirst</strong> – Whether or not to ask for permission in the command window
before downloading any files.  Reports the size of the
dataset for context.  LOGICAL.  If unspecified, treated as
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">true</span></code> (<em>do</em> ask for permission before downloading files).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>pth</strong> – Filesystem path where dataset was or should be placed.</p></li>
<li><p><strong>ok</strong> – Logical status code indicating whether or not the download
process completed successfully.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Function <a class="reference internal" href="#core.utils.dataset_manager.downloadDataset" title="core.utils.dataset_manager.downloadDataset"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">downloadDataset</span></code></a> is a fairly low-level facility and end-users
should rarely call this function directly.  We recommend higher-level
interfaces like function <a class="reference internal" href="#core.utils.dataset_manager.gui.mrstDatasetGUI" title="core.utils.dataset_manager.gui.mrstDatasetGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDatasetGUI</span></code></a> for interactive work.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.dataset_manager.getAvailableDatasets" title="core.utils.dataset_manager.getAvailableDatasets"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getAvailableDatasets</span></code></a>, <a class="reference internal" href="#core.utils.dataset_manager.gui.mrstDatasetGUI" title="core.utils.dataset_manager.gui.mrstDatasetGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDatasetGUI</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.getAvailableDatasets">
<span class="sig-name descname"><span class="pre">getAvailableDatasets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dataset_manager.getAvailableDatasets" title="Permalink to this definition"></a></dt>
<dd><p>Get a list of structures indicating possible and present datasets in MRST</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="nb">info</span><span class="p">,</span> <span class="n">present</span><span class="p">]</span> <span class="p">=</span> <span class="n">getAvailableDatasets</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function collects descriptive information about all datasets known
to MRST.  One structure contains useful information about a particular
dataset, such as its name, type of model (e.g., characteristics of the
model geometry, the model’s petrophysical properties, active fluid
phases, common simulation scenarios), online location (URL) from which
to download the data, any MRST examples using that dataset and so on.</p>
<p>Function <a class="reference internal" href="#core.utils.dataset_manager.getAvailableDatasets" title="core.utils.dataset_manager.getAvailableDatasets"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getAvailableDatasets</span></code></a> relies on dedicated helper functions
named <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dataset_*</span></code> (lower-case) located in the sudirectory <code class="xref mat mat-func docutils literal notranslate"><span class="pre">datasets</span></code> of
this function’s location.  Each helper function produces a single
collection of metadata about a particular dataset and determines if the
associated dataset is already present (i.e., downloaded).</p>
<p>Creating a new dataset consequently means implementing a new
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">dataset_*</span></code> function.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul>
<li><p><strong>info</strong> – An array of structures in which each array element provides
information about a separate dataset.  See datasetInfoStruct
for possible fields, along with their meanings.</p></li>
<li><p><strong>present</strong> – Logical array of the same size as <code class="xref mat mat-func docutils literal notranslate"><span class="pre">info</span></code>.  If <code class="xref mat mat-func docutils literal notranslate"><span class="pre">present(i)</span></code> is
true, the dataset named <code class="xref mat mat-func docutils literal notranslate"><span class="pre">info(i).name</span></code> is already downloaded
and exists in the directory returned by function</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">mrstDataDirectory</span>
</pre></div>
</div>
<p>This dataset is therefore directly available for use by MRST.
Otherwise, the dataset may be retrieved interactively through
a graphical user interface (function <a class="reference internal" href="#core.utils.dataset_manager.gui.mrstDatasetGUI" title="core.utils.dataset_manager.gui.mrstDatasetGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDatasetGUI</span></code></a>) or
programmatically by means of function <a class="reference internal" href="#core.utils.dataset_manager.downloadDataset" title="core.utils.dataset_manager.downloadDataset"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">downloadDataset</span></code></a> or
<a class="reference internal" href="#core.utils.dataset_manager.utils.downloadAllDatasets" title="core.utils.dataset_manager.utils.downloadAllDatasets"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">downloadAllDatasets</span></code></a>.</p>
</li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.dataset_manager.gui.mrstDatasetGUI" title="core.utils.dataset_manager.gui.mrstDatasetGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDatasetGUI</span></code></a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDataDirectory</span></code>, <a class="reference internal" href="#core.utils.dataset_manager.utils.datasetInfoStruct" title="core.utils.dataset_manager.utils.datasetInfoStruct"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">datasetInfoStruct</span></code></a>, <a class="reference internal" href="#core.utils.dataset_manager.downloadDataset" title="core.utils.dataset_manager.downloadDataset"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">downloadDataset</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.getDatasetPath">
<span class="sig-name descname"><span class="pre">getDatasetPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dataset_manager.getDatasetPath" title="Permalink to this definition"></a></dt>
<dd><p>Get the path of a dataset (optionally: try to download it if missing)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">pth</span> <span class="p">=</span> <span class="n">getDatasetPath</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="n">pth</span> <span class="p">=</span> <span class="n">getDatasetPath</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – The name of the dataset. Must be known to MRST, see
<a class="reference internal" href="#core.utils.dataset_manager.getAvailableDatasets" title="core.utils.dataset_manager.getAvailableDatasets"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getAvailableDatasets</span></code></a> for details.</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>download</strong> – Boolean indicating if the functions should attempt to
download the dataset if it is missing. Default: Enabled.</p></li>
<li><p><strong>askBeforeDownload</strong> – Boolean. If the download option is enabled, setting
this to true will prompt the user before starting a
potentially large download. Default: Enabled.</p></li>
<li><p><strong>skipAvailableCheck</strong> – Boolean flag indicating whether or not to omit checking for
presence of data on disk.  This is mainly intended for the
case of needing to manually download objects into the
dataset’s containing directory through some external means.
Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">skipAvailableCheck</span> <span class="pre">=</span> <span class="pre">false</span></code> (<em>do</em> check if
the dataset is available).</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pth</strong> – Path to dataset.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this function returns, the dataset will be present at the path
given. Any other situation will result in an error being thrown.</p>
<p>Using <code class="xref mat mat-func docutils literal notranslate"><span class="pre">skipAvailableCheck</span></code> bypasses this basic safety measure of MRST’s
dataset handling.  Consequently, said option should be used only when
circumstances so dictate.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstdatasetGUI</span></code>, <a class="reference internal" href="#core.utils.dataset_manager.downloadDataset" title="core.utils.dataset_manager.downloadDataset"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">downloadDataset</span></code></a>.</p>
</div>
</dd></dl>

<span class="target" id="module-core.utils.dataset_manager.gui"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.gui.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.dataset_manager.gui.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>GUI</dt><dd><p>Interactive interface for exploring collection of datasets</p>
</dd>
<dt>Files</dt><dd><p>mrstDatasetGUI - Open dataset management user interface</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.gui.mrstDatasetGUI">
<span class="sig-name descname"><span class="pre">mrstDatasetGUI</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dataset_manager.gui.mrstDatasetGUI" title="Permalink to this definition"></a></dt>
<dd><p>Open dataset management user interface</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="p">=</span> <span class="n">mrstDatasetGUI</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>The dataset GUI is a user interface, allowing the user to see which
datasets are known to MRST, visit their webpages, download and manage
them. The function is built upon the dataset library.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to panel figure.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.dataset_manager.utils.getDatasetInfo" title="core.utils.dataset_manager.utils.getDatasetInfo"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDatasetInfo</span></code></a>, <a class="reference internal" href="#core.utils.dataset_manager.getDatasetPath" title="core.utils.dataset_manager.getDatasetPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDatasetPath</span></code></a>, <a class="reference internal" href="#core.utils.dataset_manager.utils.listDatasetExamples" title="core.utils.dataset_manager.utils.listDatasetExamples"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">listDatasetExamples</span></code></a></p>
</div>
</dd></dl>

<span class="target" id="module-core.utils.dataset_manager.utils"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.utils.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.dataset_manager.utils.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>UTILS</dt><dd><p>Supporting routines for managing collection of external datasets</p>
</dd>
<dt>Files</dt><dd><p>datasetInfoStruct           - Get a struct containing standardized information about a dataset
datasetHasCustomDownloadFcn - Predicate for whether or not a dataset provides a custom download function
datasetHasValidFileURL      - Predicate for whether or not a dataset provides a valid file URL
downloadAllDatasets         - Download all datasets known to MRST and available for direct download
getDatasetInfo              - Get info struct for a given dataset.
listDatasetExamples         - List all MRST examples using a specific dataset</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.utils.datasetHasCustomDownloadFcn">
<span class="sig-name descname"><span class="pre">datasetHasCustomDownloadFcn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">info</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dataset_manager.utils.datasetHasCustomDownloadFcn" title="Permalink to this definition"></a></dt>
<dd><p>Predicate for whether or not a dataset provides a custom download function</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">tf</span> <span class="p">=</span> <span class="n">datasetHasCustomDownloadFcn</span><span class="p">(</span><span class="nb">info</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>info</strong> – A dataset information structure as defined by function
datasetInfoStruct.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tf</strong> – Whether or not the dataset identified by ‘info’ does provide a
custom download function.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.utils.datasetHasValidFileURL">
<span class="sig-name descname"><span class="pre">datasetHasValidFileURL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">info</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dataset_manager.utils.datasetHasValidFileURL" title="Permalink to this definition"></a></dt>
<dd><p>Predicate for whether or not a dataset provides a valid file URL</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">tf</span> <span class="p">=</span> <span class="n">datasetHasValidFileURL</span><span class="p">(</span><span class="nb">info</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>info</strong> – A dataset information structure as defined by function
datasetInfoStruct.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tf</strong> – Whether or not the dataset identified by ‘info’ does provide a
valid file URL from which to download the dataset.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.utils.datasetInfoStruct">
<span class="sig-name descname"><span class="pre">datasetInfoStruct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dataset_manager.utils.datasetInfoStruct" title="Permalink to this definition"></a></dt>
<dd><p>Get a struct containing standardized information about a dataset</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="nb">info</span><span class="p">,</span> <span class="n">present</span><span class="p">]</span> <span class="p">=</span> <span class="n">datasetInfoStruct</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;myDataset&#39;</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Keyword Arguments</dt>
<dd class="field-odd"><ul>
<li><p><strong>‘name’</strong> – Name of the dataset. Any capitalization will be kept,
but MRST does not allow multiple datasets with the
same name aside from capitalization. Any whitespace
will be stripped from the name.</p></li>
<li><p><strong>‘description’</strong> – Description of the dataset.</p></li>
<li><p><strong>‘cells’</strong> – Number of cells in the dataset, if applicable.</p></li>
<li><p><strong>‘website’</strong> – Website for the dataset. Should be the home page of
the dataset, if it exists.</p></li>
<li><p><strong>‘fileurl’</strong> – URL to directly download the dataset. Supports files
in standard archive formats (.tar.gz, .tgz, .zip).</p></li>
<li><p><strong>‘filesize’</strong> – Size of files (in MegaBytes). Used to give the user a
estimate before downloading.</p></li>
<li><p><strong>‘instructions’</strong> – If fileurl is not provided, it typically means that
the dataset is not directly available. The
instructions field should tell the user how to get
the dataset in that case (or if it is not available
at all).</p></li>
<li><p><strong>‘hasGrid’</strong> – Boolean. True if the dataset includes a grid.</p></li>
<li><p><strong>‘hasRock’</strong> – Boolean. True if the dataset includes petrophysical
data for the rock.</p></li>
<li><p><strong>‘hasFluid’</strong> – Boolean. True if the dataset includes a fluid model.</p></li>
<li><p><strong>‘source’</strong> – String indicating where the dataset originated.</p></li>
<li><p><strong>‘examples’</strong> – Cell array with strings of the form
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">module:examplename</span></code>. For example, setting it to:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s">&#39;module_a:test1&#39;</span><span class="p">,</span><span class="c">...</span>
 <span class="s">&#39;module_a:test5&#39;</span><span class="p">,</span> <span class="c">...</span>
 <span class="s">&#39;module_b: myTest&#39;</span><span class="p">};</span>
</pre></div>
</div>
<p>will indicate that the examples in module_a named
test1 and test5 use the dataset and that the test
myTest in module_b also does use it.</p>
</li>
<li><p><strong>‘modelType’</strong> – The type of the model (e.g. grid only, black oil,
corner point).</p></li>
<li><p><strong>‘downloadFcn’</strong> – Custom dataset download function.  Handle to function
that takes no input parameters and returns a status
code signifying whether or not the file data was
successfully downloaded.  If specified, this value
takes precedence over the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">fileurl</span></code> parameter.</p></li>
<li><p><strong>‘note’</strong> – Additional notes concerning the dataset, e.g.
special actions to take before using the datafiles.
Character vector or cell array of character vectors
(‘cellstring’).  Default value: <code class="xref mat mat-func docutils literal notranslate"><span class="pre">note</span> <span class="pre">=</span> <span class="pre">''</span></code> (no
additional notes).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>info</strong> – Struct with info fields as listed above.</p></li>
<li><p><strong>present</strong> – Boolean indicator if the directory
<code class="xref mat mat-func docutils literal notranslate"><span class="pre">fullfile(mrstDataDirectory(),</span> <span class="pre">info.name)</span></code> exists.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.dataset_manager.gui.mrstDatasetGUI" title="core.utils.dataset_manager.gui.mrstDatasetGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDatasetGUI</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.utils.downloadAllDatasets">
<span class="sig-name descname"><span class="pre">downloadAllDatasets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">askFirst</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dataset_manager.utils.downloadAllDatasets" title="Permalink to this definition"></a></dt>
<dd><p>Download all datasets known to MRST and available for direct download</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>askFirst</strong> – (OPTIONAL) Boolean indicating if the user should be prompted
before starting the download. Default on.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Nothing. Prints output to command line.</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Avoid using this function in scripts. Rather, opt for the more
conservative <a class="reference internal" href="#core.utils.dataset_manager.downloadDataset" title="core.utils.dataset_manager.downloadDataset"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">downloadDataset</span></code></a> function to have control over which
files to download.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.dataset_manager.gui.mrstDatasetGUI" title="core.utils.dataset_manager.gui.mrstDatasetGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDatasetGUI</span></code></a>, <a class="reference internal" href="#core.utils.dataset_manager.downloadDataset" title="core.utils.dataset_manager.downloadDataset"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">downloadDataset</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.utils.getDatasetInfo">
<span class="sig-name descname"><span class="pre">getDatasetInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dataset_manager.utils.getDatasetInfo" title="Permalink to this definition"></a></dt>
<dd><p>Get info struct for a given dataset.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="nb">info</span><span class="p">,</span> <span class="n">present</span><span class="p">]</span> <span class="p">=</span> <span class="n">getDatasetInfo</span><span class="p">(</span><span class="s">&#39;datasetname&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – Dataset name. Must be known to MRST.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>info</strong> – Info struct as defined by datasetInfoStruct with containing
metadata about the dataset with the supplied name.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.dataset_manager.utils.datasetInfoStruct" title="core.utils.dataset_manager.utils.datasetInfoStruct"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">datasetInfoStruct</span></code></a>, <a class="reference internal" href="#core.utils.dataset_manager.getDatasetPath" title="core.utils.dataset_manager.getDatasetPath"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">getDatasetPath</span></code></a>, <a class="reference internal" href="#core.utils.dataset_manager.utils.listDatasetExamples" title="core.utils.dataset_manager.utils.listDatasetExamples"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">listDatasetExamples</span></code></a></p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.dataset_manager.utils.listDatasetExamples">
<span class="sig-name descname"><span class="pre">listDatasetExamples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.dataset_manager.utils.listDatasetExamples" title="Permalink to this definition"></a></dt>
<dd><p>List all MRST examples using a specific dataset</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">listDatasetExamples</span><span class="p">(</span><span class="s">&#39;mydataset&#39;</span><span class="p">);</span>
<span class="n">ex</span> <span class="p">=</span> <span class="n">listDatasetExamples</span><span class="p">(</span><span class="s">&#39;mydataset&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function has two calling syntaxes. If called without output
arguments, it will print a list of examples using a given example into
the command line, with links to the corresponding files.</p>
<p>If called with a single output argument, it will instead output the
list of examples as a variable, while not printing anything to the
command window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – Either a string containing a valid dataset name, or a info
struct for a given dataset.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>examples</strong> – (OPTIONAL) A array of structs, each representing an example
where the dataset is used. Contains fields name, path and
module.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function relies on the <code class="xref mat mat-func docutils literal notranslate"><span class="pre">dataset_*.m</span></code> functions being up to date
with the examples included in MRST. Although we strive to do so, it
may happen that examples are not listed.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.dataset_manager.gui.mrstDatasetGUI" title="core.utils.dataset_manager.gui.mrstDatasetGUI"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrstDatasetGUI</span></code></a></p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="units">
<h2>Units<a class="headerlink" href="#units" title="Permalink to this headline"></a></h2>
<p>MRST uses strict SI units internally. In order to make examples easier to read,
we have included many specific units as functions. This makes it possible to
write examples without introducing messy conversion factors.</p>
<span class="target" id="module-core.utils.units"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.units.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.units.Contents" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>UNITS</dt><dd><p>MRST’s implementation of support for different units of measurement</p>
</dd>
<dt>Files</dt><dd><p>ampere        - Electrical current of 1 ampere (in units of amps)
atm           - Compute numerical value, in units of Pascal, of one atmosphere.
barsa         - Compute numerical value, in units of Pascal, of one bar.
btu           - British termal unit
centi         - One houndreth prefix.
convertFrom   - Convert physical quantity from given unit to equivalent SI.
convertTo     - Convert physical quantity from SI to equivalent given unit.
dalton        - Mass of one kilogram, in units of kilogram.
darcy         - Compute numerical value, in units of m^2, of the Darcy constant.
day           - Give numerical value, in units of seconds, of one day.
deci          - One tenth prefix.
dyne          - Compute numerical value, in units of Newton of one dyne.
farad         - Electrical capacitance of 1 Farad (in units of Farads)
ft            - Distance of one foot (in units of meters).
gal           - Unit of gravity 1 Gal = 0.01 m/s²
gallon        - Compute numerical value, in units of m^3, of one U.S. liquid gallon.
getUnitSystem - Define unit conversion factors for input data.
giga          - One billion (milliard) prefix.
gram          - Mass of one gram, in units of kilogram.
hour          - Time span of one hour (in units of seconds).
inch          - Distance of one inch (in units of meters).
joule         - Units of energy
Kelvin        - Temperature of one Kelvin (in units Kelvin)
kilo          - One thousand prefix.
kilogram      - Mass of one kilogram, in units of kilogram.
lbf           - Force excerted by a mass of one avoirdupois pound at Tellus equator.
litre         - Numerical value of one liter, in units of m^3
mega          - One million prefix.
meter         - Distance of one meter (in units of meters).
micro         - One millionth prefix.
milli         - One thousandth prefix.
minute        - Time span of one minute (in units of seconds).
mol           - Amount of Chemical Substance of One Mole in Units of Moles
nano          - One billionth prefix.
Newton        - Force of one Newton, in units of Newton.
Pascal        - Compute numerical value, in units of Pascal, of one Pascal.
pico          - One trillionth prefix.
poise         - Compute numerical value, in units of Pa*s, of one poise (P).
pound         - Mass of one avoirdupois pound, in units of kilogram.
psia          - Compute numerical value, in units of Pascal, of one Psi.
Rankine       - Temperature of one Rankine (in units of Kelvin).
second        - Time span of one second (in units of seconds).
site          - Number of 1 site (in units of avagadros numer)
stb           - Compute numerical value, in units of m^3, of one standard barrel.
year          - Give numerical value, in units of seconds, of one year.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.Kelvin">
<span class="sig-name descname"><span class="pre">Kelvin</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.Kelvin" title="Permalink to this definition"></a></dt>
<dd><p>Temperature of one Kelvin (in units Kelvin)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="p">=</span> <span class="n">Kelvin</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>T</strong> – Temperature of one Kelvin (in units of Kelvin, == 1).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.Newton">
<span class="sig-name descname"><span class="pre">Newton</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.Newton" title="Permalink to this definition"></a></dt>
<dd><p>Force of one Newton, in units of Newton.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="p">=</span> <span class="n">Newton</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>n</strong> – Numeric value, in units of Newton, of a force of one Newton.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.Pascal">
<span class="sig-name descname"><span class="pre">Pascal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.Pascal" title="Permalink to this definition"></a></dt>
<dd><p>Compute numerical value, in units of Pascal, of one Pascal.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="p">=</span> <span class="n">Pascal</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>b</strong> – Numerical value, in units of Pascal (Pa), of a pressure of one
Pascal, == 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.Rankine">
<span class="sig-name descname"><span class="pre">Rankine</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.Rankine" title="Permalink to this definition"></a></dt>
<dd><p>Temperature of one Rankine (in units of Kelvin).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="p">=</span> <span class="n">Rankine</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>T</strong> – Temperature of one Rankine (in units of Kelvin).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.ampere">
<span class="sig-name descname"><span class="pre">ampere</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.ampere" title="Permalink to this definition"></a></dt>
<dd><p>Electrical current of 1 ampere (in units of amps)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">Amepere</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – Electrical current of 1 Ampere (in units of Amps, == 1).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.atm">
<span class="sig-name descname"><span class="pre">atm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.atm" title="Permalink to this definition"></a></dt>
<dd><p>Compute numerical value, in units of Pascal, of one atmosphere.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="p">=</span> <span class="n">atm</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>a</strong> – Numerical value, in units of Pascal (Pa), of a pressure of one
atmosphere.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.barsa">
<span class="sig-name descname"><span class="pre">barsa</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.barsa" title="Permalink to this definition"></a></dt>
<dd><p>Compute numerical value, in units of Pascal, of one bar.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="p">=</span> <span class="n">barsa</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>b</strong> – Numerical value, in units of Pascal (Pa), of a pressure of one bar.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.btu">
<span class="sig-name descname"><span class="pre">btu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.btu" title="Permalink to this definition"></a></dt>
<dd><p>British termal unit
.. rubric:: Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="p">=</span> <span class="n">btu</span><span class="p">()</span>
</pre></div>
</div>
<dl class="simple">
<dt>PARMETERS:</dt><dd><p>None.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>E</strong> – Energy in units of joule.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.centi">
<span class="sig-name descname"><span class="pre">centi</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.centi" title="Permalink to this definition"></a></dt>
<dd><p>One houndreth prefix.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="p">=</span> <span class="n">centi</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>c = 1 / 100</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.convertFrom">
<span class="sig-name descname"><span class="pre">convertFrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">q</span></em>, <em class="sig-param"><span class="pre">unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.convertFrom" title="Permalink to this definition"></a></dt>
<dd><p>Convert physical quantity from given unit to equivalent SI.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="p">=</span> <span class="n">convertFrom</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> – Numerical array containing values of a physical quantity
measured in a given unit of measurement.</p></li>
<li><p><strong>unit</strong> – The unit of measurement of the physical quantity ‘q’.  Assumed
to be a combination of the known units in ‘units’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>q</strong> – Numerical array containing the numerical values resulting from
converting the input array from the unit of measurement given by
‘unit’ to the equivalent SI unit.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">press</span> <span class="p">=</span> <span class="n">convertFrom</span><span class="p">(</span><span class="n">press</span><span class="p">,</span> <span class="n">barsa</span><span class="p">())</span>    <span class="c">% bar -&gt; Pascal</span>
<span class="n">rate</span>  <span class="p">=</span> <span class="n">convertFrom</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">stb</span><span class="p">()</span><span class="o">/</span><span class="n">day</span><span class="p">())</span> <span class="c">% stb/day -&gt; m^3/s</span>
<span class="n">mu</span>    <span class="p">=</span> <span class="n">convertFrom</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">Pa</span><span class="p">()</span><span class="o">*</span><span class="nb">sec</span><span class="p">())</span>    <span class="c">% Pa s -&gt; Pa s (identity)</span>

<span class="n">press</span> <span class="p">=</span> <span class="n">convertTo</span><span class="p">(</span><span class="n">convertFrom</span><span class="p">(</span><span class="n">press</span><span class="p">,</span> <span class="n">atm</span><span class="p">()),</span> <span class="n">psia</span><span class="p">())</span> <span class="c">% Atm -&gt; psia</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is the caller’s responsibility to supply a ‘unit’ consistent with
the physical quantity ‘q’.  Specifically, function ‘convertFrom’ does
no checking of the input parameters and will, if so instructed, convert
the numeric value of a pressure into a time value.  Caveat emptor.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">units</span></code>, <a class="reference internal" href="#core.utils.units.convertTo" title="core.utils.units.convertTo"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertTo</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.convertTo">
<span class="sig-name descname"><span class="pre">convertTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">q</span></em>, <em class="sig-param"><span class="pre">unit</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.convertTo" title="Permalink to this definition"></a></dt>
<dd><p>Convert physical quantity from SI to equivalent given unit.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="p">=</span> <span class="n">convertTo</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> – Numerical array containing values of a physical quantity
measured in a strictly SI unit.</p></li>
<li><p><strong>unit</strong> – The unit of measurement to which ‘q’ should be converted.
Assumed to be a combination of the known units in ‘units’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>q</strong> – Numerical array containing the numerical values resulting from
converting the input array from the SI unit to the unit of
measurement given by ‘unit’.</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">press</span> <span class="p">=</span> <span class="n">convertTo</span><span class="p">(</span><span class="n">press</span><span class="p">,</span> <span class="n">barsa</span><span class="p">())</span>    <span class="c">% Pascal -&gt; bar</span>
<span class="n">rate</span>  <span class="p">=</span> <span class="n">convertTo</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">stb</span><span class="p">()</span><span class="o">/</span><span class="n">day</span><span class="p">())</span> <span class="c">% m^3/s -&gt; stb/day</span>
<span class="n">mu</span>    <span class="p">=</span> <span class="n">convertTo</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">Pa</span><span class="p">()</span><span class="o">*</span><span class="nb">sec</span><span class="p">())</span>    <span class="c">% Pa s -&gt; Pa s (identity)</span>

<span class="n">press</span> <span class="p">=</span> <span class="n">convertTo</span><span class="p">(</span><span class="n">convertFrom</span><span class="p">(</span><span class="n">press</span><span class="p">,</span> <span class="n">atm</span><span class="p">()),</span> <span class="n">psia</span><span class="p">())</span> <span class="c">% Atm -&gt; psia</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is the caller’s responsibility to supply a ‘unit’ consistent with
the physical quantity ‘q’.  Specifically, function ‘convertTo’ does
no checking of the input parameters and will, if so instructed,
convert the numeric value of a pressure into a time value.  Caveat
emptor.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">units</span></code>, <a class="reference internal" href="#core.utils.units.convertFrom" title="core.utils.units.convertFrom"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertFrom</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.dalton">
<span class="sig-name descname"><span class="pre">dalton</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.dalton" title="Permalink to this definition"></a></dt>
<dd><p>Mass of one kilogram, in units of kilogram.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="p">=</span> <span class="n">dalton</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>m</strong> – Numeric value, in units of kilogram, of a mass of one kilogram.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.darcy">
<span class="sig-name descname"><span class="pre">darcy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.darcy" title="Permalink to this definition"></a></dt>
<dd><p>Compute numerical value, in units of m^2, of the Darcy constant.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">darcy</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – Numerical value, in units of m^2, of the Darcy constant.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A porous medium with a permeability of 1 darcy permits a flow (flux) of
1 cm³/s of a fluid with viscosity 1 cP (1 mPa·s) under a pressure
gradient of 1 atm/cm acting across an area of 1 cm².</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.params.gravity" title="core.params.gravity"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">gravity</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.day">
<span class="sig-name descname"><span class="pre">day</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.day" title="Permalink to this definition"></a></dt>
<dd><p>Give numerical value, in units of seconds, of one day.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">day</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – Numerical value, in units of s, of one day.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.units.darcy" title="core.utils.units.darcy"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">darcy</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.deci">
<span class="sig-name descname"><span class="pre">deci</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.deci" title="Permalink to this definition"></a></dt>
<dd><p>One tenth prefix.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">deci</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d = 1 / 10</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.dyne">
<span class="sig-name descname"><span class="pre">dyne</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.dyne" title="Permalink to this definition"></a></dt>
<dd><p>Compute numerical value, in units of Newton of one dyne.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">dyne</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – Numerical value, in units of N, of a force of one dyne.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.farad">
<span class="sig-name descname"><span class="pre">farad</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.farad" title="Permalink to this definition"></a></dt>
<dd><p>Electrical capacitance of 1 Farad (in units of Farads)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">Farad</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – Electrical capacitance of 1 Farad (in units of Farads, == 1).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.ft">
<span class="sig-name descname"><span class="pre">ft</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.ft" title="Permalink to this definition"></a></dt>
<dd><p>Distance of one foot (in units of meters).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">ft</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – Distance of one foot (in units of meters).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.gal">
<span class="sig-name descname"><span class="pre">gal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.gal" title="Permalink to this definition"></a></dt>
<dd><p>Unit of gravity 1 Gal = 0.01 m/s²
.. rubric:: Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">gal</span><span class="p">()</span>
</pre></div>
</div>
<dl class="simple">
<dt>PARMETERS:</dt><dd><p>None.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>d</strong> – gravitation in gal (== 0.01)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.gallon">
<span class="sig-name descname"><span class="pre">gallon</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.gallon" title="Permalink to this definition"></a></dt>
<dd><p>Compute numerical value, in units of m^3, of one U.S. liquid gallon.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">ga</span> <span class="p">=</span> <span class="n">gallon</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ga</strong> – Numerical value, in units of m^3, of a volume of one U.S. liquid
gallon (== 231 cubic inches).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The U.S. liquid gallon was historically defined as the volume of a
straight, vertical cylinder with an inner diameter of 7 inches and a
height of 6 inches.  This is 231 inch^3 if we assume that pi = 22/7.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.getUnitSystem">
<span class="sig-name descname"><span class="pre">getUnitSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.getUnitSystem" title="Permalink to this definition"></a></dt>
<dd><p>Define unit conversion factors for input data.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="p">=</span> <span class="n">getUnitSystem</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>s</strong> – <p>String naming particular ECLIPSE deck unit conventions.  Accepted
values are:</p>
<blockquote>
<div><ul class="simple">
<li><p>’METRIC’ –  Metric unit conventions (lengths in meter &amp;c)</p></li>
<li><p>’FIELD’  –  Field unit conventions (lengths in feet &amp;c)</p></li>
<li><p>’LAB’    –  Lab unit conventions (lengths in cm &amp;c)</p></li>
<li><p>’SI’     –  Strict SI conventions (all conversion factors 1)</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>u</strong> – Data structure of unit conversion factors from input data to MRST’s
strict SI conventions.  Currently defines the following fields:</p>
<blockquote>
<div><p>length    - Input unit of measurement for lengths/depths &amp;c
time      - Input unit of measurement for time
press     - Input unit of measurement for pressure
viscosity - Input unit of measurement for viscosities
perm      - Input unit of measurement for permeabilities
resvolume - Input unit of measurement for reservoir volumes
trans     - Input unit of measurement for transmissibilitities</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.inout.eclipse.deckinput_simple.readGRDECL" title="core.utils.inout.eclipse.deckinput_simple.readGRDECL"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">readGRDECL</span></code></a>, <a class="reference internal" href="#core.utils.inout.convertInputUnits" title="core.utils.inout.convertInputUnits"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertInputUnits</span></code></a>, <a class="reference internal" href="#core.utils.units.convertFrom" title="core.utils.units.convertFrom"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">convertFrom</span></code></a>.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.giga">
<span class="sig-name descname"><span class="pre">giga</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.giga" title="Permalink to this definition"></a></dt>
<dd><p>One billion (milliard) prefix.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="p">=</span> <span class="n">giga</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>g = 1e9</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.gram">
<span class="sig-name descname"><span class="pre">gram</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.gram" title="Permalink to this definition"></a></dt>
<dd><p>Mass of one gram, in units of kilogram.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="p">=</span> <span class="n">gram</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>m</strong> – Numeric value, in units of kilogram, of a mass of one gram.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.hour">
<span class="sig-name descname"><span class="pre">hour</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.hour" title="Permalink to this definition"></a></dt>
<dd><p>Time span of one hour (in units of seconds).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="p">=</span> <span class="n">hour</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>t</strong> – Time span of one hour measured in units of seconds.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.inch">
<span class="sig-name descname"><span class="pre">inch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.inch" title="Permalink to this definition"></a></dt>
<dd><p>Distance of one inch (in units of meters).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">inch</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – Distance of one inch (in units of meters).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.joule">
<span class="sig-name descname"><span class="pre">joule</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.joule" title="Permalink to this definition"></a></dt>
<dd><p>Units of energy
.. rubric:: Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="p">=</span> <span class="n">joule</span><span class="p">()</span>
</pre></div>
</div>
<dl class="simple">
<dt>PARMETERS:</dt><dd><p>None.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>E</strong> – Temperature of one Kelvin (in units of Kelvin, == 1).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.kilo">
<span class="sig-name descname"><span class="pre">kilo</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.kilo" title="Permalink to this definition"></a></dt>
<dd><p>One thousand prefix.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="p">=</span> <span class="n">kilo</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>k = 1000</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.kilogram">
<span class="sig-name descname"><span class="pre">kilogram</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.kilogram" title="Permalink to this definition"></a></dt>
<dd><p>Mass of one kilogram, in units of kilogram.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="p">=</span> <span class="n">kilogram</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>m</strong> – Numeric value, in units of kilogram, of a mass of one kilogram.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.lbf">
<span class="sig-name descname"><span class="pre">lbf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.lbf" title="Permalink to this definition"></a></dt>
<dd><p>Force excerted by a mass of one avoirdupois pound at Tellus equator.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="p">=</span> <span class="n">lbf</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>F</strong> – Force excerted by a mass of one avoirdupois pound (0.45359237 kg)
at Tellus equator measured in units of Newton (N).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.litre">
<span class="sig-name descname"><span class="pre">litre</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.litre" title="Permalink to this definition"></a></dt>
<dd><p>Numerical value of one liter, in units of m^3</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">ltr</span> <span class="p">=</span> <span class="n">litre</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ltr</strong> – Numerical value of one liter, in units of m^3 (== 1 dm^3)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.mega">
<span class="sig-name descname"><span class="pre">mega</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.mega" title="Permalink to this definition"></a></dt>
<dd><p>One million prefix.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="p">=</span> <span class="n">mega</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>m = 1e6</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.meter">
<span class="sig-name descname"><span class="pre">meter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.meter" title="Permalink to this definition"></a></dt>
<dd><p>Distance of one meter (in units of meters).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">meter</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – Distance of one meter (in units of meters, == 1).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.micro">
<span class="sig-name descname"><span class="pre">micro</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.micro" title="Permalink to this definition"></a></dt>
<dd><p>One millionth prefix.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="p">=</span> <span class="n">micro</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mu = 1e</strong> – 6</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.milli">
<span class="sig-name descname"><span class="pre">milli</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.milli" title="Permalink to this definition"></a></dt>
<dd><p>One thousandth prefix.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="p">=</span> <span class="n">milli</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>m = 1 / 1000</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.minute">
<span class="sig-name descname"><span class="pre">minute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.minute" title="Permalink to this definition"></a></dt>
<dd><p>Time span of one minute (in units of seconds).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="p">=</span> <span class="n">minute</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>t</strong> – Time span of one minute measured in units of seconds.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.mol">
<span class="sig-name descname"><span class="pre">mol</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.mol" title="Permalink to this definition"></a></dt>
<dd><p>Amount of Chemical Substance of One Mole in Units of Moles</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="p">=</span> <span class="n">mol</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>m</strong> – Numerical value of a mole in units of mole (== 1).</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.nano">
<span class="sig-name descname"><span class="pre">nano</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.nano" title="Permalink to this definition"></a></dt>
<dd><p>One billionth prefix.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="p">=</span> <span class="n">nano</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mu = 1e</strong> – 9</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.pico">
<span class="sig-name descname"><span class="pre">pico</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.pico" title="Permalink to this definition"></a></dt>
<dd><p>One trillionth prefix.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="p">=</span> <span class="n">pico</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mu = 1e</strong> – 12</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.poise">
<span class="sig-name descname"><span class="pre">poise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.poise" title="Permalink to this definition"></a></dt>
<dd><p>Compute numerical value, in units of Pa*s, of one poise (P).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="p">=</span> <span class="n">poise</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mu</strong> – Numerical value, in units of Pascal seconds (Pa*s) of a viscosity
of one poise (P).</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.pound">
<span class="sig-name descname"><span class="pre">pound</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.pound" title="Permalink to this definition"></a></dt>
<dd><p>Mass of one avoirdupois pound, in units of kilogram.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="p">=</span> <span class="n">pound</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>m</strong> – Mass of one avoirdupois pound (0.45359237 kg)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.psia">
<span class="sig-name descname"><span class="pre">psia</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.psia" title="Permalink to this definition"></a></dt>
<dd><p>Compute numerical value, in units of Pascal, of one Psi.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="p">=</span> <span class="n">psia</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Numerical value, in units of Pascal (Pa), of a pressure of one Psi.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.second">
<span class="sig-name descname"><span class="pre">second</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.second" title="Permalink to this definition"></a></dt>
<dd><p>Time span of one second (in units of seconds).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="p">=</span> <span class="n">second</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>t</strong> – Time span of one second (in units of seconds, == 1).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.site">
<span class="sig-name descname"><span class="pre">site</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.site" title="Permalink to this definition"></a></dt>
<dd><p>Number of 1 site (in units of avagadros numer)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">site</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – Number of 1 site (in units of avagadros numer).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.stb">
<span class="sig-name descname"><span class="pre">stb</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.stb" title="Permalink to this definition"></a></dt>
<dd><p>Compute numerical value, in units of m^3, of one standard barrel.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">bbl</span> <span class="p">=</span> <span class="n">stb</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>bbl</strong> – Numerical value, in units of m^3, of a volume of one barrel
(== 42 U.S. liquid gallon).</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.year">
<span class="sig-name descname"><span class="pre">year</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.year" title="Permalink to this definition"></a></dt>
<dd><p>Give numerical value, in units of seconds, of one year.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">=</span> <span class="n">year</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>d</strong> – Numerical value, in units of s, of one year.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#core.utils.units.day" title="core.utils.units.day"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">day</span></code></a>, <a class="reference internal" href="#core.utils.units.hour" title="core.utils.units.hour"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hour</span></code></a>.</p>
</div>
</dd></dl>

<span class="target" id="module-core.utils.units.constants"></span><dl class="mat script">
<dt class="sig sig-object mat" id="core.utils.units.constants.Contents">
<span class="sig-name descname"><span class="pre">Contents</span></span><a class="headerlink" href="#core.utils.units.constants.Contents" title="Permalink to this definition"></a></dt>
<dd><p>CONSTANTS</p>
<dl class="simple">
<dt>Files</dt><dd><p>avogadro           - Avogadro constant (in mol^-1)
faradayConstant    - Faraday constant in C mol^-1
gasConstant        - Gas constant (in kg m^2 s^-2 K^-1 mol^-1)
vacuumpermittivity - Vacuum permitivity in Farads per meter</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.constants.avogadro">
<span class="sig-name descname"><span class="pre">avogadro</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.constants.avogadro" title="Permalink to this definition"></a></dt>
<dd><p>Avogadro constant (in mol^-1)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">An</span> <span class="p">=</span> <span class="n">avogadro</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>An</strong> – Avogadro number (in mol^-1)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.constants.faradayConstant">
<span class="sig-name descname"><span class="pre">faradayConstant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.constants.faradayConstant" title="Permalink to this definition"></a></dt>
<dd><p>Faraday constant in C mol^-1</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="p">=</span> <span class="n">faradayConstant</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>F</strong> – Faraday constant in C mol^-1</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.constants.gasConstant">
<span class="sig-name descname"><span class="pre">gasConstant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.constants.gasConstant" title="Permalink to this definition"></a></dt>
<dd><p>Gas constant (in kg m^2 s^-2 K^-1 mol^-1)</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="p">=</span> <span class="n">gasconstant</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>R</strong> – Gas constant (in kg m^2 s^-2 K^-1 mol^-1)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="core.utils.units.constants.vacuumpermittivity">
<span class="sig-name descname"><span class="pre">vacuumpermittivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#core.utils.units.constants.vacuumpermittivity" title="Permalink to this definition"></a></dt>
<dd><p>Vacuum permitivity in Farads per meter</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">epsi</span> <span class="p">=</span> <span class="n">vacuumpermittivity</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None.</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>epsi</strong> – Vacuum permitivity in Farads per meter</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary purpose of this utility function is to make examples
easier to read.</p>
</div>
</dd></dl>

</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h2>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to the MRST quick documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ad-core.html" class="btn btn-neutral float-right" title="ad-core: Automatic Differentiation Core" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, SINTEF Digital.
      <span class="lastupdated">Last updated on Sep 23, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>