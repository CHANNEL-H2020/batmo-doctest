<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hfm: Hierarchical and embedded fractures &mdash; The Matlab Reservoir Simulation Toolbox 2019b documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="incomp: Solvers for incompressible flow and transport" href="incomp.html" />
    <link rel="prev" title="heterogeneity" href="heterogeneity.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> The Matlab Reservoir Simulation Toolbox
            <img src="_static/mrstlogo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2019b
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="core.html">Core functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-core.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-core</span></code>: Automatic Differentiation Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-props.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-props</span></code>: PVT, fluid models and other properties for the AD-solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-blackoil.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-blackoil</span></code>: Black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-eor.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-eor</span></code>: Enhanced oil recovery solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad-mechanics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">ad-mechanics</span></code>: Coupled flow and mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="adjoint.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">adjoint</span></code>: Two-phase, incompressible adjoint solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="agglom.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">agglom</span></code>: Flow and property-based coarse-grid generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="blackoil-sequential.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">blackoil-sequential</span></code>: Sequential implicit black-oil solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="book.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">book</span></code>: Book examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="coarsegrid.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">coarsegrid</span></code>: Generation of coarse grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="compositional.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">compositional</span></code>: Equation-of-state compositional solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="co2lab.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">co2lab</span></code>: Numerical CO<sub>2</sub> laboratory</a></li>
<li class="toctree-l1"><a class="reference internal" href="deckformat.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">deckformat</span></code>: Reading and conversion of input decks</a></li>
<li class="toctree-l1"><a class="reference internal" href="dfm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dfm</span></code>: Discrete fracture matrix implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="dg.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dg</span></code>: Discontinous Galerkin discretizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">diagnostics</span></code>: Flow diagnostics functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="dual_porosity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">dual-porosity</span></code>: Dual porosity/permeability model for fractures</a></li>
<li class="toctree-l1"><a class="reference internal" href="fvbiot.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">fvbiot</span></code>: Consistent finite-volume discretizations for poroelasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="geochemistry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">geochemistry</span></code>: Surface geochemistry</a></li>
<li class="toctree-l1"><a class="reference internal" href="heterogeneity.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">heterogeneity</span></code></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hfm</span></code>: Hierarchical and embedded fractures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="incomp.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">incomp</span></code>: Solvers for incompressible flow and transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="libgeometry.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">libgeometry</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="linearsolvers.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">linearsolvers</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="matlab_bgl.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">matlab_bgl</span></code>:</a></li>
<li class="toctree-l1"><a class="reference internal" href="mimetic.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mimetic</span></code>: Mimetic solvers for pressure problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mpfa</span></code>: Multi-point flux approximation solvers for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst_api.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst_api</span></code>: API for writing C/C++ for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrst-gui.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">mrst-gui</span></code>: Graphical user-interfaces for MRST</a></li>
<li class="toctree-l1"><a class="reference internal" href="msfvm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msfvm</span></code>: Multiscale Finite-Volume method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msmfem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msmfem</span></code>: Multiscale Mixed Finite-Element method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="msrsb.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">msrsb</span></code>: Multiscale Restriction-Smoothed Basis method for pressure</a></li>
<li class="toctree-l1"><a class="reference internal" href="nwm.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nwm</span></code>: Near Wellbore Modelling</a></li>
<li class="toctree-l1"><a class="reference internal" href="opm_gridprocessing.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">opm_gridprocessing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="optimization.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">optimization</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="re-mpfa.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">re-mpfa</span></code>: Richards’ equation with multi-point flux</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvent.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">solvent</span></code>: Solvent solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="spe10.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">spe10</span></code>: Access to the SPE10 benchmark case</a></li>
<li class="toctree-l1"><a class="reference internal" href="steady-state.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">steady-state</span></code> Steady-state upscaling of functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamlines.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">streamlines</span></code>: Compute streamlines</a></li>
<li class="toctree-l1"><a class="reference internal" href="triangle.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">triangle</span></code>: Triangular grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="upscaling.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">upscaling</span></code>: Upscaling of reservoir problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="vem.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vem</span></code>: Virtual element method on general grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="vemmech.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">vemmech</span></code>: Mechanics for general grids using the virtual element method</a></li>
<li class="toctree-l1"><a class="reference internal" href="wellpaths.html"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">wellpaths</span></code>: Generation of wells using general curves</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Matlab Reservoir Simulation Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hfm</span></code>: Hierarchical and embedded fractures</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/hfm.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="hfm-hierarchical-and-embedded-fractures">
<h1><code class="xref mat mat-func docutils literal notranslate"><span class="pre">hfm</span></code>: Hierarchical and embedded fractures<a class="headerlink" href="#hfm-hierarchical-and-embedded-fractures" title="Permalink to this headline"></a></h1>
<p>The hierarchical fracture module (HFM) utilises the hierarchical fracture modelling framework to simulate multiphase flow in naturally fractured reservoirs with multiple length scales. Also known as the embedded discrete fracture model, this method models fractures explicitly, as major fluid pathways, and benefits from independent definitions of the fracture and matrix grid. As a result, intricate fracture networks can be modelled easily, without the need for a complex underlying matrix grid that is conformal with each fracture. The module also extends the newly developed multiscale restriction smoothed basis (MsRSB) method to compute the flux field developed in a fractured reservoir. The multiscale approach of dealing with fractures is inspired by similar strategies developed for the multiscale finite volume (MSFV) method.</p>
<span class="target" id="module-hfm.utils"></span><dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.checkDistmesh">
<span class="sig-name descname"><span class="pre">checkDistmesh</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.checkDistmesh" title="Permalink to this definition"></a></dt>
<dd><p>Checks if distmesh_2d file is installed in the MATLAB path</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">hasLSI</span> <span class="p">=</span> <span class="n">checkLineSegmentIntersect</span><span class="p">();</span>
<span class="n">checkLineSegmentIntersect</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function checks if the file ‘distmesh_2d.m’
(<a class="reference external" href="http://people.sc.fsu.edu/~jburkardt/m_src/distmesh/distmesh.html">http://people.sc.fsu.edu/~jburkardt/m_src/distmesh/distmesh.html</a>) is
installed in the current MATLAB path and advises the user to install it
if it is not found.</p>
<p>If called with a return argument, it will produce a boolean indicating
the status of the distmesh_2d.m file. The application checking
for distmesh_2d.m can then fall back to other implementations
of graph algorithms as they please. If called without any return
arguments, it will throw an error if distmesh_2d.m was not
found, along with a link and install instructions for the user to
rectify the missing installation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>foundLSI</strong> (<em>OPTIONAL</em>) – If distmesh_2d.m was found. Note that
the nature of the utility changes if called with
return argument.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.checkIfCoplanar">
<span class="sig-name descname"><span class="pre">checkIfCoplanar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fracplanes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.checkIfCoplanar" title="Permalink to this definition"></a></dt>
<dd><p>Asserts that a given set of points (in 3D) are coplanar.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.checkLineSegmentIntersect">
<span class="sig-name descname"><span class="pre">checkLineSegmentIntersect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.checkLineSegmentIntersect" title="Permalink to this definition"></a></dt>
<dd><p>Checks if lineSegmentIntersect file is installed in the MATLAB path</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">hasLSI</span> <span class="p">=</span> <span class="n">checkLineSegmentIntersect</span><span class="p">();</span>
<span class="n">checkLineSegmentIntersect</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function checks if the file ‘lineSegmentIntersect.m’
(<a class="reference external" href="http://www.mathworks.com/matlabcentral/fileexchange/27205">http://www.mathworks.com/matlabcentral/fileexchange/27205</a>) is
installed in the current MATLAB path and advises the user to install it
if it is not found.</p>
<p>If called with a return argument, it will produce a boolean indicating
the status of the lineSegmentIntersect.m file. The application checking
for lineSegmentIntersect.m can then fall back to other implementations
of graph algorithms as they please. If called without any return
arguments, it will throw an error if lineSegmentIntersect.m was not
found, along with a link and install instructions for the user to
rectify the missing installation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>foundLSI</strong> (<em>OPTIONAL</em>) – If lineSegmentIntersect.m was found. Note that
the nature of the utility changes if called with
return argument.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.checkMATLABversionHFM">
<span class="sig-name descname"><span class="pre">checkMATLABversionHFM</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.checkMATLABversionHFM" title="Permalink to this definition"></a></dt>
<dd><p>Checks if the matlab version is greater than 2015a for compatibility with
‘ismembertol’ and ‘uniquetol’ functions and prints a warning if the
matlab version is lower.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="p">=</span> <span class="n">checkMATLABversionHFM</span><span class="p">();</span>
<span class="n">checkMATLABversionHFM</span><span class="p">();</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>v</strong> (<em>OPTIONAL</em>) – Matlab version as a character array (ex: 2015a)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.computeEffectiveTrans">
<span class="sig-name descname"><span class="pre">computeEffectiveTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.computeEffectiveTrans" title="Permalink to this definition"></a></dt>
<dd><p>Computes the effective transmissibility between the fracture and matrix
by harmonically averaging weighted permeablities and multiplying by CI.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.establishSign">
<span class="sig-name descname"><span class="pre">establishSign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fracplanes</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.establishSign" title="Permalink to this definition"></a></dt>
<dd><p>Assigns a value of 0 (if the node/edge lies on the plane), 1 (if the
node/edge lies on the positive side of the plane) or -1 (if the node/edge
lies  on the negative side of the plane) to every corner point and edge
of the input polygon with respect to the normal vector of the polygon and
the normal vector of its bounding planes.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.extend_frac2D">
<span class="sig-name descname"><span class="pre">extend_frac2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">frac_endp</span></em>, <em class="sig-param"><span class="pre">edges</span></em>, <em class="sig-param"><span class="pre">out</span></em>, <em class="sig-param"><span class="pre">cnum</span></em>, <em class="sig-param"><span class="pre">cnodes</span></em>, <em class="sig-param"><span class="pre">faces</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.extend_frac2D" title="Permalink to this definition"></a></dt>
<dd><p>extend_frac is used to extend a 2D fracture line when it only partially
penetrates matrix cells at its end points. Following this, the ratio of
true fracture length to its extended length inside the concerned matrix
cell is returned. CI is computed for the extended fracture inside the
corresponding matrix cell and scaled by this ratio. See Lee et al, Water
Resources Research, 2001.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.findRectangularFractures">
<span class="sig-name descname"><span class="pre">findRectangularFractures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fractures</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.findRectangularFractures" title="Permalink to this definition"></a></dt>
<dd><p>Indicates the rectangular fractures using a structure containing, for
each fracture, the set of points defining the fracture polygon in 3D.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.generatePointsOnPlane">
<span class="sig-name descname"><span class="pre">generatePointsOnPlane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">points</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.generatePointsOnPlane" title="Permalink to this definition"></a></dt>
<dd><p>Generates points on a 3D convex polygon defined by a coplanar set of
points</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.getAvgFracDist2D">
<span class="sig-name descname"><span class="pre">getAvgFracDist2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fracp</span></em>, <em class="sig-param"><span class="pre">cell_num</span></em>, <em class="sig-param"><span class="pre">cnodes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.getAvgFracDist2D" title="Permalink to this definition"></a></dt>
<dd><p>getAvgFracDist computes the average normal distance of each point inside
a matrix cell from every fracture line that intersects with this cell.
This is the same as &lt;d&gt; used for computing conductivity index (CI, see
CIcalculator2D) as described in SPE-103901-PA, Lyong Li and Seong H. Lee,
2008.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.getPlaneNormals">
<span class="sig-name descname"><span class="pre">getPlaneNormals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fracplanes</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.getPlaneNormals" title="Permalink to this definition"></a></dt>
<dd><p>Computes the normal vector for a set of coplanar points in 3D.
Additionally, it returns the normal vector of the bounding planes
perpendicular to the edges of the polygon defined by the set of input
points.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.globalTriangulation">
<span class="sig-name descname"><span class="pre">globalTriangulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.globalTriangulation" title="Permalink to this definition"></a></dt>
<dd><p>This function creates a global triangulation such that each cell in a
grid is made up of one or more full tetrahedrons. The global
triangulation can then be used to locate the cells that enclose a given
set of points.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.inPolygon3D">
<span class="sig-name descname"><span class="pre">inPolygon3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">q</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.inPolygon3D" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if a set of query points ‘q’ in 3D lie inside or on a polygon
defined by coplanar points ‘p’.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.iscoplanar">
<span class="sig-name descname"><span class="pre">iscoplanar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pxyz</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.iscoplanar" title="Permalink to this definition"></a></dt>
<dd><p>Checks if a set of points lie on the plane defined by points ‘pxyz’ and
returns an indicator value for each point along with its normal distance
from the plane.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.makeRockFrac">
<span class="sig-name descname"><span class="pre">makeRockFrac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">K_frac</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.makeRockFrac" title="Permalink to this definition"></a></dt>
<dd><p>makeRockFrac can be used to set homogeneous rock properties to the
fracture grid stored in G.FracGrid given a scalar value for fracture
permeability and porosity.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">makeRockFrac</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">K_frac</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">makeRockFrac</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">K_frac</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="s">&#39;pv1&#39;</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">makeRockFrac</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">K_frac</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="s">&#39;pv1&#39;</span><span class="p">,</span> <span class="s">&#39;pn2&#39;</span><span class="p">,</span> <span class="n">pn2</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure containing fracture grids (for each
fracture line or plane) in G.FracGrid</p></li>
<li><p><strong>K_frac</strong> – Scalar Darcy permeability for homogeneous fractures.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>permtype</strong> – ‘homogeneous’ or ‘heterogeneous’. If ‘heterogeneous’ is
passed as the permtype, this function assigns a random
permeability distribution to each fracture grid cell. To
manually assign a specific permeability distribution, the
user must access G.FracGrid.Frac#.rock.perm as shown in the
code written below. In that case, one does not need to call
makeRockFrac.</p></li>
<li><p><strong>porosity</strong> – Scalar value for rock porosity (0&lt;porosity&lt;1)</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid data structure with structure rock added to each fracture grid
(Frac#) in G.FracGrid.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function uses randi() to generate a random permeability field when
‘heterogeneous’ is specified as ‘permtype’.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>FracTensorGrid2D</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.pdist_euclid">
<span class="sig-name descname"><span class="pre">pdist_euclid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.pdist_euclid" title="Permalink to this definition"></a></dt>
<dd><p>Pairwise euclidian distance between pairs of objects.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.polyArea3D">
<span class="sig-name descname"><span class="pre">polyArea3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">p</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.polyArea3D" title="Permalink to this definition"></a></dt>
<dd><p>Computes the surface area of a polygon defined by the set of points ‘p’
in 3D</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.rotatePlane">
<span class="sig-name descname"><span class="pre">rotatePlane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">points</span></em>, <em class="sig-param"><span class="pre">normal</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.rotatePlane" title="Permalink to this definition"></a></dt>
<dd><p>Rotates a set of points (assumed to be coplanar) in order to align with a
plane defined by the input normal vector. Rotation is along the axis
defined by the intersection of the two planes. If the plane defined by
the input set of points is parallel to the input normal vector, then this
function returns the points without making a transformation.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.roundsd">
<span class="sig-name descname"><span class="pre">roundsd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">n</span></em>, <em class="sig-param"><span class="pre">method</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.roundsd" title="Permalink to this definition"></a></dt>
<dd><p>ROUNDSD Round with fixed significant digits
ROUNDSD(X,N) rounds the elements of X towards the nearest number with
N significant digits.</p>
<dl class="simple">
<dt>ROUNDSD(X,N,METHOD) uses following methods for rounding:</dt><dd><p>‘round’ - nearest (default)
‘floor’ - towards minus infinity
‘ceil’  - towards infinity
‘fix’   - towards zero</p>
</dd>
</dl>
<p class="rubric">Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">roundsd</span><span class="p">(</span><span class="mf">0.012345</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="n">returns</span> <span class="mf">0.0123</span>
<span class="n">roundsd</span><span class="p">(</span><span class="mi">12345</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="n">returns</span> <span class="mi">12000</span>
<span class="n">roundsd</span><span class="p">(</span><span class="mf">12.345</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s">&#39;ceil&#39;</span><span class="p">)</span> <span class="n">returns</span> <span class="mf">12.35</span>
</pre></div>
</div>
<p>See also Matlab’s functions ROUND, ROUND10, FLOOR, CEIL, FIX, and
ROUNDN (Mapping Toolbox).</p>
<dl class="simple">
<dt>Author: Franois Beauducel &lt;<a class="reference external" href="mailto:beauducel&#37;&#52;&#48;ipgp&#46;fr">beauducel<span>&#64;</span>ipgp<span>&#46;</span>fr</a>&gt;</dt><dd><p>Institut de Physique du Globe de Paris</p>
</dd>
</dl>
<p>Acknowledgments: Edward Zechmann, Daniel Armyr, Yuri Kotliarov</p>
<p>Created: 2009-01-16
Updated: 2015-04-03</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.translateLine">
<span class="sig-name descname"><span class="pre">translateLine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">points</span></em>, <em class="sig-param"><span class="pre">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.translateLine" title="Permalink to this definition"></a></dt>
<dd><p>translateLine(points,a) translates the line given by an n-by-2 vector of
coincident ‘points’ by a normal distance ‘a’ in 2D space to create a
rectangle given by the 2*n-by-2 vector ‘p’.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.utils.tri_area">
<span class="sig-name descname"><span class="pre">tri_area</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">P1</span></em>, <em class="sig-param"><span class="pre">P2</span></em>, <em class="sig-param"><span class="pre">P3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.utils.tri_area" title="Permalink to this definition"></a></dt>
<dd><p>tri_area(P1, P2, P3) calculates the triangle area given the coordinates
of its vertices in P1, P2 and P3 using Heron’s formula.</p>
<p>Heron’s Formula:
s = semiperimeter
A = sqrt(s * (s-a) * (s-b) * (s-c))
Where a,b,c are lengths of the triangle edges</p>
</dd></dl>

<span class="target" id="module-hfm.rsbsupport"></span><dl class="mat function">
<dt class="sig sig-object mat" id="hfm.rsbsupport.addCoarseCenterPointsFrac">
<span class="sig-name descname"><span class="pre">addCoarseCenterPointsFrac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">CGf</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.rsbsupport.addCoarseCenterPointsFrac" title="Permalink to this definition"></a></dt>
<dd><p>addCoarseCenterPointsFrac adds coarse nodes to the fracture coarse
grid CGf. This function can be modified to improve coarse node selection
inside fractures.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">CGf</span> <span class="p">=</span> <span class="n">addCoarseCenterPointsFrac</span><span class="p">(</span><span class="n">CGf</span><span class="p">)</span>
<span class="n">CGf</span> <span class="p">=</span> <span class="n">addCoarseCenterPointsFrac</span><span class="p">(</span><span class="n">CGf</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="s">&#39;pv1&#39;</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>CGf</strong> – Fracture coarse grid (supplied by ‘generateCoarseGrid’) with
geometry information (computed through ‘coarsenGeometry’).</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>option</strong> – option specifies the type of coarse grid points to use for
computing the coarse node location. Possible self-explanatory
values are:</p>
<ol class="loweralpha simple">
<li><p>‘useCoarseFaceCentroids’</p></li>
<li><p>‘useCoarseCellCentroids’</p></li>
<li><p>‘useFineCellCentroids’</p></li>
<li><p>‘useCoarseCellEndPoints’ - 2D grids only</p></li>
</ol>
<p>passed as character arrays.</p>
</li>
<li><p><strong>meantype</strong> – type of mean, of the points specified by option, to use for
computing the coarse node location. Valid input values
include ‘geometric’ and ‘arithmetic’ passed as character
arrays. This option is not useful if
‘useCoarseCellEndPoints’ is passed as the option</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>CGf</strong> – Fracture coarse grid with CGf.cells.centers added as a new field.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>storeFractureInteractionRegion</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.rsbsupport.getRsbGridsHFM">
<span class="sig-name descname"><span class="pre">getRsbGridsHFM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">nw</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.rsbsupport.getRsbGridsHFM" title="Permalink to this definition"></a></dt>
<dd><p>Computes coarse grid and interaction region for a grid with fractures</p>
<blockquote>
<div><dl class="simple">
<dt>SYNOPSIS:</dt><dd><p>[CG, CGf] = getRsbGridsHFM(G, nw)
[CG, CGf] = getRsbGridsHFM(G, nw, ‘pn1’, pv1, …)</p>
</dd>
<dt>DESCRIPTION:</dt><dd><p>This function coarsens the matrix and fracture grids separately and
computes support regions for the fracture and matrix basis functions.
All of this is then combined into one coarse grid to be used for the
multiscale solver. There are no restrictions on grid definition.
Fracture partitioning algorithms are graph based.</p>
</dd>
</dl>
<p>REQUIRED PARAMETERS:</p>
<blockquote>
<div><p>G  - Grid structure with fractures as defined by assembleGlobalGrid.</p>
<dl class="simple">
<dt>nw - Structure containing indices of fractures that make up every</dt><dd><p>independent fracture network. same as fracture.networks for 2D
examples (see getIndepNetwork)</p>
</dd>
</dl>
</div></blockquote>
<p>OPTIONAL PARAMETERS:</p>
<blockquote>
<div><dl class="simple">
<dt>pm - Partition vector mapping matrix fine cells to coarse blocks.</dt><dd><p>Size = nm-by-1 where nm is the total number of fine cells in the
matrix.</p>
</dd>
<dt>coarseDims  -  Number of coarse blocks in each physical direction.</dt><dd><p>Assumed to be a LENGTH 2 or 3 vector of integers. To be
used only when the matrix grid is structured.</p>
</dd>
<dt>sampleDims  - Hypothetical cartesian dimensions (specifying number of</dt><dd><p>fine-cells in each coordinate direction) representing a
unstructured grid. Used to construct a structured coarse
grid, in the same physical space, which is then utilized
as a sample for mapping the unstructured fine grid to the
structured coarse grid. See sampleFromBox.</p>
</dd>
<dt>use_metis   - Logical value (true or false) to indicate the use of</dt><dd><p>metis to partition matrix.</p>
</dd>
<dt>dof_matrix  - Degrees of freedom in matrix at coarse scale. Required if</dt><dd><p>use_metis = true.</p>
</dd>
<dt>MatrixTrans - Transmissibility vector for all fine-grid faces in the</dt><dd><p>matrix</p>
</dd>
<dt>partition_frac - Logical value to indicate if fractures must be</dt><dd><p>coarsened. Otherwise fractures will be a part of the
matrix coarse grid and support regions and there will
be no coarse nodes inside a fracture. Useful to
observe the impact of coarsening fractures.</p>
</dd>
<dt>coarseDimsF - Number of coarse blocks for a fracture plate in each</dt><dd><p>physical direction. Aplicable only to rectangular
fracture plates in 3D system.</p>
</dd>
<dt>sampleDimsF - Similar to its counterpart in the matrix. Aplicable only</dt><dd><p>to rectangular fracture plates in 3D system.</p>
</dd>
<dt>use_metisF  - Logical value (true or false) to indicate the use of</dt><dd><p>metis to partition fractures.</p>
</dd>
<dt>dof_frac     - Degrees of freedom in each fracture network at coarse</dt><dd><p>scale. Required when use_metisF = true. Must either be a
single value &lt; minimum number of fine cells in all
independant fracture networks or a vector containing a
value for each intependent fracture network.</p>
</dd>
<dt>sysMatrix    - Fine scale system (transmissibility) matrix A (see</dt><dd><p>incompTPFA). Not necessary, but if available, allows the
use of an existing variable to construct an Adjacency
(or connectivity) matrix.</p>
</dd>
<dt>fracSupportRadius - levels of connectivity used to define the support</dt><dd><p>region for a fracture coarse block. In other words,
the topological radius of the fracture support
region. See storeFractureInteractionRegion.</p>
</dd>
<dt>fullyCoupled - Coupled fracture and matrix basis functions. Allows</dt><dd><p>matrix support to extend into fractures. Increases
accuracy but reduces speed.</p>
</dd>
<dt>excludeBoundary - Excludes fine cells on the boundary from support</dt><dd><p>regions of internal coarse blocks. Improves accuracy,
especially when boundary conditions are specified.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>———–EXPERIMENTAL———–%%%%%%%%%%%%%%%%%%%%%%</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>removeCenters    - Logical value to essentially enforce a basis</dt><dd><p>function value of 1 at each coarse node. May improve
convergence rate in an iterative multiscale
strategy.</p>
</dd>
<dt>coarseNodeOption - Possible methods for optimizing coarse node location</dt><dd><p>inside fractures.</p>
</dd>
<dt>paddedPartition  - If true, uses partitionUniformPadded to partition</dt><dd><p>matrix coarse grid. Requires ‘coarseDims’.</p>
</dd>
<dt>paddedPartitionF - If true, uses partitionUniformPadded to partition</dt><dd><p>fracture coarse grid. Requires ‘coarseDimsF’.</p>
</dd>
</dl>
<p>Wells            - Well structure. See addWell.</p>
<dl class="simple">
<dt>nearWellRefinement - Refines the coarse grid near wells by recursively</dt><dd><p>splitting the coarse block containing a well a
specified number of times.</p>
</dd>
<dt>nearWellRefinementMultipler - Integer denoting the number of times the</dt><dd><p>coarse block containing a well must be
recursively split into 2.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>RETURNS:</dt><dd><dl class="simple">
<dt>CG  - Coarse grid for grid G with basis supports and coarse node</dt><dd><p>indices. See storeInteractionRegion, generateCoarseGrid.</p>
</dd>
<dt>CGf - Fracture coarse grid with similar information as CG but only for</dt><dd><p>the internal fracture grid Gf as returned by assembleFracGrid.</p>
</dd>
</dl>
</dd>
<dt>SEE ALSO:</dt><dd><p>partitionMatrix, partitionFracture, generateCoarseGrid,
storeInteractionRegion, storeInteractionRegionFrac, partitionMETIS,
callMetisMatrix.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.rsbsupport.getRsbGridsMatrix">
<span class="sig-name descname"><span class="pre">getRsbGridsMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">pm</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.rsbsupport.getRsbGridsMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Generates the matrix coarse grid and computes support regions for the
matrix coarse blocks. See generateCoarseGrid and storeInteractionRegion.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.rsbsupport.partitionFracture">
<span class="sig-name descname"><span class="pre">partitionFracture</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">pm</span></em>, <em class="sig-param"><span class="pre">nw</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.rsbsupport.partitionFracture" title="Permalink to this definition"></a></dt>
<dd><p>Generates partition vector for the fracture grid. See getRsbGridsHFM for
description of input parameters.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.rsbsupport.partitionMatrix">
<span class="sig-name descname"><span class="pre">partitionMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.rsbsupport.partitionMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Generates partition vector for the matrix grid. See getRsbGridsHFM for
description of input parameters.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.rsbsupport.storeFractureInteractionRegion">
<span class="sig-name descname"><span class="pre">storeFractureInteractionRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">CG</span></em>, <em class="sig-param"><span class="pre">CGf</span></em>, <em class="sig-param"><span class="pre">CGm</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.rsbsupport.storeFractureInteractionRegion" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>storeFractureInteractionRegion defines and stores connectivity or grid</dt><dd><p>topology based internal and external (matrix) support regions for a
given matrix and fracture coarse grid.</p>
<dl class="simple">
<dt>SYNOPSIS:</dt><dd><p>[CG,CGf] = storeFractureInteractionRegion(CG, CGf, CGm)
[CG,CGf] = storeFractureInteractionRegion(CG, CGf, CGm, ‘pn1’, pv1, …)</p>
</dd>
<dt>DESCRIPTION:</dt><dd><p>This function computes the support for fracture basis functions
including interaction in the matrix as well as internal to each
fracture network.</p>
</dd>
</dl>
<p>REQUIRED PARAMETERS:</p>
<blockquote>
<div><p>CG  - Coarsened global grid ‘G’ containing fracture and matrix cells.</p>
<p>CGf - Coarsened fracture grid ‘Gf’ defined by assembleFracGrid.</p>
<p>CGm - Matrix coarse grid.</p>
</div></blockquote>
<p>OPTIONAL PARAMETERS:</p>
<blockquote>
<div><dl class="simple">
<dt>levels    - levels of connectivity used to define the support region</dt><dd><p>for a fracture coarse block. In other words, the
topological radius of the fracture support region.</p>
</dd>
<dt>fullyCoupled - Coupled fracture and matrix basis functions. Allows</dt><dd><p>matrix support to extend into fractures. Increases
accuracy but reduces speed.</p>
</dd>
<dt>excludeBoundary - Excludes fine cells on the boundary from support</dt><dd><p>regions of internal coarse blocks. Improves accuracy,
especially when boundary conditions are specified.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>———–EXPERIMENTAL———–%%%%%%%%%%%%%%%%%%%%%%</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>removeCenters    - Logical value to essentially enforce a basis</dt><dd><p>function value of 1 at each coarse node. May improve
convergence rate in an iterative multiscale
strategy.</p>
</dd>
<dt>coarseNodeOption - Possible methods for optimizing coarse node location</dt><dd><p>inside fractures.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>RETURNS:</dt><dd><dl class="simple">
<dt>CG - Coarse grid for combined fracture and matrix grid ‘G’ with basis</dt><dd><p>supports and coarse node indices in added fields
‘G.cells.interaction’ and ‘G.cells.centers respectively’.</p>
</dd>
<dt>CGf - Fracture coarse grid with similar added information as CG but</dt><dd><p>only for the internal fracture grid Gf as returned by
assembleFracGrid.</p>
</dd>
</dl>
</dd>
<dt>SEE ALSO:</dt><dd><p>storeInteractionRegion, getRsbGridsHFM,
storeFractureInternalInteractionRegion, addCoarseCenterPointsFrac</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.rsbsupport.storeFractureInternalInteractionRegion">
<span class="sig-name descname"><span class="pre">storeFractureInternalInteractionRegion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">CGf</span></em>, <em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.rsbsupport.storeFractureInternalInteractionRegion" title="Permalink to this definition"></a></dt>
<dd><p>storeFractureInternalInteractionRegion can be used to compute the support
region that lies inside a fracture for every fracture coarse block.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">CGf</span> <span class="p">=</span> <span class="n">storeFractureInternalInteractionRegion</span><span class="p">(</span><span class="n">CGf</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="n">CGf</span> <span class="p">=</span> <span class="n">storeFractureInternalInteractionRegion</span><span class="p">(</span><span class="n">CGf</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="s">&#39;pv1&#39;</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>CGf</strong> – Fracture coarse grid (supplied by ‘generateCoarseGrid’) with
geometry information (computed through ‘coarsenGeometry’).</p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>simpleInteractionRegion</strong> – connects neighboring coarse nodes, in a 2D
domain where fractures are represented as 1D
grids to compute the interaction region.</p></li>
<li><p><strong>callStoreInteractionRegion</strong> – calls the function storeInteractionRegion
to compute fracture internal interaction
regions. Applicable for 3D domains.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>CGf</strong> – Fracture coarse grid containing internal support regions in the
list CGf.cells.interaction.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>storeInteractionRegionFrac</p>
</div>
</dd></dl>

<span class="target" id="module-hfm.processing"></span><dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.CIcalculator2D">
<span class="sig-name descname"><span class="pre">CIcalculator2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fracture</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.CIcalculator2D" title="Permalink to this definition"></a></dt>
<dd><p>CIcalculator2D computes the conductivity index (CI) of each 2D cell for
every fracture line embedded in it.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">CIcalculator2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">fracture</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">CIcalculator2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">fracture</span><span class="p">,</span> <span class="n">waitbar</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>CI or conductivity index is similar to the well productivity index as
in the Peaceman well model. In hierarchical/embedded fracture
modelling, the flux exchange between fracture and matrix is defined by
a model similar to the peaceman well model. See Lee et al, Water
Resources Research, 2001 or SPE-65095-PA, Lee et al, 2000.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Matrix grid structure as returned by processFracture2D.</p></li>
<li><p><strong>fracture</strong> – Processed fracture structure. See processFracture2D.</p></li>
<li><p><strong>waitbar</strong> – Display a waitbar if this boolean variable is true</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Matrix grid structure with added cell lists ‘G.cells.fracture.CI’
and ‘G.cells.fracture.fA’ containing fracture-matrix conductivity
index and fracture length inside each matrix cell respectively</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>processFracture2D, getIndepNetwork, markcells2D</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.defineNNCandTrans">
<span class="sig-name descname"><span class="pre">defineNNCandTrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">F</span></em>, <em class="sig-param"><span class="pre">fracture</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.defineNNCandTrans" title="Permalink to this definition"></a></dt>
<dd><p>defineNNCandTrans identifies fracture-matrix and fracture-fracture
connections and computes once transmissibility for each connections.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">G</span><span class="p">,</span><span class="n">T</span><span class="p">]</span> <span class="p">=</span> <span class="n">defineNNCandTrans</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">fracture</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>defineNNCandTrans first recognizes all fracture-matrix connections
and stores them as non-neighboring connections (NNC’s). Then, the
global grid ‘G’ containing both fracture and matrix grid cells is
assembled. Following that, fracture-fracture connections (at
intersections) are defined as NNC’s and added to the global grid. The
script also computes transmissibilities for these NNC’s using rock
properties defined in G. This function calls frac_matrix_nnc,
frac_frac_nnc, assembleGlobalGrid and computeTrans internally.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure containing G.FracGrid (see
FracTensorGrid2D) with corresponding rock properties and
G.cells.fracture (see markcells2D and CIcalculator2D).</p></li>
<li><p><strong>F</strong> – Output from gridFracture2D.</p></li>
<li><p><strong>fracture</strong> – Output from gridFracture2D.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>G</strong> – Global grid structure (individual matrix and fracture grids
assembled into 1 grid) with NNC’s and relevant information defined
in G.nnc.</p></li>
<li><p><strong>T</strong> – Face transmissibilities.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>gridFracture2D, assembleGlobalGrid, frac_matrix_nc, frac_frac_nnc</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.fracMatrixConnections">
<span class="sig-name descname"><span class="pre">fracMatrixConnections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">Gfrac</span></em>, <em class="sig-param"><span class="pre">CItot</span></em>, <em class="sig-param"><span class="pre">possible_cells</span></em>, <em class="sig-param"><span class="pre">area</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.fracMatrixConnections" title="Permalink to this definition"></a></dt>
<dd><p>fracMatrixConnections assigns a “non-neighboring connection (NNC)” status
to each fracture-matrix connection and also assigns a transmissibility to
each NNC given the total conductivity index of the fracture. See Lee et
al, Water Resources Research, 2001 or SPE-65095-PA, Lee et al, 2000.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.frac_frac_nnc">
<span class="sig-name descname"><span class="pre">frac_frac_nnc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">F</span></em>, <em class="sig-param"><span class="pre">fracture</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.frac_frac_nnc" title="Permalink to this definition"></a></dt>
<dd><p>frac_frac_nnc assigns NNC connections to fracture-fracture intersections
and also assigns a transmissibility to each connection using the
star-delta transformation. See see SPE-88812-PA, Karimi-Fard et al, 2004.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">frac_frac_nnc</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">fracture</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure containing G.FracGrid (see
FracTensorGrid2D) and corresponding rock properties for
the fracture.</p></li>
<li><p><strong>F</strong> – Output from gridFracture2D.</p></li>
<li><p><strong>fracture</strong> – Output from gridFracture2D.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid structure with fracture-fracture intersections and their
transmissibilities added in the cell lists ‘G.nnc.cells’ and
‘G.nnc.T’ respectively. To aid in detecting specific NNC types,
these connections are added as ‘star-delta’ type in the list
‘G.nnc.type’</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>assembleFracNodes2D, gridFracture2D, frac_matrix_nnc</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.frac_frac_nnc_extruded">
<span class="sig-name descname"><span class="pre">frac_frac_nnc_extruded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">Gl</span></em>, <em class="sig-param"><span class="pre">F</span></em>, <em class="sig-param"><span class="pre">fracture</span></em>, <em class="sig-param"><span class="pre">flayers</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.frac_frac_nnc_extruded" title="Permalink to this definition"></a></dt>
<dd><p>frac_frac_nnc_extruded assigns NNC connections to fracture-fracture
intersections (similar to its 2D counterpart frac_frac_nnc) and also
assigns a transmissibility to each connection using the star-delta
transformation. See see SPE-88812-PA, Karimi-Fard et al, 2004. The NNC’s
are first identified in 2D and then extruded to 3D.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.frac_matrix_nnc">
<span class="sig-name descname"><span class="pre">frac_matrix_nnc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">F</span></em>, <em class="sig-param"><span class="pre">fracture</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.frac_matrix_nnc" title="Permalink to this definition"></a></dt>
<dd><p>frac_matrix_nnc assigns a “non-neighboring connection (NNC)” indicators
to each fracture-matrix connection and also assigns a transmissibility to
each NNC. See Lee et al, Water Resources Research, 2001 or SPE-65095-PA,
Lee et al, 2000.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">frac_matrix_nnc</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">fracture</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure containing G.FracGrid (see
FracTensorGrid2D) and G.cells.fracture (see markcells2D
and CIcalculator2D)</p></li>
<li><p><strong>F</strong> – Output from gridFracture2D.</p></li>
<li><p><strong>fracture</strong> – Output from gridFracture2D.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid structure with fracture-matrix connections  at fine scale and
their corresponding CI added in ‘G.nnc’ as lists ‘G.nnc.cells’ and
‘G.nnc.CI’ respectively. To aid in detecting specific NNC types,
these connections are added as ‘frac-matrix’ type in the list
G.nnc.type</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>getIndepNetwork, markcells2D, CIcalculator2D, gridFracture2D,
frac_frac_nnc</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.getIndepNetwork">
<span class="sig-name descname"><span class="pre">getIndepNetwork</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">fl</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.getIndepNetwork" title="Permalink to this definition"></a></dt>
<dd><p>getIndepNetwork(fl) extracts independant fracture networks from a set of
‘n’ fracture lines given by an n-by-4 matrix with each row containing the
end points of a fracture line. This function is used when the matrix is
two-dimensional.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">frac</span> <span class="p">=</span> <span class="n">getIndepNetwork</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fl</strong> – fracture lines represented by it’s end points as [x1 y1 x2 y2]. fl
will have 1 row per fracture line.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>frac</strong> – Structure containing information about individual fractures
with the following sub-structures: (a) lines - Structure with
the fields “network”</p>
<blockquote>
<div><p>(network to each fracture belongs), “endp”
(endpoints of each fracture line as supplied by
‘fl’) and “cells” (matrix cells containing the
fracture) . Size = 1-by-rows(fl).</p>
</div></blockquote>
<ol class="loweralpha simple" start="2">
<li><dl class="simple">
<dt>network - stores indices for fracture lines contained in</dt><dd><p>each network.</p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>markcells2D</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.makeLayers">
<span class="sig-name descname"><span class="pre">makeLayers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">nl</span></em>, <em class="sig-param"><span class="pre">flayers</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.makeLayers" title="Permalink to this definition"></a></dt>
<dd><p>This function extrudes the matrix grid and independent fracture grid
given the number of layers.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Gl</span> <span class="p">=</span> <span class="n">makeLayers</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nl</span><span class="p">,</span><span class="n">flayers</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Matrix grid structure post fracture processing and
gridding.</p></li>
<li><p><strong>nl</strong> – Number of extruded layers.</p></li>
<li><p><strong>flayers</strong> – Indices of extruded layers in which fractures are present.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Gl</strong> – Extruded matrix grid structure with extruded fracture grids
stored in Gl.FracGrid.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>makeLayeredGrid</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.makeNNCextruded">
<span class="sig-name descname"><span class="pre">makeNNCextruded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">Gl</span></em>, <em class="sig-param"><span class="pre">F</span></em>, <em class="sig-param"><span class="pre">fracture</span></em>, <em class="sig-param"><span class="pre">flayers</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.makeNNCextruded" title="Permalink to this definition"></a></dt>
<dd><p>makeNNCextruded identifies fracture-matrix and fracture-fracture
connections and computes a single transmissibility for each connection.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Gl</span><span class="p">,</span><span class="n">T</span><span class="p">]</span> <span class="p">=</span> <span class="n">makeNNCextruded</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">Gl</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">fracture</span><span class="p">,</span><span class="n">flayers</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>defineNNCandTrans first recognizes all fracture-matrix connections in
2D and stores them as non-neighboring connections (NNC’s) following
which these connections are added to the layerd grid. Then, the
global grid ‘G’ containing both fracture and matrix grid cells (in 3D) is
assembled. Next, fracture-fracture connections (at
intersections) are defined as NNC’s and added to the global grid. The
script also computes transmissibilities for these NNC’s using rock
properties defined in G. This function calls frac_matrix_nnc,
frac_frac_nnc, assembleGlobalGrid and computeTrans internally.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure containing G.FracGrid (see
FracTensorGrid2D) with corresponding rock properties and
G.cells.fracture (see markcells2D and CIcalculator2D)</p></li>
<li><p><strong>Gl</strong> – Extruded matrix and fracture grids. See makeLayers</p></li>
<li><p><strong>F</strong> – Output from gridFracture2D.</p></li>
<li><p><strong>fracture</strong> – Output from gridFracture2D.</p></li>
<li><p><strong>flayers</strong> – Indices of extruded layers in which fractures are present.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>Gl</strong> – Global extruded grid structure with matrix and fracture assemblies
combined into a single grid. NNC’s and other relevant information
is defined in G.nnc.</p></li>
<li><p><strong>T</strong> – Face transmissibilities.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>assembleGlobalGrid, frac_matrix_nc, frac_frac_nnc_extruded, makeLayers</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.markcells">
<span class="sig-name descname"><span class="pre">markcells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fracplanes</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.markcells" title="Permalink to this definition"></a></dt>
<dd><p>markcells returns the indices of matrix cells that are connected with
each fracture.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.markcells2D">
<span class="sig-name descname"><span class="pre">markcells2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">frac</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.markcells2D" title="Permalink to this definition"></a></dt>
<dd><p>markcells2D assigns a indicator to cells containing embedded fractures or
discrete fractures at any of its faces. Indices of fracture lines and
networks are also stored for the corresponding cells. Each fracture is
assumed to be a line by this function. See processFracture2D for details
on input and output.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.preProcessingFractures">
<span class="sig-name descname"><span class="pre">preProcessingFractures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fracplanes</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.preProcessingFractures" title="Permalink to this definition"></a></dt>
<dd><p>preProcessingFractures identifies fracture-matrix connections, imposes a
fracture grid and computes the fracture-matrix conductivity index.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">G</span><span class="p">,</span><span class="n">fracplanes</span><span class="p">]</span> <span class="p">=</span> <span class="n">preProcessingFractures</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fracplanes</span><span class="p">)</span>
<span class="p">[</span><span class="n">G</span><span class="p">,</span><span class="n">fracplanes</span><span class="p">]</span> <span class="p">=</span> <span class="n">preProcessingFractures</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fracplanes</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure containing geometrical information.</p></li>
<li><p><strong>fracplanes</strong> – 1-by-n structure where n is the number of fractures. Each
column contains a set of coplanar points that define
the fracture polygon and a value for the fracture
aperture.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>fractureGridType</strong> – Type of fracture mesh desired. Possible options:
(a) 1 - Cartesian mesh: Possible only when the
fracture plane is rectangular.</p>
<p>(b) 2 - Triangle mesh: Uses the external library
‘distmesh’ to create the nodes and connectivity
list required to create a triangular grid.</p>
<p>(c) 3 - PEBI mesh: Voronoi grid. External
library ‘distmesh’ required to create underlying
triangulation.</p>
</li>
<li><p><strong>fractureCellSize</strong> – Dimensionless element size (&gt;0 and &lt;1) for the
fracture grid.</p></li>
<li><p><strong>GlobTri</strong> – See globalTriangulation.</p></li>
<li><p><strong>pointDensity</strong> – A measure to control the number density of points
generated on a fracture plane for processing
purposes.</p></li>
<li><p><strong>inPolygonTolerance</strong> – Tolerance for checking if a set of points lie
inside a polygon.</p></li>
<li><p><strong>uniqueTolerance</strong> – Tolerance for the matlab function unique.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure with added fields G.nnc and
G.FracGrid. G.FracGrid contains the grid information for
each fracture. G.nnc contains relevant information
about fracture matrix connections, which are defined as
NNC’s to compute transmissibilities.</p></li>
<li><p><strong>fracplanes</strong> – Structure with added fields normal and boundNormals for
each fracture polygon.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>markcells, getPlaneNormals, gridPlanarFracture, fracMatrixConnections</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.processing.processFracture2D">
<span class="sig-name descname"><span class="pre">processFracture2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fl</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.processing.processFracture2D" title="Permalink to this definition"></a></dt>
<dd><p>processFracture2D extracts independant fracture networks and stores
matrix cells containing fractures given a matrix grid and a set of
fracture lines in two dimensions.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">G</span><span class="p">,</span><span class="n">fracture</span><span class="p">]</span> <span class="p">=</span> <span class="n">processFracture2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fl</span><span class="p">)</span>
<span class="p">[</span><span class="n">G</span><span class="p">,</span><span class="n">fracture</span><span class="p">]</span> <span class="p">=</span> <span class="n">processFracture2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure.</p></li>
<li><p><strong>fl</strong> – fracture lines represented by it’s end points as [x1 y1 x2 y2]. fl
will have 1 row per fracture line. Size = nf-by-1.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>verbose</strong> – Enable output.  Default value dependent upon global verbose
settings of function ‘mrstVerbose’.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul>
<li><p><strong>G</strong> – Grid data structure with an added cell list G.cells.fracture
containing indicator values for cells containing fractures
as well as the indices of those fractures.</p></li>
<li><p><strong>fracture</strong> –</p>
<dl class="simple">
<dt>Structure containing information about individual fractures</dt><dd><p>with the following sub-structures:</p>
</dd>
</dl>
<ol class="loweralpha simple">
<li><dl class="simple">
<dt>lines - Structure with the fields “network”</dt><dd><p>(network to each fracture belongs), “endp”
(endpoints of each fracture line as supplied by
‘fl’) and “cells” (matrix cells containing the
fracture) . Size = 1-by-rows(fl).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>network - stores indices for fracture lines contained in</dt><dd><p>each network.</p>
</dd>
</dl>
</li>
</ol>
</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function calls getIndepNetwork and markcells2D internally.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>getIndepNetwork, markcells2D</p>
</div>
</dd></dl>

<span class="target" id="module-hfm.gridding"></span><dl class="mat function">
<dt class="sig sig-object mat" id="hfm.gridding.FracTensorGrid2D">
<span class="sig-name descname"><span class="pre">FracTensorGrid2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">F</span></em>, <em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.gridding.FracTensorGrid2D" title="Permalink to this definition"></a></dt>
<dd><p>FracTensorGrid2D uses information about each fracture line supplied by
‘F’ obtained through assembleFracNodes2D and creates a tensorGrid for
each fracture line using the fracture aperture ‘a’.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">FracTensorGrid2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
<span class="n">G</span> <span class="p">=</span> <span class="n">FracTensorGrid2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="s">&#39;plot&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Matrix grid data structure.</p></li>
<li><p><strong>F</strong> – Structure containing information abo’Frac’ut partitioned fracture
lines as returned by assembleFracNodes2D.</p></li>
<li><p><strong>a</strong> – Fracture aperture, Must either have a single value for all
fracture lines or an individual value for each fracture line.
Varying fracture apartures for one line are not supported.</p></li>
</ul>
</dd>
</dl>
<p>OPTIONAL PARAMETER:</p>
<blockquote>
<div><p>‘plot’ - Plot all fracture grid structures returned under G.FracGrid.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure with sub-structure G.FracGrid. G.FracGrid in-turn
contains a grid structure for each fracture line with nomenclature
such as Frac1, Frac2, and so on. G.FracGrid.Frac1, for example,
will have the same basic grid structure as G.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>assembleFracNodes2D, tensorGrid</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.gridding.assembleFracGrid">
<span class="sig-name descname"><span class="pre">assembleFracGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.gridding.assembleFracGrid" title="Permalink to this definition"></a></dt>
<dd><p>assembleFracGrid assembles a grid (Gf) containing only fractures using
the global grid (G) containing both fracture and matrix information.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Gf</span> <span class="p">=</span> <span class="n">assembleFracGrid</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Grid structure with fractures (see assembleGlobalGrid)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Gf</strong> – Grid structure containing all fracture lines as 1 grid.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function assumes that each fracture grid is represented as a
cartesian grid. Underlying matrix grid structure as in ‘G’ can be
cartesian or unstructured. Fracture intersections exist as NNC’s
(Gf.nnc.cells) in the returned grid Gf. Transmissibility at these
intersections can also be found in Gf.nnc. Fracture-matrix connections
do not exist in the output grid.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>assembleGlobalGrid</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.gridding.assembleFracNodes2D">
<span class="sig-name descname"><span class="pre">assembleFracNodes2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fracture</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.gridding.assembleFracNodes2D" title="Permalink to this definition"></a></dt>
<dd><p>assembleFracNodes2D partitions fracture lines to generate nodes for
gridding</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">F</span><span class="p">,</span><span class="n">fracture</span><span class="p">]</span> <span class="p">=</span> <span class="n">assembleFracNodes2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fracture</span><span class="p">);</span>
<span class="p">[</span><span class="n">F</span><span class="p">,</span><span class="n">fracture</span><span class="p">]</span> <span class="p">=</span> <span class="n">assembleFracNodes2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fracture</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p class="rubric">Description:</p>
<p>This function supports 3 possible options to divide a fracture for
gridding. The resulting output can be thought of as a 1D grid for each
fracture line. From preliminary experiments, option/type 1 has proved
to be the cheapest way to ensure relatively uniform gridding with
similar resolution throughout all fractures. For each assemblyType
fracture intersections will be a node on each of the intersecting line.
This is because transmissibility at these intersections is determined
using the star-delta transformation (see SPE-88812-PA, Karimi-Fard et
al, 2004). Hence, the intersection must be a fine-scale face when the
intersecting fractures are represented as narrow 2D cells in the global
grid.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Matrix grid structure.</p></li>
<li><p><strong>fracture</strong> – Structure containing information about fracture networks,
independent fractures and their conductivity towards the
matrix cells they penetrate. See processFracture2D.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul>
<li><p><strong>assemblyType</strong> – Possible values: 1, 2 or 3.
1. Partition fracture grid based on a minimum and</p>
<blockquote>
<div><p>mean desired cell size as specified by the user.</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>Partition fracture grid by specifying a cell size
ratio (&lt;=1) with respect to total length. ex: If
cell size ratio is 0.1, then each fracture will be
partitioned into ~1/0.1=10 parts. Not a good option
when individual fracture length varies by orders of
magnitude.</p></li>
<li><p>1 fracture cell for every matrix cell that fracture
penetrates.</p></li>
</ol>
</li>
<li><p><strong>min_size</strong> – Scalar quantity, useful only if assemblyType = 1 or 2.
For assemblyType = 1, min_size specifies the minimum
cell size the fracture fine grid can have. The function
will override this option if there exist fractures
which are smaller than min_size. For assemblyType = 2,
min_size is used to determine maximum number of
divisions (~1/min_size) for a fracture line.</p></li>
<li><p><strong>cell_size</strong> – Scalar quantity, useful only if assemblyType = 1 or 2.
For assemblyType = 1, cell_size specifies the average
cell size in the fracture fine grid. For assemblyType =
2, cell_size is used to determine average number of
divisions (~1/cell_size) for a fracture line.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul>
<li><p><strong>F</strong> – Structure with the following sub-structures per fracture line:
(a) nodes - contains the following subfields</p>
<blockquote>
<div><ul class="simple">
<li><p>start - start index w.r.t. global node numbers for the
corresponding fracture line</p></li>
<li><p>coords - node coordinates for the corresponding line</p></li>
</ul>
</div></blockquote>
<ol class="loweralpha" start="2">
<li><p>cells - contains the following subfields
-   start - start index w.r.t. global cell numbers for the</p>
<blockquote>
<div><p>corresponding fracture line</p>
</div></blockquote>
<ul class="simple">
<li><p>num - Number of grid cells in the corresponding fracture
line</p></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>fracture</strong> – structure with the added structure - ‘intersections’ which
contains the following fields:
(a) lines - n-by-2 matrix of pairs of intersecting lines
where n is the total number of fracture intersections.
(b) coords - coordinates of intersection correspondng to
field lines</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there is more than 1 fracture ‘intersection’ within 1 matrix fine
cell, do not use assemblyType = 3.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>processFracture2D, getIndepNetwork, markcells2D</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.gridding.assembleGlobalGrid">
<span class="sig-name descname"><span class="pre">assembleGlobalGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Gm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.gridding.assembleGlobalGrid" title="Permalink to this definition"></a></dt>
<dd><p>assembleGlobalGrid combines matrix and fracture grids into 1 global grid.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="p">=</span> <span class="n">assembleFracGrid</span><span class="p">(</span><span class="n">Gm</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>G</strong> – Matrix grid data structure (passed through computeGeometry)
containing G.FracGrid as returned by FracTensorGrid2D.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – Grid structure containing both matrix and fracture cells and
information about fracture-matrix NNC connections</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function assumes that each fracture grid is represented as a
cartesian grid. Underlying matrix grid structure as in ‘Gm’ can be
cartesian or unstructured.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>FracTensorGrid2D</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.gridding.gridFracture2D">
<span class="sig-name descname"><span class="pre">gridFracture2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fracture</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.gridding.gridFracture2D" title="Permalink to this definition"></a></dt>
<dd><p>gridFracture2D imposes a fracture grid given the underlying matrix grid,
information about the fracture lines and desired grid resolution
(optional).</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">G</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">fracture</span><span class="p">]</span> <span class="p">=</span> <span class="n">gridFracture2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fracture</span><span class="p">)</span>
<span class="p">[</span><span class="n">G</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">fracture</span><span class="p">]</span> <span class="p">=</span> <span class="n">gridFracture2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fracture</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Matrix grid structure with the sub-structure
G.cells.fracture. See processFracture2D.</p></li>
<li><p><strong>fracture</strong> – Structure containing information about fracture networks,
independent fractures and their conductivity towards the
matrix cells they penetrate. See processFracture2D.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>Same as assembleFracNodes2D</strong></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Matrix grid structure with sub-structure G.FracGrid (see
FracTensorGrid2D).</p></li>
<li><p><strong>F</strong> – Same as assembleFracNodes2D.</p></li>
<li><p><strong>fracture</strong> – structure with the added structure - ‘intersections’ which
contains the following fields:
(a) lines - n-by-2 matrix of pairs of intersecting lines
where n is the total number of fracture intersections.
(b) coords - coordinates of intersection correspondng to
field lines</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function calls assembleFracNodes2D and FracTensorGrid2D
internally</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>assembleFracNodes2D, FracTensorGrid2D, processFracture2D,
getIndepNetwork, markcells2D, tensorGrid</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.gridding.gridPlanarFracture">
<span class="sig-name descname"><span class="pre">gridPlanarFracture</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fracplane</span></em>, <em class="sig-param"><span class="pre">scaledplane</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.gridding.gridPlanarFracture" title="Permalink to this definition"></a></dt>
<dd><p>This function can be used to grid a planar fracture using a cartesian,
triangular or PEBI mesh. See preProcessingFractures for input options.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">Gf</span> <span class="p">=</span> <span class="n">gridPlanarFracture</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fracplane</span><span class="p">,</span> <span class="n">scaledplane</span><span class="p">)</span>
<span class="n">Gf</span> <span class="p">=</span> <span class="n">gridPlanarFracture</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fracplane</span><span class="p">,</span> <span class="n">scaledplane</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure containing geometrical information.</p></li>
<li><p><strong>fracplane</strong> – Structure containing a set of coplanar points that define
the fracture polygon and a value for the fracture
aperture.</p></li>
<li><p><strong>scaledplane</strong> – Same as fracplane with geometrical information in
dimensionless form.</p></li>
</ul>
</dd>
</dl>
<p>OPTIONAL PARAMETERS (supplied in ‘key’/value pairs (‘pn’/pv …)):</p>
<blockquote>
<div><dl>
<dt>gridType           - Type of fracture mesh desired. Possible options:</dt><dd><p>(a) 1 - Cartesian mesh: Possible only when the
fracture plane is rectangular.</p>
<p>(b) 2 - Triangle mesh: Uses the external library
‘distmesh’ to create the nodes and connectivity
list required to create a triangular grid.</p>
<p>(c) 3 - PEBI mesh: Voronoi grid. External
library ‘distmesh’ required to create underlying
triangulation.</p>
</dd>
<dt>cellSize           - Dimensionless element size (&gt;0 and &lt;1) for the</dt><dd><p>fracture grid.</p>
</dd>
</dl>
<p>rectangular        - Indicates if the fracture plane is a rectangle.</p>
<dl class="simple">
<dt>minTriangles       - Can be used to set a minimum on the number of</dt><dd><p>cells for a triangular grid.</p>
</dd>
<dt>scale              - Scaling factor for fracture cellSize. Useful when</dt><dd><p>physical dimensions vary by orders of magnitude in
each direction. Not used if cellSize is provided
as input.</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>Gf</strong> – Fracture grid structure with geometrical information.</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-hfm.plotting"></span><dl class="mat function">
<dt class="sig sig-object mat" id="hfm.plotting.plotCI">
<span class="sig-name descname"><span class="pre">plotCI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fracture</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.plotting.plotCI" title="Permalink to this definition"></a></dt>
<dd><p>plotCI plots conductivity index as matrix cell data for all fracture
lines</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.plotting.plotFracData2D">
<span class="sig-name descname"><span class="pre">plotFracData2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">data</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.plotting.plotFracData2D" title="Permalink to this definition"></a></dt>
<dd><p>plotFracData plots data inside fracture cells only, given a grid with
matrix and fractures. The function is designed for 2D grids.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotFracData2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
 <span class="n">plotFracData2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotFracData2D</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure with fractures as defined by
assembleGlobalGrid.</p></li>
<li><p><strong>data</strong> – data to plot with values inside fracture cells only. Matrix data
is ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>wide</strong> – This option can be used to redefine a fracture grid (by
recalling FracTensorGrid2D) with larger aperture for
plotting purposes. Can be thought of as an
exaggerated/magnified fracture grid.</p></li>
<li><p><strong>width</strong> – fracture width/aperture in m if key ‘wide’ is used.</p></li>
<li><p><strong>F</strong> – Structure containing information about partitioned
fracture lines as returned by assembleFracNodes2D. See
also gridFracture.</p></li>
<li><p><strong>CG</strong> – Fracture coarse grid as returned by getRsbGrids_HFM.</p></li>
<li><p><strong>cmap</strong> – Colormap desired. default = jet.</p></li>
<li><p><strong>outline</strong> – If true, matrix coarse grid will be outlined.</p></li>
<li><p><strong>outlineCoarseNodes</strong> – If true, will outline fracture coarse nodes.</p></li>
<li><p><strong>plotMatrix</strong> – If true, plots matrix grid as well.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to polygonal patch structure as defined by function
plotFaces.  OPTIONAL.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>outlineCoarseGrid, plotToolbar, patch</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.plotting.plotFractureCoarseGrid2D">
<span class="sig-name descname"><span class="pre">plotFractureCoarseGrid2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">F</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.plotting.plotFractureCoarseGrid2D" title="Permalink to this definition"></a></dt>
<dd><p>plotFractureCoarseGrid(G, p, F) plots the fracture and matrix coarse
grids for a 2D domain. This function uses rand() to generate colours for
plotting fracture coarse cells.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotFractureCoarseGrid2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
 <span class="n">plotFractureCoarseGrid2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotFractureCoarseGrid2D</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure with fractures as assembled by
assembleGlobalGrid.</p></li>
<li><p><strong>p</strong> – Partition vector for the coarse grid.</p></li>
<li><p><strong>F</strong> – see assembleFracNodes2D.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><p><strong>showNumbering</strong> – If true, plots the fracture coarse block numbers.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to polygonal patch structure as defined by function
plotFaces.  OPTIONAL.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>assembleFracNodes2D, outlineCoarseGrid</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.plotting.plotFractureLines">
<span class="sig-name descname"><span class="pre">plotFractureLines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">fracture</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.plotting.plotFractureLines" title="Permalink to this definition"></a></dt>
<dd><p>This function plots the fracture lines using the fracture structure
returned by processFracture2D.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotFractureLines</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fracture</span><span class="p">)</span>
 <span class="n">plotFractureLines</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">fracture</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="p">...)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotFractureLines</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Grid data structure with fractures as assembled by
assembleGlobalGrid.</p></li>
<li><p><strong>fracture</strong> – See processFracture2D.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>show</strong> – Takes string values ‘lines’ or ‘network’ to indicate if
each fractures should be coloured using its corresponding
fracture line index or fracture network index,
respectively. Only works if no line numbers are provided
using the second optional argument.</p></li>
<li><p><strong>lineNumbers</strong> – Indices of fracture lines to be plotted. If provided, the
above optional parameter is ignored.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to polygonal patch structure as defined by function
plotFaces.  OPTIONAL.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>processFracture2D</p>
</div>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="hfm.plotting.plotFractureNodes2D">
<span class="sig-name descname"><span class="pre">plotFractureNodes2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">F</span></em>, <em class="sig-param"><span class="pre">fracture</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#hfm.plotting.plotFractureNodes2D" title="Permalink to this definition"></a></dt>
<dd><p>plotFractureNodes2D plots the 1D fracture grid defined in F as returned
by assembleFracNodes2D.</p>
<p class="rubric">Synopsis:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span> <span class="n">plotFractureNodes2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">fracture</span><span class="p">)</span>
 <span class="n">plotFractureNodes2D</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">fracture</span><span class="p">,</span> <span class="s">&#39;pn1&#39;</span><span class="p">,</span> <span class="n">pv1</span><span class="p">)</span>

<span class="n">h</span> <span class="p">=</span> <span class="n">plotFractureNodes2D</span><span class="p">(...)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – Matrix grid structure as returned by gridFracture2D.</p></li>
<li><p><strong>F</strong> – Fracture grid structure as returned by gridFracture2D.</p></li>
<li><p><strong>fracture</strong> – See gridFracture2D.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>linewidth</strong> – width of fracture line. Passed as a LineSpec in the
matlab function ‘plot’.</p></li>
<li><p><strong>markersize</strong> – Size of markers indicating fracture nodes. Passed as a
LineSpec in the matlab function ‘plot’.</p></li>
<li><p><strong>shownumbering</strong> – If shownumbering = 1, global cell numbers are also
plotted for the fractures. Might not be readable when
the fracture grid is too fine or there are too many
fractures.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>h</strong> – Handle to resulting patch object.  The patch object is added
directly to the current AXES object (GCA).
OPTIONAL.  Only returned if specifically requested.  If
ISEMPTY(cells), then h==-1.</p>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h2>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="heterogeneity.html" class="btn btn-neutral float-left" title="heterogeneity" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="incomp.html" class="btn btn-neutral float-right" title="incomp: Solvers for incompressible flow and transport" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, SINTEF Digital.
      <span class="lastupdated">Last updated on Sep 23, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>